//


// vec4 unprojectPos(in vec2 coord, in float depth) { 
//     vec4 fragposition = in_matrix_3D.proj_inv * vec4(coord.s * 2.0f - 1.0f, coord.t * 2.0f - 1.0f, 2.0f * depth - 1.0f, 1.0f);
//     fragposition /= fragposition.w;
//     return fragposition;
// }

float calcStepSize(float stepSize, float maxStep, vec3 n, vec3 cam) {
	float scalarProduct = max(0, dot(n, cam));
	float res = 0.0;
	
	res = (1.0 - scalarProduct) * (maxStep-stepSize);
	
	return res + stepSize;
}
// Umwandlung einer Weltkoordinate in Screenkoordinate!
vec3 getScreenPos (vec3 worldPos) {
	vec4 screenPos 	= worldMVP * vec4(worldPos, 1.0);
	vec3 screenPos3	= screenPos.xyz / screenPos.w;
	return (screenPos3 + vec3(1.0)) / 2.0;
}


vec3 raytrace(in vec3 reflectionWorld, in int maxCount, in float stepSize, in vec3 worldposition, out bool hit) {
	vec3 color = vec3(1.0); 	
	vec3 testVec = worldposition;
	
	vec3 reflectionVector = reflectionWorld * stepSize;
	
	vec3 screenPos		= getScreenPos(testVec);
	vec2 screenTexPos 	= screenPos.xy;
	
	
	float depthFrag = texture(texDepth, screenTexPos).x;
	float worldDepth = screenPos.z;
	
	bool run = true;
	int count = 0;
	hit = false;

	while (run) {
		
		depthFrag = texture(texDepth, screenTexPos).x;
		worldDepth = screenPos.z;
		
		if (depthFrag <= worldDepth) {
			hit = true;
			color = texture(texColor, screenTexPos).rgb;
			break;
		}
		
		testVec 		= testVec + reflectionVector;
		screenPos		= getScreenPos(testVec);
		screenTexPos 	= screenPos.xy;
		
		count = count+1;
		run = 	screenTexPos.x < 1.0 && screenTexPos.x >= 0.0 &&
				screenTexPos.y < 1.0 && screenTexPos.y >= 0.0 && count < maxCount;
	}
	
	if (!run) {
		// color = cubeMapRefl(testVec);
		// Cheating
		color = vec3(0,1,1);
	}
	
	return color;
} 