nidefawl.qubes.BootClient -> nidefawl.qubes.BootClient:
    12:28:java.lang.String getValue(java.lang.String[],int,java.lang.String) -> getValue
    31:85:void main(java.lang.String[]) -> main
nidefawl.qubes.Game -> Ij1LIjL1jIL1iJIj:
    nidefawl.qubes.Game instance -> do
    nidefawl.qubes.PlayerProfile profile -> do
    nidefawl.qubes.config.ClientSettings settings -> do
    nidefawl.qubes.gui.GuiOverlayStats statsOverlay -> do
    nidefawl.qubes.gui.GuiCached statsCached -> do
    nidefawl.qubes.gui.GuiOverlayDebug debugOverlay -> do
    nidefawl.qubes.gui.GuiOverlayChat chatOverlay -> do
    nidefawl.qubes.gui.Gui gui -> do
    nidefawl.qubes.network.client.ThreadConnect connect -> do
    nidefawl.qubes.network.client.NetworkClient client -> do
    nidefawl.qubes.world.WorldClient world -> do
    nidefawl.qubes.entity.PlayerSelf player -> do
    nidefawl.qubes.input.InputController movement -> do
    nidefawl.qubes.input.DigController dig -> do
    nidefawl.qubes.input.Selection selection -> do
    boolean follow -> do
    nidefawl.qubes.item.BlockStack selBlock -> do
    long lastShaderLoadTime -> do
    nidefawl.qubes.vec.Vector3f vCam -> do
    nidefawl.qubes.vec.Vector3f vPlayer -> if
    nidefawl.qubes.vec.Vector3f vLastCam -> for
    nidefawl.qubes.vec.Vector3f vLastPlayer -> int
    boolean updateRenderers -> if
    nidefawl.qubes.gl.TesselatorState debugChunks -> do
    boolean showGrid -> for
    boolean thirdPerson -> int
    boolean reinittexthook -> new
    boolean wasGrabbed -> try
    java.lang.String serverAddr -> do
    boolean testMode -> byte
    int skipChars -> do
    nidefawl.qubes.item.BaseStack testStack -> do
    nidefawl.qubes.item.BaseStack testStack2 -> if
    nidefawl.qubes.input.GameMode mode -> do
    float[] loadProgress -> do
    int throttleClick -> if
    108:108:nidefawl.qubes.input.GameMode getMode() -> do
    113:125:void connectTo(java.lang.String) -> do
    133:171:void initGame() -> do
    174:174:boolean loadRender(int,float) -> do
    177:251:boolean loadRender(int,float,java.lang.String) -> do
    254:266:void lateInitGame() -> if
    269:279:void toggleGameMode() -> for
    302:303:void reposModel() -> int
    306:316:void setWorld(nidefawl.qubes.world.WorldClient) -> do
    320:324:void shutdown() -> new
    331:341:void onTextInput(long,int) -> do
    345:377:void onKeyPress(long,int,int,int,int) -> do
    381:420:void onWheelScroll(long,double,double) -> do
    423:465:void onMouseClick(long,int,int,int) -> do
    469:476:void input(float) -> do
    479:486:void setGrabbed(boolean) -> do
    493:918:void render(float) -> if
    922:938:void onStatsUpdated() -> try
    942:943:void postRenderUpdate(float) -> for
    946:1044:void preRenderUpdate(float) -> int
    1048:1075:void showGUI(nidefawl.qubes.gui.Gui) -> do
    1079:1090:void updateInput() -> byte
    1094:1116:void onResize(int,int) -> do
    1119:1141:void tick() -> case
    1144:1151:void returnToMenu() -> char
    1154:1154:boolean isConnected() -> do
    1158:1161:void addDebugOnScreen(java.lang.String) -> if
    1164:1164:nidefawl.qubes.world.World getWorld() -> do
    1168:1175:void setConnection(nidefawl.qubes.network.client.NetworkClient) -> do
    1178:1178:nidefawl.qubes.entity.PlayerSelf getPlayer() -> do
    1182:1183:void setPlayer(nidefawl.qubes.entity.PlayerSelf) -> do
    1186:1189:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    1192:1192:nidefawl.qubes.PlayerProfile getProfile() -> do
    1200:1205:void saveSettings() -> else
    1208:1213:void saveProfile() -> goto
    1216:1223:void loadProfile() -> long
    1226:1233:void loadSettings() -> this
    1240:1257:void blockClicked(nidefawl.qubes.util.RayTrace$RayTraceIntersection,boolean) -> do
    1270:1270:nidefawl.qubes.input.Selection getSelection() -> do
    1274:1274:nidefawl.qubes.gui.Gui getGui() -> do
nidefawl.qubes.GameBase -> jI1LJi1LllJi:
    java.lang.String appName -> if
    int displayWidth -> for
    int displayHeight -> int
    boolean GL_ERROR_CHECKS -> case
    long windowId -> if
    int initWidth -> new
    int initHeight -> try
    int TICKS_PER_SEC -> byte
    org.lwjgl.glfw.GLFWErrorCallback errorCallback -> do
    org.lwjgl.glfw.GLFWWindowSizeCallback cbWindowSize -> do
    org.lwjgl.glfw.GLFWKeyCallback cbKeyboard -> do
    org.lwjgl.glfw.GLFWMouseButtonCallback cbMouseButton -> do
    org.lwjgl.glfw.GLFWScrollCallback cbScrollCallback -> do
    org.lwjgl.glfw.GLFWWindowFocusCallback cbWindowFocus -> do
    org.lwjgl.glfw.GLFWCursorPosCallback cbCursorPos -> do
    org.lwjgl.glfw.GLFWCharCallback cbText -> do
    boolean toggleTiming -> char
    boolean DO_TIMING -> else
    float renderTime -> do
    int ticksran -> case
    int lastFPS -> char
    long timeLastFPS -> for
    long timeLastFrame -> int
    nidefawl.qubes.util.Timer timer -> do
    int tick -> else
    boolean startRender -> goto
    nidefawl.qubes.util.GameError showError -> do
    nidefawl.qubes.logging.LogBufferStream outStream -> do
    nidefawl.qubes.logging.LogBufferStream errStream -> if
    long frameTime -> do
    boolean vsync -> long
    boolean running -> this
    boolean wasrunning -> void
    boolean sysExit -> break
    boolean minimized -> catch
    java.lang.Thread thread -> do
    int newWidth -> do
    int newHeight -> if
    nidefawl.qubes.gl.GPUVendor vendor -> do
    java.util.ArrayList glProfileResults -> do
    77:80:void startGame() -> void
    95:95:boolean isRunning() -> if
    99:99:nidefawl.qubes.gl.GPUVendor getVendor() -> do
    105:157:void run() -> run
    160:233:void initCallbacks() -> break
    238:310:void initDisplay(boolean) -> if
    313:321:void destroyContext() -> catch
    324:326:void onDestroy() -> class
    329:331:void shutdown() -> new
    334:362:void checkResize() -> const
    void onStatsUpdated() -> try
    367:369:void setVSync(boolean) -> for
    372:372:boolean getVSync() -> for
    376:376:java.lang.Thread getMainThread() -> do
    380:385:boolean _checkGLError(java.lang.String) -> do
    389:409:java.lang.String getGlErrorString(int) -> do
    414:415:void updateDisplay() -> final
    418:418:boolean isCloseRequested() -> int
    422:432:void setVSync_impl(boolean) -> int
    437:438:void updateInput() -> byte
    441:442:void setTitle(java.lang.String) -> for
    461:544:void runFrame() -> float
    549:549:boolean loadRender(int,float) -> do
    553:579:void mainLoop() -> short
    582:639:void initGLContext() -> super
    642:649:void updateTime() -> throw
    653:769:void showErrorScreen(java.lang.String,java.util.List,java.lang.Throwable,boolean) -> do
    772:773:void setException(nidefawl.qubes.util.GameError) -> do
    779:784:void setTextHook(boolean) -> new
    void onTextInput(long,int) -> do
    void onKeyPress(long,int,int,int,int) -> do
    void onMouseClick(long,int,int,int) -> do
    void onWheelScroll(long,double,double) -> do
    void render(float) -> if
    void input(float) -> do
    void preRenderUpdate(float) -> int
    void postRenderUpdate(float) -> for
    void onResize(int,int) -> do
    void tick() -> case
    void initGame() -> do
    void lateInitGame() -> if
    32:32:int access$002(nidefawl.qubes.GameBase,int) -> do
    32:32:int access$102(nidefawl.qubes.GameBase,int) -> if
nidefawl.qubes.GameBase$1 -> Ij1LL1JiIjIjjI:
    nidefawl.qubes.GameBase this$0 -> do
    165:167:void invoke(long,int,int) -> invoke
nidefawl.qubes.GameBase$2 -> ll1LL1JiiJL1iJL1:
    nidefawl.qubes.GameBase this$0 -> do
    173:177:void invoke(long,int,int,int,int) -> invoke
nidefawl.qubes.GameBase$3 -> jI1LJi1L1LJiiJll:
    nidefawl.qubes.GameBase this$0 -> do
    184:188:void invoke(long,int,int,int) -> invoke
nidefawl.qubes.GameBase$4 -> IjllL1JiJiiJJiJi:
    nidefawl.qubes.GameBase this$0 -> do
    194:200:void invoke(long,double,double) -> invoke
nidefawl.qubes.GameBase$5 -> JiL1lljI1Lll1LL1:
    nidefawl.qubes.GameBase this$0 -> do
    207:211:void invoke(long,int) -> invoke
nidefawl.qubes.GameBase$6 -> Ij1LIjiJllL11LJi:
    nidefawl.qubes.GameBase this$0 -> do
    217:221:void invoke(long,double,double) -> invoke
nidefawl.qubes.GameBase$7 -> iJlljI1LiJiJiJJi:
    nidefawl.qubes.GameBase this$0 -> do
    227:231:void invoke(long,int) -> invoke
nidefawl.qubes.GameRegistry -> iJll1LjIL1IjJiIj:
    java.util.Map terrainGenerators -> do
    java.util.Map terrainPopulators -> if
    34:41:nidefawl.qubes.worldgen.terrain.ITerrainGen newGenerator(nidefawl.qubes.world.WorldServer,nidefawl.qubes.world.WorldSettings) -> do
    46:55:nidefawl.qubes.worldgen.biome.IBiomeManager newBiomeManager(nidefawl.qubes.world.WorldServer,nidefawl.qubes.worldgen.terrain.ITerrainGen,nidefawl.qubes.world.WorldSettings) -> do
    60:76:nidefawl.qubes.worldgen.populator.IChunkPopulator newPopulator(nidefawl.qubes.world.WorldServer,nidefawl.qubes.worldgen.terrain.ITerrainGen,nidefawl.qubes.world.WorldSettings) -> do
    85:85:java.lang.Class getTerrainGen(java.lang.String) -> do
    93:93:java.lang.Class getTerrainPop(java.lang.String) -> if
    97:102:void registerChunkPopulator(java.lang.String,java.lang.Class) -> do
    104:109:void registerTerrainGenerator(java.lang.String,java.lang.Class) -> if
nidefawl.qubes.NativeClassLoader -> nidefawl.qubes.NativeClassLoader:
    nidefawl.qubes.NativeClassLoader instance -> instance
    byte[] cppLoadClass(java.lang.String) -> cppLoadClass
    byte[] cppLoadResource(java.lang.String) -> cppLoadResource
    19:19:java.lang.Class loadClassRedirect(java.lang.String) -> loadClassRedirect
    24:31:java.lang.Class findClass(java.lang.String) -> findClass
    34:36:byte[] loadGameResource(java.lang.String) -> loadGameResource
    40:46:void setLoader() -> setLoader
    52:52:nidefawl.qubes.NativeClassLoader getInstance() -> getInstance
nidefawl.qubes.NativeInterface -> nidefawl.qubes.NativeInterface:
    nidefawl.qubes.NativeInterface instance -> instance
    boolean isPresent -> isPresent
    15:15:nidefawl.qubes.NativeInterface getInstance() -> getInstance
    19:28:void start() -> start
    30:30:boolean isPresent() -> isPresent
    void gameCrashed(nidefawl.qubes.util.CrashInfo) -> gameCrashed
    void gameAlive() -> gameAlive
nidefawl.qubes.PlayerProfile -> IjJillL1ll1LJiL1:
    java.util.UUID uuid -> do
    java.lang.String name -> do
    21:23:void setDefaults() -> do
    34:35:void setName(java.lang.String) -> do
    41:41:java.lang.String getName() -> do
    46:48:void load() -> if
    52:54:void save() -> for
nidefawl.qubes.assets.Asset -> L1JiJiiJ1L1LJiJi:
    nidefawl.qubes.assets.AssetPack pack -> do
    6:7:void setPack(nidefawl.qubes.assets.AssetPack) -> do
    12:12:nidefawl.qubes.assets.AssetPack getPack() -> do
nidefawl.qubes.assets.AssetBinary -> JiL1JiiJIjiJiJ1L:
    byte[] data -> do
    java.lang.String name -> do
    21:34:void load(nidefawl.qubes.assets.AssetInputStream) -> do
    36:36:byte[] getData() -> do
    43:43:java.lang.String getName() -> do
nidefawl.qubes.assets.AssetInputStream -> ll1LIjjIIjL1IjIj:
    nidefawl.qubes.assets.AssetPack source -> do
    java.io.InputStream inputStream -> do
    30:32:void close() -> do
nidefawl.qubes.assets.AssetManager -> jIL1Ij1LIjiJIj:
    nidefawl.qubes.assets.AssetManager instance -> do
    java.util.ArrayList assetPacks -> do
    nidefawl.qubes.shader.ShaderSource lastFailedShader -> do
    java.io.File folder -> do
    boolean externalResources -> do
    19:21:void toggleExternalResources() -> do
    23:23:boolean isExternalResources() -> do
    31:31:nidefawl.qubes.assets.AssetManager getInstance() -> do
    43:74:void init() -> if
    77:99:nidefawl.qubes.assets.AssetInputStream findResource(java.lang.String,boolean) -> do
    125:125:nidefawl.qubes.assets.AssetTexture loadPNGAsset(java.lang.String) -> do
    128:149:nidefawl.qubes.assets.AssetTexture loadPNGAsset(java.lang.String,boolean) -> do
    152:172:nidefawl.qubes.assets.AssetVoxModel loadVoxModel(java.lang.String) -> do
    176:176:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String) -> do
    179:204:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    207:226:nidefawl.qubes.assets.AssetBinary loadBin(java.lang.String) -> do
    230:230:nidefawl.qubes.shader.ShaderSource getLastFailedShaderSource() -> do
nidefawl.qubes.assets.AssetPack -> jI1LiJlliJ1LiJjI:
    nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
nidefawl.qubes.assets.AssetPackClassPath -> JiIjjIiJL1jIiJiJ:
    22:25:nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
    33:33:java.lang.String toString() -> toString
nidefawl.qubes.assets.AssetPackFolder -> IjIjJiJiiJjIjIJi:
    java.io.File directory -> do
    27:33:nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
    38:38:java.lang.String toString() -> toString
nidefawl.qubes.assets.AssetTexture -> IjIjjIJiL1iJ1LJi:
    int width -> if
    int height -> for
    byte[] data -> do
    int slot -> do
    java.lang.String name -> do
    25:32:void load(nidefawl.qubes.assets.AssetInputStream) -> do
    34:34:int getWidth() -> do
    37:37:int getHeight() -> if
    40:40:byte[] getData() -> do
    47:69:void rescale(int) -> do
    75:86:void cutH() -> do
    89:90:void setSlot(int) -> if
    93:93:int getSlot() -> for
    100:100:java.lang.String getName() -> do
nidefawl.qubes.assets.AssetVoxModel -> iJiJ1LllL1L1jI1L:
    nidefawl.qubes.models.voxel.ModelVoxPalette defaultPalette -> do
    java.lang.String name -> do
    nidefawl.qubes.models.voxel.ModelVoxPalette palette -> if
    nidefawl.qubes.vec.BlockPos size -> do
    int[] voxels -> do
    39:44:boolean headerCheck(byte[],java.lang.String) -> do
    47:53:int readInt(java.io.DataInputStream) -> do
    60:118:void load(nidefawl.qubes.assets.AssetInputStream) -> do
    126:128:boolean complete() -> do
nidefawl.qubes.async.AsyncTaskThread -> lliJiJJiJill1L1L:
    java.util.zip.Inflater inflate -> do
    int i10Meg -> do
    byte[] tmpBuffer -> do
    17:27:byte[] inflate(byte[]) -> do
nidefawl.qubes.async.AsyncTasks -> iJIjiJiJlliJ:
    java.util.ArrayList tasks -> do
    java.util.concurrent.ExecutorService service -> do
    16:34:void init() -> do
    36:40:java.util.concurrent.Future submit(nidefawl.qubes.async.IAsyncTask) -> do
    44:67:void completeTasks() -> if
    69:71:void shutdown() -> for
nidefawl.qubes.async.AsyncTasks$1 -> L1llJi1LJiL1jIiJ:
    30:30:java.lang.Thread newThread(java.lang.Runnable) -> newThread
nidefawl.qubes.async.AsyncTasks$2 -> L1Ij1LIjJijIjI1L:
    25:26:void uncaughtException(java.lang.Thread,java.lang.Throwable) -> uncaughtException
nidefawl.qubes.async.IAsyncTask -> iJIjiJllll1LlliJ:
    boolean requiresComplete() -> do
nidefawl.qubes.biome.Biome -> Ij1L1LL1JillIjJi:
    nidefawl.qubes.biome.Biome[] biomes -> do
    int maxBiome -> do
    nidefawl.qubes.biome.Biome MEADOW_GREEN -> do
    nidefawl.qubes.biome.Biome MEADOW_BLUE -> if
    nidefawl.qubes.biome.Biome MEADOW_RED -> for
    nidefawl.qubes.biome.Biome DESERT -> int
    nidefawl.qubes.biome.Biome DESERT_RED -> new
    nidefawl.qubes.biome.Biome ICE -> try
    nidefawl.qubes.biome.Biome MEADOW_GREEN2 -> byte
    int color -> if
    int colorFoliage -> for
    int colorFoliage2 -> int
    int colorLeaves -> new
    int colorGrass -> try
    int id -> byte
    77:93:nidefawl.qubes.biome.Biome setColor(nidefawl.qubes.biome.BiomeColor,int) -> do
    101:102:nidefawl.qubes.biome.Biome setDebugColor(int) -> do
    110:112:nidefawl.qubes.biome.Biome get(int) -> if
    120:136:int getFaceColor(nidefawl.qubes.biome.BiomeColor) -> do
    139:139:nidefawl.qubes.block.Block getStone() -> do
    142:142:nidefawl.qubes.block.Block getTopBlock() -> if
    145:145:nidefawl.qubes.block.Block getSoilBlock() -> for
nidefawl.qubes.biome.Biome$1 -> JiJillL1llIjL1jI:
    int[] $SwitchMap$nidefawl$qubes$biome$BiomeColor -> do
nidefawl.qubes.biome.BiomeColor -> iJ1LiJlljIllIj:
    nidefawl.qubes.biome.BiomeColor GRASS -> do
    nidefawl.qubes.biome.BiomeColor LEAVES -> if
    nidefawl.qubes.biome.BiomeColor FOLIAGE -> for
    nidefawl.qubes.biome.BiomeColor FOLIAGE2 -> int
    nidefawl.qubes.biome.BiomeColor[] $VALUES -> do
    10:10:nidefawl.qubes.biome.BiomeColor[] values() -> values
    10:10:nidefawl.qubes.biome.BiomeColor valueOf(java.lang.String) -> valueOf
nidefawl.qubes.biome.BiomeDesert -> JiIjL1IjiJJi1L1L:
    22:22:nidefawl.qubes.block.Block getStone() -> do
    25:25:nidefawl.qubes.block.Block getTopBlock() -> if
    28:28:nidefawl.qubes.block.Block getSoilBlock() -> for
nidefawl.qubes.biome.BiomeDesertRed -> JiJiJiJiL11LJi1L:
    22:22:nidefawl.qubes.block.Block getStone() -> do
    25:25:nidefawl.qubes.block.Block getTopBlock() -> if
    28:28:nidefawl.qubes.block.Block getSoilBlock() -> for
nidefawl.qubes.biome.BiomeIce -> L1IjjIL1jI1LL1L1:
    20:20:nidefawl.qubes.block.Block getStone() -> do
    24:24:nidefawl.qubes.block.Block getTopBlock() -> if
    28:28:nidefawl.qubes.block.Block getSoilBlock() -> for
nidefawl.qubes.biome.BiomeMeadow -> lllljIJiL1iJIjIj:
nidefawl.qubes.block.Block -> IjjIL1jIJijIJijI:
    nidefawl.qubes.block.Block[] registeredblocks -> if
    short[] registeredblockIds -> do
    nidefawl.qubes.block.Block[] block -> do
    java.lang.String[] NO_TEXTURES -> do
    nidefawl.qubes.block.Block air -> do
    nidefawl.qubes.block.Block grass -> if
    nidefawl.qubes.block.Block dirt -> for
    nidefawl.qubes.block.BlockGroupStones stones -> do
    nidefawl.qubes.block.Block water -> int
    nidefawl.qubes.block.Block sand -> new
    nidefawl.qubes.block.Block sand_red -> try
    nidefawl.qubes.block.Block snow -> byte
    nidefawl.qubes.block.Block ice -> case
    nidefawl.qubes.block.BlockGroupLogs logs -> do
    nidefawl.qubes.block.BlockGroup wood -> do
    nidefawl.qubes.block.BlockGroupLeaves leaves -> do
    nidefawl.qubes.block.Block grassbush -> char
    nidefawl.qubes.block.Block heath -> else
    nidefawl.qubes.block.Block aloe_vera -> goto
    nidefawl.qubes.block.Block nasturtium -> long
    nidefawl.qubes.block.Block thingrass -> this
    nidefawl.qubes.block.Block vines -> void
    nidefawl.qubes.block.Block treemoss -> break
    nidefawl.qubes.block.Block quarter -> catch
    nidefawl.qubes.block.Block ore_diamond -> class
    nidefawl.qubes.block.Block ore_gold -> const
    nidefawl.qubes.block.Block ore_silver -> final
    nidefawl.qubes.block.BlockGroupOres ores -> do
    nidefawl.qubes.block.BlockGroup bricks -> if
    nidefawl.qubes.block.BlockGroup stonebricks -> for
    nidefawl.qubes.block.BlockGroup smoothstones -> int
    nidefawl.qubes.block.BlockGroup stonepath -> new
    nidefawl.qubes.block.BlockGroup cobblestones -> try
    nidefawl.qubes.block.BlockGroup slabs -> byte
    nidefawl.qubes.block.BlockGroup stairs -> case
    nidefawl.qubes.block.BlockGroup walls -> char
    nidefawl.qubes.block.BlockGroup fences -> else
    nidefawl.qubes.block.Block flower_fmn_black -> float
    nidefawl.qubes.block.Block flower_fmn_blue -> short
    nidefawl.qubes.block.Block flower_compositae_camille -> super
    nidefawl.qubes.block.Block flower_compositae_milkspice -> throw
    nidefawl.qubes.block.Block flower_compositae_pinkpanther -> while
    nidefawl.qubes.block.Block flower_compositae_tigerteeth -> double
    nidefawl.qubes.block.Block flower_violet -> import
    nidefawl.qubes.block.Block flower_rose -> native
    nidefawl.qubes.block.Block flower_poppy1 -> public
    nidefawl.qubes.block.Block flower_poppy2 -> return
    nidefawl.qubes.block.Block flower_poppy3 -> static
    nidefawl.qubes.block.Block flower_oxmorina_blue -> switch
    nidefawl.qubes.block.Block flower_cup_0 -> throws
    nidefawl.qubes.block.Block flower_cup_1 -> boolean
    nidefawl.qubes.block.Block flower_cup_2 -> default
    nidefawl.qubes.block.Block flower_cup_3 -> extends
    nidefawl.qubes.block.Block flower_cup_4 -> finally
    nidefawl.qubes.block.Block flower_cup_5 -> package
    nidefawl.qubes.block.Block flower_cup_6 -> private
    nidefawl.qubes.block.Block flower_cup_7 -> abstract
    nidefawl.qubes.block.Block flower_star_frost -> continue
    nidefawl.qubes.block.Block flower_star_sundown -> strictfp
    nidefawl.qubes.block.Block flower_dandelion -> volatile
    nidefawl.qubes.block.Block flower_lotus -> interface
    nidefawl.qubes.block.Block flower_lavender -> protected
    nidefawl.qubes.block.Block flower_tulip1 -> transient
    nidefawl.qubes.block.Block flower_tulip2 -> implements
    nidefawl.qubes.block.Block flower_tulip3 -> instanceof
    nidefawl.qubes.block.Block flower_tulip4 -> synchronized
    nidefawl.qubes.block.Block flower_tulip5 -> ZssZSS2zz2SSZssZ
    nidefawl.qubes.block.Block flower_tulip6 -> z22zZsSSSS2zZsSS
    nidefawl.qubes.block.Block flower_nomades -> Zsz22z2z2zZsZs
    nidefawl.qubes.block.Block flower_sheeps_meal -> sZz2SSZssZz2z2z2
    nidefawl.qubes.block.Block rhubarb -> SSZsZs2zsZsZ2zsZ
    nidefawl.qubes.block.Block fern1 -> z2ZsZs2zZsZs2zsZ
    nidefawl.qubes.block.Block fern2 -> ZssZZsz2sZsZ2zz2
    nidefawl.qubes.block.Block fern3 -> sZSSZsZsz2ZsZssZ
    nidefawl.qubes.block.Block fern4 -> SSZsz2ZssZsZz2
    nidefawl.qubes.block.Block double_heath -> z2z22zSSZs2z2z2z
    nidefawl.qubes.block.Block tallgrass1 -> sZZsZsZsSSsZ
    nidefawl.qubes.block.Block tallgrass2 -> sZ2zsZSSZssZsZ2z
    nidefawl.qubes.block.Block cattail -> Zs2z2zSSz2Zsz2
    nidefawl.qubes.block.Block pad -> z2SS2zsZSSZs
    nidefawl.qubes.block.BlockGroup modelled -> goto
    int id -> do
    java.lang.String name -> do
    boolean transparent -> do
    java.lang.String[] textures -> if
    java.lang.String[] normalMaps -> for
    nidefawl.qubes.vec.AABBFloat blockBounds -> do
    nidefawl.qubes.block.BlockTextureMode textureMode -> do
    nidefawl.qubes.block.BlockCategory blockCategory -> do
    nidefawl.qubes.models.qmodel.ModelBlock[] loadedModels -> do
    java.lang.String[] models -> int
    nidefawl.qubes.block.BlockGroup blockGroup -> long
    137:137:void preInit() -> do
    139:162:void postInit() -> if
    191:192:nidefawl.qubes.block.Block setBlockGroup(nidefawl.qubes.block.BlockGroup) -> do
    196:197:nidefawl.qubes.block.Block setCategory(nidefawl.qubes.block.BlockCategory) -> do
    200:200:nidefawl.qubes.block.BlockCategory getBlockCategory() -> do
    204:204:void init() -> for
    214:214:java.lang.String[] getTextures() -> do
    217:217:java.lang.String[] getNormalMaps() -> if
    221:225:nidefawl.qubes.block.Block setTextures(java.lang.String[]) -> do
    228:232:nidefawl.qubes.block.Block setNormalMaps(java.lang.String[]) -> if
    236:237:nidefawl.qubes.block.Block setModels(java.lang.String[]) -> for
    240:240:java.lang.String[] getModels() -> for
    249:249:java.lang.String getName() -> do
    253:253:boolean isTransparent() -> do
    256:256:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    259:260:nidefawl.qubes.block.Block setTextureMode(nidefawl.qubes.block.BlockTextureMode) -> do
    263:263:int getTexturePasses() -> do
    281:292:int getTexture(int,int,int) -> do
    295:295:int getLODPass() -> if
    298:298:int getRenderPass() -> for
    301:301:int getRenderType() -> int
    304:304:boolean isValid(int) -> do
    307:307:nidefawl.qubes.block.Block get(int) -> do
    310:310:boolean applyAO() -> if
    313:313:boolean isOccluding() -> for
    317:320:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    323:323:float getAlpha() -> do
    326:326:int getLightValue() -> new
    329:329:boolean isOpaque(int) -> if
    333:334:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    337:361:boolean isVisibleBounds(nidefawl.qubes.world.IBlockWorld,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    365:368:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    378:378:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    384:384:boolean isSlab() -> int
    390:390:boolean isStairs() -> new
    404:404:boolean canPlaceAt(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    416:416:int prePlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    427:427:void postPlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    438:439:void place(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> if
    444:444:boolean isReplaceable() -> try
    447:450:int placeOffset(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> if
    464:469:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    472:472:boolean isFullBB() -> byte
    475:475:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    481:481:short[] getRegisteredIDs() -> do
    488:488:nidefawl.qubes.block.Block[] getRegisteredBlocks() -> do
    492:495:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    502:502:int getRenderShadow() -> try
    507:509:java.lang.String toString() -> toString
    513:517:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    521:521:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
    525:533:int getItems(java.util.List) -> do
    537:537:int getMeshedColor(nidefawl.qubes.meshing.BlockSurface) -> do
    541:541:int getTextureByIdx(int) -> do
    545:545:int getLightLoss(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
    575:575:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    583:583:int getInvRenderData(nidefawl.qubes.item.BlockStack) -> do
    589:589:float getInvRenderRotation() -> if
    592:592:boolean canMineWith(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    595:595:void onBlockMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    597:597:nidefawl.qubes.models.qmodel.ModelBlock getBlockModel(nidefawl.qubes.world.IBlockWorld,int,int,int,int) -> do
    600:603:int getNormalMap(int) -> if
nidefawl.qubes.block.Block$1 -> Ji1LjIL1JiiJjI1L:
    int[] $SwitchMap$nidefawl$qubes$block$BlockTextureMode -> do
nidefawl.qubes.block.BlockAir -> Ijll1L1LjIL1Jill:
    33:33:nidefawl.qubes.block.Block setTextures(java.lang.String[]) -> do
    41:41:int getTexture(int,int,int) -> do
    45:45:int getRenderPass() -> for
    48:48:int getRenderType() -> int
    52:52:boolean applyAO() -> if
    55:55:boolean isOccluding() -> for
    59:59:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    62:62:float getAlpha() -> do
    65:65:int getLightValue() -> new
    70:70:boolean isVisibleBounds(nidefawl.qubes.world.IBlockWorld,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    74:74:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    78:78:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    82:82:boolean isReplaceable() -> try
    87:87:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    90:90:boolean isFullBB() -> byte
    95:95:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    99:99:int getItems(java.util.List) -> do
    104:104:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
nidefawl.qubes.block.BlockCategory -> jIllIjjIJiiJJiIj:
    nidefawl.qubes.block.BlockCategory GROUND -> do
    nidefawl.qubes.block.BlockCategory ROCK -> if
    nidefawl.qubes.block.BlockCategory LEAVES -> for
    nidefawl.qubes.block.BlockCategory STONE -> int
    nidefawl.qubes.block.BlockCategory LOG -> new
    nidefawl.qubes.block.BlockCategory FLOWER -> try
    nidefawl.qubes.block.BlockCategory VINE -> byte
    nidefawl.qubes.block.BlockCategory PLANT -> case
    nidefawl.qubes.block.BlockCategory UNASSIGNED -> char
    nidefawl.qubes.block.BlockCategory[] $VALUES -> do
    10:10:nidefawl.qubes.block.BlockCategory[] values() -> values
    10:10:nidefawl.qubes.block.BlockCategory valueOf(java.lang.String) -> valueOf
nidefawl.qubes.block.BlockConnect -> iJL1llIj1LJi1LIj:
    nidefawl.qubes.block.BlockConnect FENCE -> do
    nidefawl.qubes.block.BlockConnect WALL -> if
    nidefawl.qubes.block.BlockConnect PANE -> for
    nidefawl.qubes.block.BlockConnect[] $VALUES -> do
    10:10:nidefawl.qubes.block.BlockConnect[] values() -> values
    10:10:nidefawl.qubes.block.BlockConnect valueOf(java.lang.String) -> valueOf
nidefawl.qubes.block.BlockDoubleCatTail -> L1ll1L1LJillIjL1:
    13:13:int getTexturePasses() -> do
    17:20:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockDoublePlant -> lliJlliJL1JijIjI:
    29:29:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    33:36:void postPlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    39:39:int getRenderType() -> int
    44:44:boolean applyAO() -> if
    49:49:boolean isOccluding() -> for
    57:57:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    61:61:boolean isReplaceable() -> try
    65:65:boolean isFullBB() -> byte
    72:75:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    80:85:int getTexture(int,int,int) -> do
    90:90:int getRenderShadow() -> try
nidefawl.qubes.block.BlockFence -> IjIjllIjJiIjJiL1:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    19:28:int setFenceConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> do
    32:38:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    42:42:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
    55:55:int getLightValue() -> new
    60:60:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    65:65:float getAlpha() -> do
    69:75:int getTexture(int,int,int) -> do
    79:79:int getRenderType() -> int
    84:84:boolean isOccluding() -> for
    89:89:boolean isFullBB() -> byte
    94:94:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    99:99:int getRenderShadow() -> try
    104:120:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    125:177:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
nidefawl.qubes.block.BlockFlowerFMN -> llllL1IjJiIjjIll:
    29:32:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    35:35:int getTexturePasses() -> do
    39:42:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockGrass -> llJill1LjIiJjIIj:
    19:21:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    25:34:int getTexture(int,int,int) -> do
    37:37:int getMeshedColor(nidefawl.qubes.meshing.BlockSurface) -> do
    41:41:int getTexturePasses() -> do
    45:45:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    49:54:int getNormalMap(int) -> if
nidefawl.qubes.block.BlockGrassBush -> iJjIllJiL1L1Ji:
    27:27:boolean applyRandomOffset() -> case
    31:31:int getLODPass() -> if
    35:35:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
nidefawl.qubes.block.BlockGroup -> lliJJiIjL1llL1L1:
    int NEXT_GROUP_ID -> do
    int id -> if
    java.util.List blocks -> do
    24:26:void addBlock(nidefawl.qubes.block.Block) -> do
    java.util.List getNames() -> do
    31:31:java.util.List getBlocks() -> if
nidefawl.qubes.block.BlockGroupBricks -> L1jIL11LjIL1llIj:
    java.util.List stoneNames -> do
    27:27:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupCobbleStones -> jIllL1JiJilliJll:
    java.util.List stoneNames -> do
    29:29:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupFences -> L1JiL1jIjIlljIJi:
    java.util.List stoneNames -> do
    44:44:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupLeaves -> iJL1jIIjjIjIiJ1L:
    java.util.List leaveNames -> do
    nidefawl.qubes.block.Block oak -> do
    23:23:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupLogs -> Ji1LL11Lll1LJiiJ:
    java.util.List logNames -> do
    nidefawl.qubes.block.Block oak -> do
    35:35:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupModelledStones -> llL1IjiJJiJiiJ:
    java.util.List stoneNames -> do
    53:53:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupOres -> iJL1JilllliJJiiJ:
    java.util.List stoneNames -> do
    18:18:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupSlabs -> iJ1LiJiJllL1Ji1L:
    java.util.List stoneNames -> do
    42:42:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupSmoothStones -> jIiJL1JiJiiJL1iJ:
    java.util.List stoneNames -> do
    30:30:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStairs -> ll1L1LIj1LL1jI1L:
    java.util.List stoneNames -> do
    44:44:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStoneBricks -> iJ1LllL1iJJillL1:
    java.util.List stoneNames -> do
    34:34:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStonePath -> lliJL1JiL1L11LIj:
    java.util.List stoneNames -> do
    29:29:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStones -> jI1LIjjIiJlljIll:
    java.util.List stoneNames -> do
    nidefawl.qubes.block.Block granite -> do
    nidefawl.qubes.block.Block basalt -> if
    nidefawl.qubes.block.Block diorite -> for
    nidefawl.qubes.block.Block marble -> int
    nidefawl.qubes.block.Block obsidian -> new
    nidefawl.qubes.block.Block sandstone -> try
    nidefawl.qubes.block.Block sandstone_red -> byte
    42:42:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupWalls -> L1L1jIJiiJIjiJjI:
    java.util.List stoneNames -> do
    43:43:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupWood -> llL1IjjIJiiJlljI:
    26:26:java.util.List getNames() -> do
nidefawl.qubes.block.BlockIce -> jIjIJi1LIjlliJL1:
    20:20:int getRenderPass() -> for
    25:25:boolean applyAO() -> if
    30:30:float getAlpha() -> do
    35:35:boolean isOccluding() -> for
    40:40:int getRenderShadow() -> try
    44:44:int getLightLoss(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
    48:52:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    56:56:int getLODPass() -> if
    59:67:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    71:76:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    81:81:boolean isFullBB() -> byte
    85:85:int getRenderType() -> int
nidefawl.qubes.block.BlockLeaves -> jIiJJiL11LiJL1:
    int leavesColor -> if
    32:32:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    37:37:boolean applyAO() -> if
    42:42:boolean isOccluding() -> for
    46:46:int getLightLoss(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
nidefawl.qubes.block.BlockLog -> IjiJ1LIj1L1LIjIj:
    int index -> if
    35:35:int getIndex() -> byte
    40:66:int getTexture(int,int,int) -> do
    71:71:int getTexturePasses() -> do
    76:81:void onBlockMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    85:89:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    94:94:int getRenderType() -> int
nidefawl.qubes.block.BlockModelled -> Ji1LJilliJjI1LJi:
    18:18:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    23:23:boolean isFullBB() -> byte
    27:27:boolean isTransparent() -> do
    31:31:int getLODPass() -> if
    35:35:int getRenderPass() -> for
    39:39:int getRenderShadow() -> try
    43:43:boolean isOccluding() -> for
    48:48:int getRenderType() -> int
nidefawl.qubes.block.BlockOre -> L11LjIllL11LIjJi:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    33:33:int getLightValue() -> new
    38:38:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    43:47:int getTexture(int,int,int) -> do
    52:52:int getTexturePasses() -> do
    57:64:void onBlockMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    68:72:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    76:76:int getNormalMap(int) -> if
    80:80:int getRenderType() -> int
nidefawl.qubes.block.BlockPane -> jIJi1LiJL11Lll1L:
    18:27:int setPaneConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    31:31:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    35:41:int getConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> if
    45:45:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
    53:53:int getRenderType() -> int
    59:59:int getRenderShadow() -> try
    64:64:boolean isOccluding() -> for
    69:69:boolean isFullBB() -> byte
    74:74:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    80:109:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    114:166:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
nidefawl.qubes.block.BlockPlantCrossedSquares -> lljIIjL1JiL1llIj:
    boolean multipass -> do
    37:40:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    44:44:int getRenderType() -> int
    49:49:boolean isOccluding() -> for
    57:57:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    61:61:boolean isReplaceable() -> try
    65:65:boolean isFullBB() -> byte
    68:68:boolean applyRandomOffset() -> case
    72:75:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    80:80:int getRenderShadow() -> try
    83:83:int getTexturePasses() -> do
    87:90:int getTexture(int,int,int) -> do
    96:96:int getLODPass() -> if
nidefawl.qubes.block.BlockPlantFlat -> IjlljIIjllJillL1:
    32:32:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    36:36:int getRenderType() -> int
    41:41:boolean isOccluding() -> for
    46:46:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    50:50:boolean isReplaceable() -> try
    54:54:boolean isFullBB() -> byte
    61:68:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    73:73:int getRenderShadow() -> try
    79:79:int getLODPass() -> if
nidefawl.qubes.block.BlockQuarterBlock -> Ijll1LjIJiJiJiL1:
    short[] readOnly -> do
    36:40:short[] getSafeRead(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    45:49:nidefawl.qubes.chunk.blockdata.BlockDataQuarterBlock getSafeCast(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    54:60:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    63:69:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    73:98:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    102:106:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    111:128:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    132:138:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    144:197:int getItems(java.util.List) -> do
    201:205:void postPlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
nidefawl.qubes.block.BlockSand -> jIlliJjIlliJ1Lll:
nidefawl.qubes.block.BlockSlab -> JillIjlljIIjjIjI:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    int overrideTextureIdx -> if
    38:38:boolean isOccluding() -> for
    44:44:int getLightValue() -> new
    49:49:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    54:54:float getAlpha() -> do
    59:59:boolean applyAO() -> if
    64:64:boolean isTransparent() -> do
    69:78:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    83:83:java.lang.String getName() -> do
    88:95:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    100:100:boolean canPlaceAt(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    104:116:int prePlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    120:127:int placeOffset(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> if
    132:167:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    171:172:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    179:179:boolean isSlab() -> int
    184:190:int getTexture(int,int,int) -> do
    193:193:boolean isFullBB() -> byte
    196:196:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    201:211:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    215:216:int getItems(java.util.List) -> do
nidefawl.qubes.block.BlockSliced -> iJJiJilliJ1LjI:
    13:13:int getRenderType() -> int
nidefawl.qubes.block.BlockStairs -> IjL1jI1LL1jIIj:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    int overrideTextureIdx -> if
    int[] offsetXZ -> do
    int[] offsetXZ2 -> if
    27:27:boolean isUpsideDown(int) -> for
    41:41:boolean isOccluding() -> for
    47:47:int getLightValue() -> new
    52:52:boolean applyAO() -> if
    57:57:boolean isTransparent() -> do
    62:81:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    85:104:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    109:109:java.lang.String getName() -> do
    114:114:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    119:119:float getAlpha() -> do
    124:131:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    137:156:int prePlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    161:182:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    188:188:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    194:194:boolean isStairs() -> new
    199:205:int getTexture(int,int,int) -> do
    208:208:boolean isFullBB() -> byte
    224:257:int stairTypeAt(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    261:318:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    326:385:void setStairBB(nidefawl.qubes.vec.AABBFloat,int,int,int,int) -> do
    387:387:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
nidefawl.qubes.block.BlockStoneModelled -> lllliJL1IjiJL1L1:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    int overrideTextureIdx -> if
    22:28:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockTextureMode -> L1lliJIjjI1LiJJi:
    nidefawl.qubes.block.BlockTextureMode DEFAULT -> do
    nidefawl.qubes.block.BlockTextureMode TOP -> if
    nidefawl.qubes.block.BlockTextureMode TOP_BOTTOM -> for
    nidefawl.qubes.block.BlockTextureMode SUBTYPED_TEX_PER_TYPE -> int
    nidefawl.qubes.block.BlockTextureMode[] $VALUES -> do
    10:10:nidefawl.qubes.block.BlockTextureMode[] values() -> values
    10:10:nidefawl.qubes.block.BlockTextureMode valueOf(java.lang.String) -> valueOf
nidefawl.qubes.block.BlockVine -> iJiJ1LL1IjIjiJll:
    33:33:int getRenderType() -> int
    38:38:int getLODPass() -> if
    44:47:boolean canPlaceAt(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    52:87:int prePlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    93:93:boolean isOccluding() -> for
    98:98:boolean isFullBB() -> byte
    103:103:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    108:108:int getRenderShadow() -> try
    113:113:boolean isReplaceable() -> try
    118:124:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    129:129:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    134:134:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    138:170:int setSelectionBB(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    175:175:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    179:179:int getInvRenderData(nidefawl.qubes.item.BlockStack) -> do
    185:185:float getInvRenderRotation() -> if
nidefawl.qubes.block.BlockWall -> jIL1IjjIL1llIj:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    int overrideTextureIdx -> if
    23:36:int setWallConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> do
    40:46:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    51:51:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
    69:69:int getLightValue() -> new
    74:74:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    79:79:float getAlpha() -> do
    83:89:int getTexture(int,int,int) -> do
    93:93:int getRenderType() -> int
    99:99:boolean isOccluding() -> for
    104:104:boolean isFullBB() -> byte
    109:109:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    114:114:int getRenderShadow() -> try
    119:131:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    136:188:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    193:194:int getItems(java.util.List) -> do
nidefawl.qubes.block.BlockWater -> iJ1LL1L1llL1lliJ:
    13:13:int getRenderPass() -> for
    18:18:boolean applyAO() -> if
    23:23:float getAlpha() -> do
    28:28:boolean isOccluding() -> for
    33:33:boolean isReplaceable() -> try
    38:38:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    43:43:int getRenderShadow() -> try
    47:47:int getLightLoss(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
nidefawl.qubes.block.BlockWood -> Ij1LL1IjIjL1IjjI:
    int index -> if
nidefawl.qubes.block.IDMappingBlocks -> lllljIL1L1iJ1LJi:
    boolean CHANGED -> do
    boolean LOADED -> if
    int HIGHEST_BLOCK_ID -> do
    com.google.common.collect.ImmutableBiMap map -> do
    java.lang.Object sync -> do
    30:65:void load() -> do
    67:108:void save() -> if
    110:139:int get(java.lang.String) -> do
nidefawl.qubes.blocklight.BlockLightThread -> jIJiL1jIjIiJiJJi:
    long sleepTime -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    nidefawl.qubes.blocklight.LightChunkCache[] caches -> do
    int misses -> do
    int hits -> if
    boolean isRunning -> do
    nidefawl.qubes.world.WorldServer world -> do
    boolean finished -> if
    nidefawl.qubes.blocklight.BlockLightUpdate lightUpdater -> do
    43:116:void run() -> run
    125:144:nidefawl.qubes.blocklight.LightChunkCache getCache(nidefawl.qubes.world.WorldServer,int,int) -> do
    148:148:void onInterruption() -> if
    151:174:void halt() -> do
    177:179:long toHash(long,long,long,long) -> do
    183:183:int getX(long) -> do
    187:187:int getZ(long) -> if
    191:191:int getY(long) -> for
    195:195:int getFlags(long) -> int
    199:202:void queueBlock(int,int,int,int) -> do
    205:207:void queueChunk(int,int,int) -> do
nidefawl.qubes.blocklight.BlockLightUpdate -> jIiJL1Ij1LL1L1Ji:
    long[] stackRemove -> do
    long[] stackAdd -> if
    int[] stackRemoveLight -> do
    int numBlocksUpdate -> do
    25:59:void updateChunk(nidefawl.qubes.blocklight.LightChunkCache,int,int,int) -> do
    64:185:void updateBlock(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
    188:190:void setLight(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int,int,int) -> do
    194:228:int getNewLightLevel(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
nidefawl.qubes.blocklight.LightChunkCache -> L1IjIjlliJiJIjL1:
    nidefawl.qubes.chunk.Chunk[] chunks -> do
    int lastX -> do
    int lastZ -> if
    boolean isValid -> do
    int[] flaggedNumBlocks -> do
    nidefawl.qubes.vec.BlockBoundingBox[] flaggedBlocks -> do
    int worldHeightMin1 -> for
    int nUse -> new
    int drainedChunks -> int
    44:48:void resetFlaggedBlocks() -> do
    51:53:void invalidate() -> if
    56:61:int idx(int,int) -> do
    65:65:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    69:70:boolean canSeeSky(int,int,int) -> do
    74:75:boolean isTransparent(int,int,int) -> if
    79:80:int getHeight(int,int) -> if
    84:87:int getLight(int,int,int,int) -> do
    90:93:int getWater(int,int,int) -> do
    100:104:int getTypeId(int,int,int) -> if
    116:131:boolean setLight(int,int,int,int,int,int) -> do
    135:144:boolean isValid(nidefawl.qubes.world.WorldServer,int,int) -> do
    147:162:boolean cache(nidefawl.qubes.world.WorldServer,int,int) -> if
    173:185:void drainFlagged(nidefawl.qubes.server.PlayerChunkTracker) -> do
    193:197:boolean hasBlock(int,int) -> do
    204:205:void flagUsed() -> for
    214:214:int getNumUses() -> do
nidefawl.qubes.chat.ChannelManager -> iJlliJJiL1iJJi:
    java.util.Map channels -> do
    49:49:nidefawl.qubes.chat.channel.AbstractChannel getChannel(java.lang.String) -> do
    60:67:void addUser(nidefawl.qubes.chat.ChatUser) -> do
    73:80:void removeUser(nidefawl.qubes.entity.PlayerServer) -> do
    88:92:void handlePlayerChat(nidefawl.qubes.chat.ChatUser,java.lang.String,java.lang.String) -> do
nidefawl.qubes.chat.ChatUser -> JiL1lliJ1LL1jIll:
    java.util.Collection getJoinedChannels() -> do
    java.lang.String getChatName() -> do
    void sendMessage(java.lang.String,java.lang.String) -> do
nidefawl.qubes.chat.channel.AbstractChannel -> jIiJJiL11L1LlliJ:
    java.lang.String tag -> do
    31:31:java.lang.String getTag() -> do
    java.util.Collection getUsers() -> do
    void addUser(nidefawl.qubes.chat.ChatUser) -> do
    void removeUser(nidefawl.qubes.chat.ChatUser) -> if
    56:56:boolean containsUser(nidefawl.qubes.chat.ChatUser) -> do
    64:66:void onChat(nidefawl.qubes.chat.ChatUser,java.lang.String) -> do
    73:76:void broadcastUserMessage(nidefawl.qubes.chat.ChatUser,java.lang.String) -> if
    93:94:java.lang.String formatMessage(nidefawl.qubes.chat.ChatUser,java.lang.String) -> do
nidefawl.qubes.chat.client.ChatLine -> iJiJIjllIjll1LL1:
    java.lang.String rawMessage -> do
    long receiveTime -> do
    25:25:java.lang.String getLine() -> do
    31:31:long getTime() -> do
nidefawl.qubes.chat.client.ChatManager -> IjjIiJ1LllIjiJ:
    java.util.ArrayList line -> do
    java.util.ArrayList hist -> if
    boolean saveHistory -> do
    nidefawl.qubes.chat.client.ChatManager instance -> do
    37:37:nidefawl.qubes.chat.client.ChatManager getInstance() -> do
    45:46:void receiveMessage(java.lang.String,java.lang.String) -> do
    52:52:java.util.List getLines() -> do
    59:65:int getNumNewLines() -> do
    69:69:void syncChannels(java.util.ArrayList) -> do
    75:87:void loadInputHistory() -> do
    93:106:void saveInputHistory() -> if
    109:111:void addHistory(java.lang.String) -> do
    115:115:int getHistorySize() -> if
    120:120:java.lang.String getHistory(int) -> do
    125:125:int indexOfHistory(java.lang.String) -> do
    130:132:void removeHistory(int) -> do
    137:139:void addHistory(int,java.lang.String) -> do
nidefawl.qubes.chunk.Chunk -> llJijI1LIjiJIjiJ:
    nidefawl.qubes.world.World world -> do
    int x -> do
    int z -> if
    int worldHeightBits -> for
    int height -> int
    short[] blocks -> do
    nidefawl.qubes.chunk.ChunkDataSliced2 blockMetadata -> do
    nidefawl.qubes.chunk.blockdata.BlockDataSliced blockData -> do
    byte[] blockLight -> do
    int[] heightMap -> do
    byte[] biomes -> if
    byte[] waterMask -> for
    long loadTime -> do
    boolean updateHeightMap -> do
    boolean needsSave -> if
    boolean isEmpty -> for
    boolean isLit -> int
    boolean isValid -> new
    boolean isUnloading -> try
    boolean isPopulated -> byte
    53:61:void checkIsEmtpy() -> do
    68:68:int getBlockX() -> do
    72:72:int getBlockZ() -> if
    76:76:int getWater(int,int,int) -> do
    80:80:int getTypeId(int,int,int) -> if
    93:93:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    96:96:int getData(int,int,int) -> for
    106:106:short getFullData(int,int,int) -> do
    110:110:boolean setFullData(int,int,int,short) -> do
    114:114:boolean setData(int,int,int,int) -> do
    117:117:boolean setBlockData(int,int,int,nidefawl.qubes.chunk.blockdata.BlockData) -> do
    121:133:int getTopBlock(int,int) -> do
    144:168:boolean setTypeData(int,int,int,int,int) -> do
    172:185:boolean setType(int,int,int,int) -> if
    189:191:void flagModified() -> if
    216:216:boolean justLoaded() -> do
    220:220:short[] getBlocks() -> do
    224:224:byte[] getBlockLight() -> do
    228:239:int getLight(int,int,int,int) -> do
    244:252:int getLight(int,int,int) -> int
    256:274:boolean setLight(int,int,int,int,int) -> if
    278:279:int getHeightMap(int,int) -> if
    285:314:void updateHeightMap(int,int) -> do
    318:330:void initLight() -> for
    334:353:void initHeightMap() -> int
    363:368:void postLoad() -> new
    371:372:void postGenerate() -> try
    379:396:byte[] getLights(nidefawl.qubes.vec.BlockBoundingBox) -> do
    405:425:boolean setLights(byte[],nidefawl.qubes.vec.BlockBoundingBox) -> do
    433:433:java.lang.String toString() -> toString
    440:440:byte[] getWaterMask() -> if
nidefawl.qubes.chunk.ChunkData -> iJllL1L1JiIjjIjI:
    boolean setByte(int,int,int,boolean,int) -> do
    21:21:boolean setLower(int,int,int,int) -> do
    27:27:nidefawl.qubes.nbt.Tag$Compound writeToTag() -> do
    33:33:void readFromTag(nidefawl.qubes.nbt.Tag$Compound) -> do
nidefawl.qubes.chunk.ChunkDataSliced2 -> ll1LL1jIllIjIjJi:
    short[][] array -> do
    28:31:short get(int,int,int) -> do
    35:42:boolean set(int,int,int,short) -> do
    45:58:boolean setByte(int,int,int,boolean,int) -> do
    62:69:short[] getArray(int,boolean) -> do
    76:96:nidefawl.qubes.nbt.Tag$Compound writeToTag() -> do
    103:121:void readFromTag(nidefawl.qubes.nbt.Tag$Compound) -> do
    127:131:short[][] getArrays() -> do
nidefawl.qubes.chunk.ChunkManager -> L1jIllJiL1iJ1LiJ:
    nidefawl.qubes.world.World world -> do
    nidefawl.qubes.chunk.ChunkTable table -> do
    nidefawl.qubes.chunk.ChunkTable makeChunkTable() -> do
    27:27:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    31:31:int getChunksLoaded() -> do
    35:35:void saveAll() -> do
    38:38:void queueLoadChecked(long) -> do
nidefawl.qubes.chunk.ChunkTable -> jIjIIjJiiJjIL11L:
    nidefawl.qubes.chunk.Chunk[][] values -> do
    int size -> do
    int halfSize -> if
    int approxLoaded -> byte
    int mswLow -> for
    int mswHigh -> int
    int lswLow -> new
    int lswHigh -> try
    36:50:boolean put(int,int,nidefawl.qubes.chunk.Chunk) -> do
    55:59:void updateBounds(int,int) -> do
    62:62:nidefawl.qubes.chunk.Chunk get(long) -> do
    66:71:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    76:83:nidefawl.qubes.chunk.Chunk remove(int,int) -> if
    98:111:int size() -> do
    161:173:java.util.List asList() -> do
    234:234:java.util.Iterator iterator() -> iterator
nidefawl.qubes.chunk.ChunkTable$ChunkRegionTableIterator -> JiL1jIJillll1LjI:
    nidefawl.qubes.chunk.Chunk value -> do
    int msw -> do
    int lsw -> if
    nidefawl.qubes.chunk.ChunkTable table -> if
    nidefawl.qubes.chunk.ChunkTable this$0 -> do
    190:204:boolean hasNext() -> hasNext
    209:211:nidefawl.qubes.chunk.Chunk next() -> do
    216:216:void remove() -> remove
    177:177:java.lang.Object next() -> next
nidefawl.qubes.chunk.blockdata.BlockData -> JiiJL1iJjIllJill:
    20:26:boolean isEqual(nidefawl.qubes.chunk.blockdata.BlockData,nidefawl.qubes.chunk.blockdata.BlockData) -> do
    33:33:boolean compareTo(nidefawl.qubes.chunk.blockdata.BlockData) -> do
    boolean compareData(nidefawl.qubes.chunk.blockdata.BlockData) -> if
    int getTypeId() -> do
    int getLength() -> if
    42:46:nidefawl.qubes.chunk.blockdata.BlockData fromType(int) -> do
    50:57:int writeHeader(byte[],int) -> do
    int writeData(byte[],int) -> if
    int readData(byte[],int) -> for
    63:66:int writeDataToStream(java.io.DataOutput) -> do
    74:77:void readDataFromStream(java.io.DataInput) -> do
    nidefawl.qubes.chunk.blockdata.BlockData copy() -> do
nidefawl.qubes.chunk.blockdata.BlockDataQuarterBlock -> L1iJIjIjIjJiJiJi:
    short[] blockIDs -> do
    byte[] blockMeta -> do
    21:28:boolean compareData(nidefawl.qubes.chunk.blockdata.BlockData) -> if
    33:33:int getTypeId() -> do
    38:38:int getLength() -> if
    43:48:int writeData(byte[],int) -> if
    53:57:int readData(byte[],int) -> for
    61:64:void fillIntArr(int[]) -> do
    67:72:void setTypeAndData(int,int,int,int,int) -> do
    74:79:void setType(int,int,int,int) -> do
    86:87:int getType(int,int,int) -> do
    90:91:int getData(int,int,int) -> if
    97:100:int idx(int,int,int) -> for
    105:110:nidefawl.qubes.chunk.blockdata.BlockData copy() -> do
nidefawl.qubes.chunk.blockdata.BlockDataSliced -> L1IjIjll1LJiIjJi:
    nidefawl.qubes.chunk.blockdata.BlockData[][] array -> do
    30:33:nidefawl.qubes.chunk.blockdata.BlockData get(int,int,int) -> do
    37:44:boolean set(int,int,int,nidefawl.qubes.chunk.blockdata.BlockData) -> do
    48:55:nidefawl.qubes.chunk.blockdata.BlockData[] getArray(int,boolean) -> do
    63:85:nidefawl.qubes.nbt.Tag$Compound writeToTag() -> do
    92:113:byte[] sliceToBytes(nidefawl.qubes.chunk.blockdata.BlockData[],byte[],int) -> do
    121:136:void readFromTag(nidefawl.qubes.nbt.Tag$Compound) -> do
    143:161:void sliceFromBytes(byte[],nidefawl.qubes.chunk.blockdata.BlockData[]) -> do
    167:171:nidefawl.qubes.chunk.blockdata.BlockData[][] getArrays() -> do
nidefawl.qubes.chunk.client.ChunkManagerClient -> iJJiJi1L1LjIiJjI:
    15:15:nidefawl.qubes.chunk.ChunkTable makeChunkTable() -> do
    19:25:nidefawl.qubes.chunk.Chunk getOrMake(int,int) -> if
    33:37:void remove(int,int) -> do
nidefawl.qubes.chunk.server.ChunkLoadThread -> JiL1Ij1LjIllJi1L:
    long sleepTime -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    boolean isRunning -> do
    nidefawl.qubes.chunk.server.ChunkManagerServer mgr -> do
    boolean finished -> if
    java.lang.Thread[] threads -> do
    31:34:void startThreads() -> do
    40:73:void run() -> run
    76:76:void onInterruption() -> for
    91:94:void queueLoadChecked(long) -> do
    97:124:void halt() -> if
nidefawl.qubes.chunk.server.ChunkManagerServer -> L1JiL1jI1LiJL1Ji:
    nidefawl.qubes.chunk.server.ChunkLoadThread thread -> do
    nidefawl.qubes.chunk.server.ChunkUnloadThread unloadThread -> do
    nidefawl.qubes.chunk.server.ChunkReader reader -> do
    nidefawl.qubes.chunk.server.RegionFileCache regionFileCache -> do
    java.lang.Object syncObj -> do
    java.lang.Object syncObj2 -> if
    nidefawl.qubes.world.WorldServer worldServer -> do
    java.util.Iterator it -> do
    34:36:void startThreads() -> if
    38:46:void onWorldUnload() -> for
    50:50:nidefawl.qubes.chunk.ChunkTable makeChunkTable() -> do
    54:81:void loadOrGenerate(int,int) -> do
    89:93:void queueLoadChecked(long) -> do
    97:116:void saveAndUnloadChunks(int) -> do
    118:123:void unloadChunk(int,int) -> if
    125:128:void saveChunk(nidefawl.qubes.chunk.Chunk) -> do
    135:147:void saveAll() -> do
    149:149:boolean isRunning() -> do
    155:155:java.util.Iterator newUpdateIterator() -> do
nidefawl.qubes.chunk.server.ChunkReader -> L1L1lliJiJL1llIj:
    nidefawl.qubes.chunk.server.ChunkManagerServer mgr -> do
    nidefawl.qubes.chunk.server.RegionFileCache fileCache -> do
    byte[] temp -> do
    23:34:nidefawl.qubes.chunk.Chunk loadChunk(nidefawl.qubes.world.World,int,int) -> do
    38:46:void saveChunk(nidefawl.qubes.chunk.Chunk) -> do
    49:73:nidefawl.qubes.nbt.Tag$Compound writeChunk(nidefawl.qubes.chunk.Chunk) -> do
    77:103:nidefawl.qubes.chunk.Chunk readChunk(nidefawl.qubes.world.World,int,int,nidefawl.qubes.nbt.Tag$Compound) -> do
    107:110:void byteToShortArray(byte[],short[]) -> do
    112:121:void readBlocks(byte[],short[]) -> if
    125:126:byte[] shortToByteArray(short[]) -> do
    130:134:byte[] shortToByteArray(short[],byte[]) -> do
nidefawl.qubes.chunk.server.ChunkUnloadThread -> jIJiL1llllIjjIIj:
    long sleepTime -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    boolean isRunning -> do
    nidefawl.qubes.chunk.server.ChunkManagerServer mgr -> do
    boolean finished -> if
    33:75:void run() -> run
    78:78:void onInterruption() -> if
    90:93:void queueUnloadChecked(java.lang.Long) -> do
    96:123:void halt() -> do
nidefawl.qubes.chunk.server.RegionFile -> JiJillllJiL1jIiJ:
    java.io.RandomAccessFile randomAccess -> do
    java.lang.String name -> do
    nidefawl.qubes.chunk.server.RegionFile$RegionFileHeader header -> do
    long timeWrite -> do
    long timeSeek -> if
    long timeSetSec -> for
    long timeFindSec -> int
    long timeWriteHeader -> new
    124:136:byte[] readChunk(int,int) -> do
    146:195:void writeChunk(int,int,byte[]) -> do
    198:210:void writeAtOffset(nidefawl.qubes.chunk.server.RegionFile$DataChunkMeta,byte[]) -> do
    213:218:void setSectors(int,int,boolean) -> do
    221:221:int toBytes(int) -> do
    225:225:int toSectors(int) -> if
    229:229:nidefawl.qubes.chunk.server.RegionFile$DataChunkMeta getMeta(int) -> do
    233:235:void writeHeader() -> if
    238:244:boolean readHeader() -> do
    248:248:java.lang.String getName(int,int) -> do
    252:256:void close() -> do
    259:264:int getLastUsedSec() -> do
    268:273:int getLastFreeSec() -> if
    277:277:java.lang.String getFileName() -> do
nidefawl.qubes.chunk.server.RegionFile$DataChunkMeta -> iJ1LJiIjIjiJjIIj:
    long byteOffset -> do
    int offset -> do
    int size -> if
    int writetime -> for
    54:57:void read(java.io.RandomAccessFile) -> do
    60:63:void write(java.io.RandomAccessFile) -> if
nidefawl.qubes.chunk.server.RegionFile$RegionFileHeader -> IjlljIJiIj1Lllll:
    int version -> do
    nidefawl.qubes.chunk.server.RegionFile$DataChunkMeta[] chunks -> do
    java.util.ArrayList usedSectors -> do
    20:33:void read(java.io.RandomAccessFile) -> do
    36:41:void write(java.io.RandomAccessFile) -> if
nidefawl.qubes.chunk.server.RegionFileCache -> iJ1LJiL1lliJjIL1:
    java.util.regex.Pattern FILE_PATTERN -> do
    java.io.File dir -> do
    java.util.HashMap map -> do
    30:30:long toLong(int,int) -> do
    36:36:nidefawl.qubes.chunk.server.RegionFile getRegionFileChunk(int,int) -> do
    40:56:nidefawl.qubes.chunk.server.RegionFile getRegionFile(int,int) -> if
    60:61:java.io.File getFile(java.io.File,int,int) -> do
    65:76:void closeAll() -> do
nidefawl.qubes.config.AbstractYMLConfig -> L1llJijI1LL1lljI:
    java.util.Map map -> do
    25:42:void write(java.io.File) -> do
    45:71:void save(java.io.OutputStream) -> do
    74:86:void load(java.io.File) -> if
    89:96:void load(java.io.InputStream) -> do
    99:102:java.lang.String getString(java.lang.String,java.lang.String) -> do
    106:109:java.lang.Boolean getBoolean(java.lang.String,boolean) -> do
    113:116:int getInt(java.lang.String,int) -> do
    120:123:long getLong(java.lang.String,long) -> do
    127:130:float getFloat(java.lang.String,float) -> do
    141:142:void setString(java.lang.String,java.lang.String) -> do
    148:149:void setBoolean(java.lang.String,boolean) -> do
    152:153:void setInt(java.lang.String,int) -> do
    157:158:void setFloat(java.lang.String,float) -> do
    161:162:void setLong(java.lang.String,long) -> do
    void setDefaults() -> do
    void load() -> if
    void save() -> for
nidefawl.qubes.config.ClientSettings -> iJIjllIj1LiJIjiJ:
    int chunkLoadDistance -> do
    int shadowDrawMode -> if
    int ssr -> for
    int aa -> int
    int smaaQuality -> new
    float thirdpersonDistance -> do
    boolean dirty -> do
    int saveTicks -> byte
    int ao -> try
    27:34:void setDefaults() -> do
    38:45:void load() -> if
    49:56:void save() -> for
    63:69:boolean lazySave() -> do
nidefawl.qubes.config.InvalidConfigException -> L1L1jI1LlliJiJjI:
nidefawl.qubes.config.ServerConfig -> JijI1LJiL1Ij1LIj:
    int port -> do
    int packetTimeout -> if
    int chunkCompressionLevel -> for
    14:17:void setDefaults() -> do
    21:24:void load() -> if
    28:31:void save() -> for
nidefawl.qubes.config.WorkingEnv -> JiIjJiiJ1LiJiJIj:
    java.io.File workingDir -> do
    java.io.File assetDir -> if
    java.io.File packsDir -> for
    java.io.File worlds -> int
    java.io.File config -> new
    java.io.File playerdata -> try
    java.io.File modules -> byte
    20:36:void init(java.lang.String) -> do
    39:39:java.io.File getAssetFolder() -> do
    45:45:java.io.File getConfigFolder() -> if
    48:48:java.io.File getWorldsFolder() -> for
    52:52:java.io.File getPlayerData() -> int
    72:72:java.io.File getModulesDir() -> new
nidefawl.qubes.crafting.CraftingManager -> iJ1LIj1LL11Lll:
    int id -> do
    long startTime -> do
    long endTime -> if
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    nidefawl.qubes.entity.PlayerServer player -> do
    30:30:int getId() -> do
    34:34:boolean isRunning() -> do
    38:38:long getStartTime() -> do
    42:42:long getEndTime() -> if
    46:60:void handleRequest(int) -> do
    63:66:void stopCrafting() -> if
    69:83:void craft() -> do
    86:110:boolean update() -> if
    114:133:boolean initCrafting(nidefawl.qubes.crafting.recipes.CraftingRecipe) -> do
    137:144:nidefawl.qubes.network.packet.PacketSCraftingProgress getStatePacket(int) -> do
nidefawl.qubes.crafting.CraftingManagerClient -> JiIjjIIjjI1LJi1L:
    int id -> do
    nidefawl.qubes.entity.PlayerSelf player -> do
    long startTime -> do
    long endTime -> if
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    long serverTime -> for
    long recvTime -> int
    int state -> if
    28:28:int getId() -> do
    57:80:void handleRequest(int,nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
nidefawl.qubes.crafting.recipes.CraftingRecipe -> jIiJjIJiL1jIJi:
    nidefawl.qubes.item.BaseStack[] in -> do
    nidefawl.qubes.item.BaseStack[] out -> if
    int id -> do
    nidefawl.qubes.item.BaseStack preview -> do
    22:22:int getId() -> do
    25:25:nidefawl.qubes.item.BaseStack[] getIn() -> do
    28:28:nidefawl.qubes.item.BaseStack[] getOut() -> if
    31:31:nidefawl.qubes.item.BaseStack getPreview() -> do
    35:46:boolean matches(nidefawl.qubes.inventory.slots.SlotsCrafting) -> do
    50:50:boolean isInput(nidefawl.qubes.item.Item) -> do
    53:53:long getTime() -> do
nidefawl.qubes.crafting.recipes.CraftingRecipes -> JiIjllL1JiL1JiiJ:
    int NEXT_ID -> do
    java.util.HashMap map -> do
    nidefawl.qubes.crafting.recipes.CraftingRecipe[] recipesArray -> do
    23:97:void init() -> do
    100:105:nidefawl.qubes.crafting.recipes.CraftingRecipe findRecipe(nidefawl.qubes.inventory.slots.SlotsCrafting) -> do
    109:109:nidefawl.qubes.crafting.recipes.CraftingRecipe getRecipeId(int) -> do
    117:117:java.util.List getList(java.lang.String) -> do
nidefawl.qubes.entity.Entity -> JijIllL1JilliJll:
    int NEXT_ENT_ID -> do
    int id -> if
    nidefawl.qubes.world.World world -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    nidefawl.qubes.vec.Vec3D lastPos -> if
    nidefawl.qubes.vec.Vec3D mot -> for
    nidefawl.qubes.vec.Vec3D lastMot -> int
    float yaw -> do
    float lastYaw -> if
    float yawBodyOffset -> for
    float lastYawBodyOffset -> int
    float pitch -> new
    float lastPitch -> try
    boolean noclip -> do
    boolean hitGround -> if
    nidefawl.qubes.vec.AABB aabb -> do
    nidefawl.qubes.vec.AABB aabb2 -> if
    nidefawl.qubes.vec.AABB aabb3 -> for
    nidefawl.qubes.vec.AABB aabb4 -> int
    nidefawl.qubes.vec.AABB dbg -> new
    nidefawl.qubes.util.CollisionQuery coll -> do
    nidefawl.qubes.vec.Vector3f renderPos -> do
    nidefawl.qubes.vec.Vector3f renderRot -> if
    nidefawl.qubes.vec.Vec3D remotePos -> new
    nidefawl.qubes.vec.Vector3f remoteRotation -> for
    int rotticks -> for
    int posticks -> int
    double width -> do
    double height -> if
    double length -> for
    int ticks1 -> new
    53:53:int hashCode() -> hashCode
    58:58:boolean equals(java.lang.Object) -> equals
    62:72:void tickUpdate() -> do
    75:183:void step() -> if
    186:186:float getGravity() -> do
    190:191:void move(nidefawl.qubes.vec.Vec3D) -> do
    194:195:void move(nidefawl.qubes.vec.Vector3f) -> do
    197:202:void move(double,double,double) -> do
    208:211:void setYawPitch(float,float) -> do
    217:217:nidefawl.qubes.nbt.Tag writeClientData(boolean) -> do
    221:221:void readClientData(nidefawl.qubes.nbt.Tag) -> do
    nidefawl.qubes.entity.EntityType getEntityType() -> do
    230:238:int getLookDir() -> do
    242:242:nidefawl.qubes.world.World getWorld() -> do
    251:255:nidefawl.qubes.vec.Vector3f getRenderPos(float) -> do
    264:277:nidefawl.qubes.vec.Vector3f getRenderRot(float) -> if
    284:286:void setRemotePos(nidefawl.qubes.vec.Vec3D) -> if
    294:296:void setRemoteRotation(float,float,float) -> do
nidefawl.qubes.entity.EntityType -> IjL1L1JiiJiJL11L:
    nidefawl.qubes.entity.EntityType[] mapping -> do
    int id -> do
    java.lang.Class clazz -> do
    java.lang.Class clientClass -> if
    nidefawl.qubes.entity.EntityType PLAYER -> do
    36:40:nidefawl.qubes.entity.Entity newById(int) -> do
    46:53:nidefawl.qubes.entity.Entity newInstance() -> do
nidefawl.qubes.entity.Player -> ll1LjIL1JiiJll1L:
    java.lang.String name -> do
    int punchTicks -> try
    nidefawl.qubes.inventory.PlayerInventory inventory -> do
    nidefawl.qubes.inventory.PlayerInventoryCrafting[] inventoryCraft -> do
    23:23:java.lang.String getName() -> if
    28:28:nidefawl.qubes.entity.EntityType getEntityType() -> do
    32:34:void tickUpdate() -> do
    36:39:void updateTicks() -> for
    45:45:nidefawl.qubes.item.BaseStack getEquippedItem() -> do
    50:50:nidefawl.qubes.inventory.PlayerInventory getInventory() -> do
    53:65:nidefawl.qubes.inventory.BaseInventory getInv(int) -> do
    68:68:nidefawl.qubes.inventory.slots.Slots getSlots(int) -> do
nidefawl.qubes.entity.PlayerRemote -> llJilljIiJllJiIj:
    22:25:void readClientData(nidefawl.qubes.nbt.Tag) -> do
    29:56:void tickUpdate() -> do
nidefawl.qubes.entity.PlayerSelf -> L1IjL1IjlliJIj1L:
    float forward -> case
    float strafe -> char
    float maxSpeed -> else
    boolean fly -> for
    float jump -> goto
    boolean jumped -> int
    float sneak -> long
    float eyeHeight -> byte
    nidefawl.qubes.PlayerProfile profile -> do
    nidefawl.qubes.network.client.ClientHandler clientHandler -> do
    nidefawl.qubes.inventory.slots.SlotsInventory slotsInventory -> do
    nidefawl.qubes.inventory.slots.SlotsCrafting slotsCrafting -> do
    nidefawl.qubes.crafting.CraftingManagerClient crafting -> do
    42:74:void updateInputDirect(nidefawl.qubes.input.InputController) -> do
    78:187:void tickUpdate() -> do
    190:190:float getGravity() -> do
    194:195:void toggleFly() -> int
    198:199:void setFly(boolean) -> do
    203:203:nidefawl.qubes.entity.EntityType getEntityType() -> do
    211:214:void clicked(int,boolean) -> do
    218:224:nidefawl.qubes.inventory.slots.Slots getSlots(int) -> do
    228:228:nidefawl.qubes.crafting.CraftingManagerClient getCrafting(int) -> do
nidefawl.qubes.entity.PlayerServer -> lliJll1LjIL1jIiJ:
    nidefawl.qubes.network.server.ServerHandlerPlay netHandler -> do
    boolean flying -> for
    int chunkX -> byte
    int chunkZ -> case
    boolean chunkTracked -> int
    java.util.Set chunks -> do
    java.util.Set sendChunks -> if
    int lastLight -> char
    java.util.UUID spawnWorld -> do
    int chunkLoadDistance -> else
    java.util.Set joinedChannels -> for
    nidefawl.qubes.world.BlockPlacer blockPlace -> do
    java.util.HashMap worldPositions -> do
    nidefawl.qubes.server.PlayerEntityTracker entTracker -> do
    nidefawl.qubes.inventory.slots.SlotsCrafting slotsCrafting -> do
    nidefawl.qubes.inventory.slots.SlotsInventory slotsInventory -> do
    nidefawl.qubes.crafting.CraftingManager crafting -> do
    72:147:void tickUpdate() -> do
    150:161:void load(nidefawl.qubes.player.PlayerData) -> do
    164:176:nidefawl.qubes.player.PlayerData save() -> do
    181:181:int getChunkLoadDistance() -> if
    185:189:void watchingChunk(long,int,int) -> do
    192:199:void unwatchingChunk(long,int,int) -> if
    202:203:void kick(java.lang.String) -> do
    209:213:void setChunkLoadDistance(int) -> do
    218:218:java.util.Collection getJoinedChannels() -> do
    224:224:void preExecuteCommand(nidefawl.qubes.server.commands.Command) -> do
    229:235:void onError(nidefawl.qubes.server.commands.Command,nidefawl.qubes.server.commands.CommandException) -> do
    239:240:void onUnknownCommand(java.lang.String,java.lang.String) -> if
    244:244:nidefawl.qubes.server.GameServer getServer() -> do
    249:250:void sendMessage(java.lang.String) -> if
    254:254:java.lang.String getChatName() -> do
    259:260:void sendMessage(java.lang.String,java.lang.String) -> do
    263:264:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    271:273:void move(double,double,double) -> do
    277:283:nidefawl.qubes.nbt.Tag writeClientData(boolean) -> do
    288:289:nidefawl.qubes.item.BaseStack recvItem(nidefawl.qubes.item.BaseStack) -> do
    293:299:nidefawl.qubes.inventory.slots.Slots getSlots(int) -> do
    303:304:void onWorldLeave() -> int
    307:307:nidefawl.qubes.crafting.CraftingManager getCrafting(int) -> do
    310:315:void syncInventory() -> new
    318:332:void updatePostTick() -> try
nidefawl.qubes.event.Events -> L1iJL11LJiiJlljI:
    18:22:void onServerStarted(nidefawl.qubes.server.GameServer) -> do
nidefawl.qubes.font.FontRenderer -> jIjIL1llL1jIll1L:
    java.util.HashMap fonts -> do
    java.util.HashMap ttfMap -> if
    nidefawl.qubes.font.TrueTypeFont trueTypeFont -> do
    int lineHeight -> for
    float size -> if
    int style -> int
    java.lang.String fontName -> do
    int maxWidth -> do
    int drawedHeight -> if
    float shadowOffset -> do
    27:36:nidefawl.qubes.font.FontRenderer get(java.lang.String,float,int,int) -> do
    51:51:void init() -> do
    70:75:java.awt.Font getFont() -> do
    79:86:void setupFont() -> if
    89:89:int drawString(java.lang.String,float,float,int,boolean,float) -> do
    93:110:int drawString(java.lang.String,float,float,int,boolean,float,int) -> do
    113:113:int getTexture() -> do
    137:137:int getStringWidth(java.lang.String) -> do
    194:194:int getLineHeight() -> if
    224:224:boolean isValid(char) -> do
nidefawl.qubes.font.IStringHistory -> llllllJill1L1LjI:
    void addHistory(java.lang.String) -> do
    int getHistorySize() -> if
    java.lang.String getHistory(int) -> do
    int indexOfHistory(java.lang.String) -> do
    void removeHistory(int) -> do
    void addHistory(int,java.lang.String) -> do
nidefawl.qubes.font.ITextEdit -> iJjIJilljIjIJi1L:
    void submit(nidefawl.qubes.font.TextInput) -> do
    void onEscape(nidefawl.qubes.font.TextInput) -> if
nidefawl.qubes.font.TextInput -> JiiJiJiJL1IjL1ll:
    nidefawl.qubes.font.TrueTypeFont trueType -> do
    java.lang.String editText -> do
    java.lang.String searchPattern -> if
    boolean mouseDown -> do
    boolean rightMouseDown -> if
    boolean did -> for
    int selStart -> do
    int selEnd -> if
    int shiftPX -> for
    int mpos -> int
    int tick -> new
    java.lang.String prevText -> for
    nidefawl.qubes.font.IStringHistory history -> do
    int commandScroll -> try
    boolean focused -> int
    nidefawl.qubes.font.FontRenderer font -> do
    int xPos -> byte
    int yPos -> case
    int width -> char
    int height -> else
    nidefawl.qubes.font.ITextEdit itextedit -> do
    boolean use17 -> new
    66:67:void clearPreview() -> do
    70:94:void calculatePreview() -> if
    98:114:void onTextInput(int) -> do
    116:125:void saveHistory() -> for
    127:131:void resetInput() -> int
    133:306:boolean onKeyPress(int,int,int,int) -> do
    310:312:void onSubmit() -> try
    315:325:void makeCursorVisible() -> new
    328:328:boolean hasSelection() -> do
    333:338:java.lang.String getSelection() -> do
    343:357:java.lang.String replaceSelection(java.lang.String) -> do
    361:375:void insertTextAtCursor(java.lang.String) -> do
    378:401:int getCharPositionFromXCoord(double) -> do
    405:648:void drawStringWithCursor(double,double,boolean) -> do
    651:655:void checkCursor() -> byte
    658:659:void onEscape() -> case
    662:662:int getLeft() -> do
    665:665:int getTop() -> if
    668:668:int getWidth() -> for
    671:671:int getHeight() -> int
    674:674:int getRight() -> new
    677:677:int getBottom() -> try
    684:685:void setHistory(nidefawl.qubes.font.IStringHistory) -> do
nidefawl.qubes.font.TrueTypeFont -> L1lljIjIiJIjjIIj:
    int[] colorMap -> do
    int texture -> else
    int fontHeight -> do
    int fontTextureID -> if
    java.awt.FontMetrics fontMetrics -> do
    int correctL -> for
    int descent -> int
    int ascent -> new
    int usedTextureHeight -> try
    int maxAscent -> byte
    int spaceWidth -> case
    boolean useAA -> do
    java.awt.image.BufferedImage image -> do
    int drawedHeight -> char
    boolean valid -> if
    nidefawl.qubes.font.TrueTypeFont$GlyphRect[] rects -> do
    java.util.HashMap charMap -> do
    java.awt.Font font -> do
    int[] usedY -> if
    int offset -> goto
    103:103:int getControlChar(char) -> do
    134:142:void drawGlyph(nidefawl.qubes.font.TrueTypeFont$GlyphRect,float,float,java.awt.Shape,java.awt.Graphics2D,boolean) -> do
    145:297:boolean createSet(int,int,java.awt.Font,int,int,int) -> do
    385:448:int getWidth(java.lang.String) -> do
    468:470:int getCharWidth(java.lang.Character) -> do
    489:489:int getLineHeight() -> do
    503:503:java.lang.String trimColorChars(java.lang.String) -> do
    507:680:int drawString(nidefawl.qubes.gl.Tess,float,float,java.lang.String,int,boolean,float,int) -> do
    684:686:void unallocate() -> do
    697:700:nidefawl.qubes.font.TrueTypeFont$GlyphRect getRect(int) -> do
    704:705:int getRectWidth(int) -> do
    717:717:boolean isValid() -> do
nidefawl.qubes.font.TrueTypeFont$1 -> iJIjiJll1LjIllL1:
    nidefawl.qubes.font.TrueTypeFont this$0 -> do
    218:222:int compare(nidefawl.qubes.font.TrueTypeFont$GlyphRect,nidefawl.qubes.font.TrueTypeFont$GlyphRect) -> do
    215:215:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.font.TrueTypeFont$GlyphRect -> iJjIJillJill1LjI:
    char ch -> do
    int width -> do
    int height -> if
    int advance -> for
    int yoffset -> int
    int x -> new
    int y -> try
    float tY2 -> do
    float tX2 -> if
    float tY1 -> for
    float tX1 -> int
    nidefawl.qubes.font.TrueTypeFont this$0 -> do
    743:749:void setXY(int,int,int) -> do
    752:757:void drawQuadTess(nidefawl.qubes.gl.Tess,float,float) -> do
nidefawl.qubes.font.TrueTypeFont$Padding -> jIiJ1LjIJijIjI:
    int top -> do
    int left -> if
    int right -> for
    int bottom -> int
    int advance -> new
    nidefawl.qubes.font.TrueTypeFont this$0 -> do
nidefawl.qubes.gl.AbstractTesselatorState -> JiJiIj1LL1IjJi:
    int vertexcount -> do
    boolean useColorPtr -> do
    boolean useTexturePtr -> if
    boolean useNormalPtr -> for
    boolean useUINTPtr -> int
    18:23:void copyTo(nidefawl.qubes.gl.AbstractTesselatorState) -> do
    nidefawl.qubes.gl.GLVBO getVBO() -> do
    28:28:int getIdx(int) -> do
    32:41:int getVSize() -> do
    79:81:void drawVBO(int) -> do
    84:85:void drawQuads() -> do
    88:92:void bindAndDraw(int) -> if
    94:103:int getSetting() -> if
nidefawl.qubes.gl.BufferedMatrix -> iJ1LIjjIjIIjjIIj:
    nidefawl.qubes.vec.Matrix4f inv -> do
    boolean needInv -> do
    java.nio.FloatBuffer cur -> do
    java.nio.FloatBuffer curInv -> if
    26:34:void update() -> do
    37:38:java.nio.FloatBuffer get() -> do
    42:46:java.nio.FloatBuffer getInv() -> if
    49:52:nidefawl.qubes.vec.Matrix4f getInvMat4() -> do
    56:61:void createInv() -> for
    67:69:void free() -> if
nidefawl.qubes.gl.Camera -> jIL1iJjI1LL1jI1L:
    float pitchAngle -> do
    float bearingAngle -> if
    nidefawl.qubes.vec.Vector3f position -> do
    nidefawl.qubes.vec.Vector3f prevposition -> if
    nidefawl.qubes.vec.Matrix4f viewMatrix -> do
    nidefawl.qubes.vec.Matrix4f thirdPersonMat -> if
    nidefawl.qubes.vec.Vector3f thirdPersonOffset -> for
    boolean changed -> do
    32:33:void setPosition(nidefawl.qubes.vec.Vector3f) -> do
    37:41:void setPosition(float,float,float) -> do
    51:67:void setOrientation(float,float,boolean,float) -> do
    73:73:nidefawl.qubes.vec.Vector3f getPosition() -> do
    89:89:nidefawl.qubes.vec.Matrix4f getViewMatrix() -> do
    96:96:nidefawl.qubes.vec.Vector3f getCameraOffset() -> if
nidefawl.qubes.gl.Engine -> jI1L1L1LiJjIIjJi:
    nidefawl.qubes.vec.BlockPos GLOBAL_OFFSET -> do
    nidefawl.qubes.vec.BlockPos LAST_REPOS -> if
    java.util.Map bufferBindingPoints -> do
    int NEXT_BUFFER_BINDING_POINT -> do
    boolean initRenderers -> do
    java.nio.IntBuffer viewport -> do
    java.nio.FloatBuffer position -> do
    java.nio.IntBuffer allocBuffer -> if
    nidefawl.qubes.gl.BufferedMatrix projection -> do
    nidefawl.qubes.gl.BufferedMatrix view -> if
    nidefawl.qubes.gl.BufferedMatrix viewInvYZ -> for
    nidefawl.qubes.gl.BufferedMatrix viewprojection -> int
    nidefawl.qubes.gl.BufferedMatrix modelviewprojection -> new
    nidefawl.qubes.vec.Matrix4f modelviewprojectionInv -> if
    nidefawl.qubes.gl.BufferedMatrix modelview -> try
    nidefawl.qubes.gl.BufferedMatrix normalMatrix -> byte
    nidefawl.qubes.gl.BufferedMatrix orthoP -> case
    nidefawl.qubes.gl.BufferedMatrix orthoMV -> char
    nidefawl.qubes.gl.BufferedMatrix orthoMVP -> else
    nidefawl.qubes.gl.BufferedMatrix ortho3DP -> goto
    nidefawl.qubes.gl.BufferedMatrix ortho3DMV -> long
    nidefawl.qubes.gl.BufferedMatrix tempMatrix -> this
    nidefawl.qubes.gl.BufferedMatrix tempMatrix2 -> void
    nidefawl.qubes.gl.BufferedMatrix identity -> break
    nidefawl.qubes.vec.Vector3f pxOffset -> do
    nidefawl.qubes.vec.TransformStack pxStack -> do
    nidefawl.qubes.vec.Matrix4f invertYZ -> do
    nidefawl.qubes.gl.FrameBuffer fbScene -> do
    nidefawl.qubes.gl.FrameBuffer fbDbg -> if
    float znear -> do
    float zfar -> if
    nidefawl.qubes.gl.TesselatorState fullscreenquad -> do
    nidefawl.qubes.gl.TesselatorState quad -> if
    nidefawl.qubes.vec.Frustum camFrustum -> do
    nidefawl.qubes.vec.Vector3f up -> if
    nidefawl.qubes.vec.Vector4f back -> do
    nidefawl.qubes.vec.Vector3f lightPosition -> for
    nidefawl.qubes.vec.Vector3f lightDirection -> int
    float sunAngle -> for
    nidefawl.qubes.gl.Camera camera -> do
    nidefawl.qubes.gl.ShadowProjector shadowProj -> do
    nidefawl.qubes.render.WorldRenderer worldRenderer -> do
    nidefawl.qubes.render.ShadowRenderer shadowRenderer -> do
    nidefawl.qubes.render.FinalRenderer outRenderer -> do
    nidefawl.qubes.render.region.RegionRenderer regionRenderer -> do
    nidefawl.qubes.render.LightCompute lightCompute -> do
    nidefawl.qubes.meshing.MeshThread regionRenderThread -> do
    float aspectRatio -> int
    int fieldOfView -> if
    boolean renderWireFrame -> if
    boolean USE_TRIANGLES -> for
    boolean isDepthMask -> try
    boolean isScissors -> int
    boolean updateRenderOffset -> new
    nidefawl.qubes.render.gui.SingleBlockRenderer blockRender -> do
    nidefawl.qubes.render.gui.SingleBlockDraw blockDraw -> do
    nidefawl.qubes.item.ItemRenderer itemRender -> do
    nidefawl.qubes.gl.GLVAO active -> do
    nidefawl.qubes.shader.ShaderBuffer debugOutput -> do
    nidefawl.qubes.vec.Vector3f vOrigin -> new
    nidefawl.qubes.vec.Vector3f vDir -> try
    nidefawl.qubes.vec.Vector3f vDirTmp -> byte
    nidefawl.qubes.vec.Vector3f vTarget -> case
    nidefawl.qubes.vec.Vector3f t -> char
    104:109:void bindVAO(nidefawl.qubes.gl.GLVAO) -> do
    112:113:void bindIndexBuffer(int) -> do
    116:117:void bindBuffer(int) -> if
    125:130:boolean checkGLError(java.lang.String) -> do
    134:171:void baseInit() -> do
    174:200:void init() -> if
    203:272:void resize(int,int) -> do
    274:288:void updateOrthoMatrix(float,float) -> do
    291:292:void drawFullscreenQuad() -> for
    295:296:void drawQuad() -> int
    300:300:nidefawl.qubes.gl.BufferedMatrix getMatSceneP() -> do
    303:303:nidefawl.qubes.gl.BufferedMatrix getMatSceneV() -> if
    306:306:nidefawl.qubes.gl.BufferedMatrix getMatSceneV_YZ_Inv() -> for
    309:309:nidefawl.qubes.gl.BufferedMatrix getMatSceneVP() -> int
    313:313:nidefawl.qubes.gl.BufferedMatrix getMatSceneMV() -> new
    316:316:nidefawl.qubes.gl.BufferedMatrix getMatSceneMVP() -> try
    320:320:nidefawl.qubes.gl.BufferedMatrix getMatSceneNormal() -> byte
    330:330:nidefawl.qubes.gl.BufferedMatrix getMatOrthoMVP() -> case
    333:333:nidefawl.qubes.gl.BufferedMatrix getMatOrtho3DMV() -> char
    337:337:nidefawl.qubes.gl.BufferedMatrix getMatOrtho3DP() -> else
    341:341:nidefawl.qubes.gl.BufferedMatrix getTempMatrix() -> goto
    345:345:nidefawl.qubes.gl.BufferedMatrix getTempMatrix2() -> long
    348:348:nidefawl.qubes.gl.BufferedMatrix getIdentityMatrix() -> this
    353:382:void updateCamera() -> new
    386:408:boolean updateGlobalRenderOffset(float,float,float) -> do
    412:412:nidefawl.qubes.gl.FrameBuffer getSceneFB() -> do
    418:429:void flushRenderTasks() -> try
    449:452:void setLightPosition(nidefawl.qubes.vec.Vector3f) -> do
    455:458:void updateShadowProjections(float) -> do
    461:463:void stop() -> byte
    474:507:void updateMouseOverView(float,float,boolean) -> do
    510:527:void reloadRenderer(boolean) -> do
    530:531:void setSceneFB(nidefawl.qubes.gl.FrameBuffer) -> do
    534:543:java.nio.IntBuffer glGenBuffers(int) -> do
    547:551:void deleteBuffers(int[]) -> do
    555:557:void toggleWireFrame() -> case
    569:572:void setOrthoMV(nidefawl.qubes.gl.BufferedMatrix) -> do
    578:581:void restoreOrtho() -> char
    588:593:int getBindingPoint(java.lang.String) -> do
    597:599:void enableDepthMask(boolean) -> if
    602:604:void enableScissors() -> else
    606:608:void disableScissors() -> goto
    610:615:void setOverrideScissorTest(boolean) -> for
    617:622:void restoreScissorTest() -> long
    624:625:void restoreDepthMask() -> this
    628:629:void setOverrideDepthMask(boolean) -> int
nidefawl.qubes.gl.Engine$1 -> iJllL11LL1L1lliJ:
    196:198:void onChange(nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.gl.FrameBuffer -> JiIjJiJiIjjIL11L:
    int FRAMEBUFFERS -> do
    int renderWidth -> if
    int renderHeight -> for
    int fb -> int
    java.nio.IntBuffer drawBufAtt -> do
    boolean hasDepth -> do
    boolean isShadowDepthBuffer -> if
    int numColorTextures -> new
    int depthTexture -> try
    int[] colorAttTextures -> do
    int[] colorAttFormats -> if
    int[] colorAttMinFilters -> for
    int[] colorAttMagFilters -> int
    boolean[] clearBuffer -> do
    float[][] clearColor -> do
    int colorTexExtFmt -> byte
    int colorTexExtType -> case
    59:64:nidefawl.qubes.gl.FrameBuffer make(nidefawl.qubes.util.IResourceManager,int,int,int) -> do
    68:75:void setColorAtt(int,int) -> do
    79:85:void setFilter(int,int,int) -> do
    87:96:void setClearColor(int,float,float,float,float) -> do
    99:100:void setHasDepthAttachment() -> do
    103:105:void setShadowBuffer() -> if
    108:163:void setup(nidefawl.qubes.util.IResourceManager) -> do
    166:168:void unbindFramebuffer() -> for
    170:172:void unbindReadFramebuffer() -> int
    175:177:void bind() -> new
    179:181:void bindRead() -> try
    184:199:void setupTexture(int,int,int,int) -> do
    202:232:void createDepthTextureAttachment(int) -> do
    235:238:int getTexture(int) -> do
    242:245:int getDepthTex() -> do
    250:253:void clearDepth() -> byte
    257:260:void clearColor() -> case
    264:269:void clearColorBlack() -> char
    273:275:void setDrawAll() -> else
    278:294:void clearFrameBuffer() -> goto
    297:316:void release() -> long
    319:319:int getWidth() -> if
    323:323:int getHeight() -> for
    329:329:int getFB() -> int
    333:333:nidefawl.qubes.util.EResourceType getType() -> do
nidefawl.qubes.gl.GL -> lljIL1llIjJiIjiJ:
    boolean directStateAccess -> do
    24:36:void bindTexture(int,int,int) -> do
    39:57:java.util.List validateCaps() -> do
    63:64:void glGetObjectParameterivARB(int,int,java.nio.IntBuffer) -> do
    66:67:void glUniformMatrix4fvARB(int,boolean,java.nio.FloatBuffer) -> do
    79:79:org.lwjgl.opengl.GLCapabilities getCaps() -> do
    82:105:void glTexStorage3D(int,int,int,int,int,int) -> do
    108:117:void glTexStorage2D(int,int,int,int,int) -> do
    120:129:int genStorage(int,int,int,int,int) -> do
    133:136:void deleteTexture(int) -> do
nidefawl.qubes.gl.GLDebugTextures -> iJJill1L1LjI1Lll:
    int format -> do
    java.lang.String name -> do
    java.lang.String pass -> if
    int h -> if
    int w -> for
    int tex -> int
    int d -> new
    int flags -> try
    boolean valid -> do
    boolean show -> if
    java.util.HashMap textures -> do
    java.util.HashMap alltextures -> if
    nidefawl.qubes.gl.GLDebugTextures selTex -> do
    boolean triggered -> for
    45:46:void readTexture(java.lang.String,java.lang.String,int) -> do
    48:79:int readTexture(java.lang.String,java.lang.String,int,int) -> do
    83:85:void release() -> int
    87:93:void onResize() -> do
    96:201:void drawAll(int,int) -> do
    204:221:void bindShader() -> if
    229:229:nidefawl.qubes.gl.GLDebugTextures getSelected() -> do
    232:232:int get() -> do
    237:244:void drawFullScreen(nidefawl.qubes.gl.GLDebugTextures) -> do
    246:246:boolean isShow() -> do
    249:250:void setShow(boolean) -> do
    253:272:void toggleDebugTex() -> for
nidefawl.qubes.gl.GLQuadBuffer -> iJJilljIiJIjlliJ:
    int vbo -> do
    int vboIndices -> if
    nidefawl.qubes.gl.ReallocIntBuffer vboBuf -> do
    nidefawl.qubes.gl.ReallocIntBuffer vboIdxBuf -> if
    73:80:void release() -> do
nidefawl.qubes.gl.GLTriBuffer -> IjJiIjiJll1LiJll:
    int vbo -> do
    int vboIndices -> if
    nidefawl.qubes.gl.ReallocIntBuffer vboBuf -> do
    nidefawl.qubes.gl.ReallocIntBuffer vboIdxBuf -> if
    int triCount -> for
    int vertexCount -> int
    36:43:void gen() -> do
    46:69:void upload(nidefawl.qubes.gl.VertexBuffer) -> do
    98:104:void draw() -> if
    110:117:void release() -> for
nidefawl.qubes.gl.GLVAO -> llL1iJjIlliJllL1:
    int NEXT_VAO_ID -> for
    nidefawl.qubes.gl.GLVAO[] vaoList -> if
    int stride -> do
    int vaoId -> if
    nidefawl.qubes.gl.GLVAO vaoBlocksShadow -> do
    nidefawl.qubes.gl.GLVAO vaoBlocksShadowTextured -> if
    nidefawl.qubes.gl.GLVAO vaoModel -> for
    nidefawl.qubes.gl.GLVAO vaoBlocks -> int
    nidefawl.qubes.gl.GLVAO[] vaoTesselator -> do
    18:21:void initVAOs() -> do
    23:23:void init() -> if
nidefawl.qubes.gl.GLVAO$1 -> jIiJjIll1LlljIiJ:
    26:38:void init() -> if
nidefawl.qubes.gl.GLVAO$2 -> IjJijIJiiJjIIjjI:
    42:60:void init() -> if
nidefawl.qubes.gl.GLVAO$3 -> IjiJIj1LiJL1IjjI:
    65:86:void init() -> if
nidefawl.qubes.gl.GLVAO$4 -> iJjI1LjIiJJijIiJ:
    90:117:void init() -> if
nidefawl.qubes.gl.GLVAO$5 -> L1IjIjIjIjjIL11L:
    int val$tessSetting -> for
    125:163:void init() -> if
nidefawl.qubes.gl.GLVBO -> iJL1iJ1L1LJi1LjI:
    int vboId -> do
    int vboSize -> if
    12:16:void bind() -> do
    18:18:int getVboId() -> do
    21:27:void upload(java.nio.ByteBuffer,int) -> do
    29:32:void release() -> if
nidefawl.qubes.gl.GPUVendor -> iJL1L11LIjlljIll:
    nidefawl.qubes.gl.GPUVendor NVIDIA -> do
    nidefawl.qubes.gl.GPUVendor AMD -> if
    nidefawl.qubes.gl.GPUVendor INTEL -> for
    nidefawl.qubes.gl.GPUVendor OTHER -> int
    nidefawl.qubes.gl.GPUVendor[] $VALUES -> do
    10:10:nidefawl.qubes.gl.GPUVendor[] values() -> values
    10:10:nidefawl.qubes.gl.GPUVendor valueOf(java.lang.String) -> valueOf
    18:36:nidefawl.qubes.gl.GPUVendor parse(java.lang.String) -> do
nidefawl.qubes.gl.Memory -> iJ1Lllll1LiJIjll:
    int mallocd -> do
    22:23:java.nio.FloatBuffer createFloatBuffer(int) -> do
    27:28:java.nio.IntBuffer createIntBuffer(int) -> do
    37:38:java.nio.DoubleBuffer createDoubleBuffer(int) -> do
    42:42:java.nio.FloatBuffer createFloatBufferAligned(int,int) -> do
    51:58:java.nio.ByteBuffer createByteBufferAligned(int,int) -> do
    68:70:java.nio.ByteBuffer reallocByteBufferAligned(java.nio.ByteBuffer,int,int) -> do
    85:87:java.nio.IntBuffer createIntBufferGC(int) -> if
    94:96:void free(java.nio.FloatBuffer) -> do
    102:104:void free(java.nio.ByteBuffer) -> do
    107:108:java.nio.IntBuffer createIntBufferHeap(int) -> for
    116:117:java.nio.FloatBuffer createFloatBufferHeap(int) -> if
nidefawl.qubes.gl.ReallocIntBuffer -> JiIjIjL1jIL1JijI:
    java.nio.ByteBuffer buffers -> do
    java.nio.IntBuffer intbuffers -> do
    34:46:void reallocBuffer(int) -> do
    48:53:void release() -> do
    68:72:void put(int[],int,int) -> do
    78:78:java.nio.ByteBuffer getByteBuf() -> do
nidefawl.qubes.gl.ShadowProjector -> jIiJiJiJllllJiL1:
    nidefawl.qubes.vec.Matrix4f[] shadowSplitProj -> do
    nidefawl.qubes.gl.BufferedMatrix[] shadowSplitMVP -> do
    float[] shadowSplitDepth -> do
    nidefawl.qubes.vec.Frustum[] shadowCamFrustum -> do
    nidefawl.qubes.vec.Matrix4f newMat -> do
    nidefawl.qubes.vec.Matrix4f newMatInv -> if
    nidefawl.qubes.vec.Matrix4f matLookAt -> for
    nidefawl.qubes.vec.Matrix4f matLookAtInv -> int
    nidefawl.qubes.vec.Matrix4f matOrtho -> new
    nidefawl.qubes.vec.Vector3f frustumCenter -> do
    nidefawl.qubes.vec.Vector3f tmp -> if
    nidefawl.qubes.vec.Vector3f eye -> for
    nidefawl.qubes.vec.Vector3f[] furstumCornersIn -> do
    nidefawl.qubes.vec.Vector3f[] furstumCornersOut -> if
    float[] splits -> if
    49:126:void calcShadow(int,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,float) -> do
    129:156:void setSplits(float[],float,float) -> do
    159:162:void calcSplits(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,float) -> do
    164:164:int checkFrustum(int,nidefawl.qubes.vec.AABBInt,float) -> do
    173:173:java.nio.FloatBuffer getSMVP(int) -> do
nidefawl.qubes.gl.Tess -> jIIjL1JijIJiL1Ij:
    java.lang.String[] attributes -> do
    boolean littleEndian -> new
    nidefawl.qubes.gl.Tess instance -> do
    nidefawl.qubes.gl.Tess tessFont -> if
    int[] rawBuffer -> do
    int rgba -> if
    int uintLSB -> for
    int uintMSB -> int
    float u -> do
    float v -> if
    int normal -> new
    float offsetX -> for
    float offsetY -> int
    float offsetZ -> new
    boolean isSoftTesselator -> try
    nidefawl.qubes.gl.ReallocIntBuffer bufInt -> do
    int vboIdx -> try
    nidefawl.qubes.gl.GLVBO[] vbo -> do
    56:56:boolean isSoftTesselator() -> do
    60:67:void add(float,float,float,float,float) -> do
    79:80:void add(float,float) -> do
    83:91:void setNormals(float,float,float) -> do
    94:124:void add(float,float,float) -> if
    128:132:void resizeBuffer() -> if
    136:151:void setColorRGBAF(float,float,float,float) -> do
    154:159:void setUIntLSB(int) -> for
    168:177:void setColor(int,int) -> do
    180:181:void setColorF(int,float) -> do
    184:206:void draw(int,nidefawl.qubes.gl.AbstractTesselatorState) -> do
    209:209:nidefawl.qubes.gl.GLVBO getVBO() -> do
    213:214:void draw(int) -> int
    218:219:void drawQuads() -> do
    224:231:void resetState() -> for
    234:238:void destroy() -> int
    241:244:void setOffset(float,float,float) -> for
    247:249:void destroyAll() -> new
nidefawl.qubes.gl.TesselatorState -> Ij1LIjjIJiiJ1L:
    nidefawl.qubes.gl.GLVBO vbo -> do
    8:8:nidefawl.qubes.gl.GLVBO getVBO() -> do
nidefawl.qubes.gl.VertexBuffer -> iJlliJiJIjllIjll:
    int[] buffer -> do
    int[] triIdxBuffer -> if
    int triIdxPos -> do
    int pos -> if
    int left -> for
    int left2 -> int
    int vertexCount -> new
    int faceCount -> try
    40:46:void reset() -> do
    53:59:int realloc(int) -> do
    66:72:int reallocTriIdxBuffer(int) -> if
    78:85:void put(int) -> do
    87:95:void putIdx(int) -> if
    100:101:void increaseVert() -> if
    106:107:void increaseFace() -> for
    112:112:int getVertexCount() -> do
    118:118:int getFaceCount() -> if
    130:130:int getTriIdxPos() -> for
    136:136:int[] get() -> do
    142:142:int[] getTriIdxBuffer() -> if
    174:176:int putIn(nidefawl.qubes.gl.ReallocIntBuffer) -> do
    191:192:void incVertCount(int) -> for
    195:201:void putTriIndex(int[]) -> do
nidefawl.qubes.gui.AbstractUI -> jIlliJ1LJiL11LIj:
    nidefawl.qubes.gui.AbstractUI parent -> do
    int id -> do
    int width -> if
    int height -> for
    int posX -> int
    int posY -> new
    int[] overridebounds -> do
    boolean hovered -> do
    boolean enabled -> if
    boolean draw -> for
    boolean focused -> int
    int zIndex -> try
    nidefawl.qubes.gui.AbstractUI selectedButton -> if
    int color -> byte
    float alpha -> do
    int color2 -> case
    float alpha2 -> if
    int color3 -> char
    float alpha3 -> for
    int color4 -> else
    int color5 -> goto
    int color6 -> long
    float alpha4 -> int
    float boxSigma -> new
    float shadowSigma -> try
    float round -> byte
    int extendx -> this
    int extendy -> void
    26:30:void saveBounds() -> do
    32:36:void restoreBounds() -> if
    38:40:void setSize(int,int) -> do
    42:44:void setPos(int,int) -> if
    46:46:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> do
    49:49:void add(nidefawl.qubes.gui.AbstractUI) -> do
    52:52:void update() -> for
    55:55:boolean mouseOver(double,double) -> do
    59:59:boolean handleMouseUp(nidefawl.qubes.gui.Gui,int) -> do
    62:62:boolean handleMouseDown(nidefawl.qubes.gui.Gui,int) -> if
    65:65:boolean onKeyPress(int,int,int,int) -> do
    68:68:boolean onTextInput(int) -> do
    72:73:void setFocus() -> int
    92:97:void resetShape() -> new
    100:125:void renderRoundedBoxShadow(float,float,float,float,float,int,float,boolean) -> do
    127:152:void renderRoundedBoxShadowInverse(float,float,float,float,float,int,float,boolean) -> if
    154:169:void renderOutlinedBox() -> try
    171:178:void renderBox() -> byte
    183:203:void renderBox(boolean,boolean,int,int) -> do
    205:225:void renderBox2(boolean,boolean,int,int) -> if
    227:227:int getWindowPosX() -> do
    230:230:int getWindowPosY() -> if
    234:247:void renderSlotBackground(float,float,float,float,float,int,float,boolean,float) -> do
nidefawl.qubes.gui.Gui -> iJjIL11L1Lll:
    java.util.ArrayList buttons -> do
    java.util.ArrayList prebackground -> if
    boolean firstOpen -> new
    nidefawl.qubes.gui.controls.AbstractUIOverlay popup -> do
    32:32:nidefawl.qubes.gui.controls.AbstractUIOverlay getPopup() -> do
    35:35:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> do
    38:40:void add(nidefawl.qubes.gui.AbstractUI) -> do
    42:46:void addBackground(nidefawl.qubes.gui.AbstractUI) -> if
    48:50:void clearElements() -> case
    52:61:void sortElements() -> char
    64:65:void remove(nidefawl.qubes.gui.AbstractUI) -> for
    68:72:void setPopup(nidefawl.qubes.gui.controls.AbstractUIOverlay) -> do
    75:82:void renderBackgroundElements(float,double,double) -> a_
    84:96:void renderButtons(float,double,double) -> if
    99:99:void onClose() -> else
    102:142:boolean onMouseClick(int,int) -> do
    146:146:double mouseOffsetY() -> do
    150:150:double mouseOffsetX() -> if
    154:154:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    158:175:boolean onKeyPress(int,int,int,int) -> do
    179:180:void close() -> goto
    183:191:boolean onTextInput(int) -> do
    195:195:boolean requiresTextInput() -> do
    198:210:void renderBackground(float,double,double,boolean,float) -> do
    213:213:void updateBounds() -> long
    216:216:boolean canResize() -> if
    220:220:boolean onWheelScroll(double,double) -> if
nidefawl.qubes.gui.Gui$1 -> IjllJijIjI1LJiIj:
    nidefawl.qubes.gui.Gui this$0 -> do
    55:58:int compare(nidefawl.qubes.gui.AbstractUI,nidefawl.qubes.gui.AbstractUI) -> do
    52:52:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.gui.GuiAction -> Ji1LjIIjL1JiIjjI:
    int mouseAction -> do
    17:17:boolean isAct(int) -> do
nidefawl.qubes.gui.GuiBG -> JillIjjIIjllIj1L:
    9:13:void render(float,double,double) -> do
    17:17:void initGui(boolean) -> do
nidefawl.qubes.gui.GuiCached -> JijIiJIjlljIL1ll:
    nidefawl.qubes.gui.Gui gui -> do
    nidefawl.qubes.gl.FrameBuffer fbDbg -> do
    boolean refresh -> try
    26:27:void setPos(int,int) -> if
    31:39:void setSize(int,int) -> do
    42:57:void render(float,double,double) -> do
    59:61:void refresh() -> this
    64:64:void initGui(boolean) -> do
nidefawl.qubes.gui.GuiChatInput -> L1L1iJjI1L1LIjll:
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.gui.controls.TextField field -> do
    nidefawl.qubes.gui.GuiOverlayChat overlay -> do
    int mouseResize -> break
    39:42:void setSize(int,int) -> do
    46:62:void initGui(boolean) -> do
    66:66:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    71:73:boolean onKeyPress(int,int,int,int) -> do
    78:86:boolean onMouseClick(int,int) -> do
    90:95:boolean over(double,double) -> for
    101:122:void render(float,double,double) -> do
    126:133:void submit(nidefawl.qubes.font.TextInput) -> do
    137:138:void onEscape(nidefawl.qubes.font.TextInput) -> if
    141:141:boolean requiresTextInput() -> do
nidefawl.qubes.gui.GuiConnecting -> jIjIiJIjL1jIJiJi:
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.font.FontRenderer fontSmall -> if
    java.lang.String stateStr -> do
    nidefawl.qubes.network.client.ThreadConnect thread -> do
    24:32:void initGui(boolean) -> do
    35:39:void update() -> for
    42:48:void render(float,double,double) -> do
    51:55:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.GuiControls -> jIjIiJ1LJiL11L1L:
    nidefawl.qubes.gui.GuiControls$Control selected -> do
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.gui.controls.Button back -> do
    java.util.List list -> do
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
    nidefawl.qubes.input.Keybinding inUseKey -> do
    108:139:void initGui(boolean) -> do
    142:145:boolean onMouseClick(int,int) -> do
    149:151:void update() -> for
    154:184:void render(float,double,double) -> do
    187:211:boolean onKeyPress(int,int,int,int) -> do
    217:229:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    232:236:boolean onWheelScroll(double,double) -> if
nidefawl.qubes.gui.GuiControls$Control -> jI1LL1jIjIjI1Lll:
    nidefawl.qubes.input.Keybinding b -> do
    41:88:void render(float,double,double) -> do
    92:92:void initGui(boolean) -> do
    27:27:nidefawl.qubes.input.Keybinding access$000(nidefawl.qubes.gui.GuiControls$Control) -> do
nidefawl.qubes.gui.GuiDisconnected -> iJIjjIjIiJiJ1L:
    nidefawl.qubes.font.FontRenderer font -> do
    java.lang.String reason -> do
    20:28:void initGui(boolean) -> do
    31:31:void update() -> for
    34:40:void render(float,double,double) -> do
    43:46:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.GuiGameMenu -> L1JiJijIllllL11L:
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.font.FontRenderer fontSmall -> if
    nidefawl.qubes.gui.controls.Button resume -> do
    nidefawl.qubes.gui.controls.Button settings -> if
    nidefawl.qubes.gui.controls.Button controls -> for
    nidefawl.qubes.gui.controls.Button back -> int
    nidefawl.qubes.gui.controls.Button quit -> new
    23:62:void initGui(boolean) -> do
    64:64:boolean onMouseClick(int,int) -> do
    69:69:void update() -> for
    72:74:void render(float,double,double) -> do
    76:91:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    95:95:boolean requiresTextInput() -> do
nidefawl.qubes.gui.GuiMainMenu -> iJlljIIjIjJillIj:
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.font.FontRenderer fontSmall -> if
    nidefawl.qubes.gui.controls.TextField field -> do
    nidefawl.qubes.gui.controls.TextField fieldN -> if
    nidefawl.qubes.gui.controls.Button connect -> do
    nidefawl.qubes.gui.controls.Button settings -> if
    nidefawl.qubes.gui.controls.Button controls -> for
    nidefawl.qubes.gui.controls.Button quit -> int
    nidefawl.qubes.gui.controls.Button crash -> new
    30:80:void initGui(boolean) -> do
    82:82:boolean onMouseClick(int,int) -> do
    87:87:void update() -> for
    90:92:void render(float,double,double) -> do
    98:114:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    118:119:void submit(nidefawl.qubes.font.TextInput) -> do
    124:131:void connect() -> this
    134:136:void onEscape(nidefawl.qubes.font.TextInput) -> if
    139:139:boolean requiresTextInput() -> do
nidefawl.qubes.gui.GuiOverlayChat -> L1IjjIJiJillJiiJ:
    nidefawl.qubes.font.FontRenderer font -> do
    boolean mouseRes -> try
    27:33:void render(float,double,double) -> do
    37:37:void initGui(boolean) -> do
    46:98:void renderAt(int,boolean) -> do
nidefawl.qubes.gui.GuiOverlayDebug -> lljI1LIjIjllL1L1:
    nidefawl.qubes.font.FontRenderer fontSmall -> do
    nidefawl.qubes.gl.BufferedMatrix mat -> do
    nidefawl.qubes.gl.TesselatorState state -> do
    24:30:void render(float,double,double) -> do
    32:44:void preDbgFB(boolean) -> if
    47:53:void postDbgFB() -> this
    56:57:void drawDbgTexture(int,int,int,int,java.lang.String) -> do
    60:109:void drawDbgTexture(int,int,int,int,java.lang.String,nidefawl.qubes.shader.Shader,float,float) -> do
    168:168:void initGui(boolean) -> do
nidefawl.qubes.gui.GuiOverlayStats -> L1jIL1iJIjJi1L1L:
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.font.FontRenderer fontSmall -> if
    java.util.ArrayList info1 -> for
    java.util.ArrayList info -> int
    java.lang.String stats -> if
    java.lang.String statsRight -> for
    long messageTime -> do
    java.lang.String message -> do
    boolean render -> try
    java.lang.String stats5 -> int
    44:117:void refresh() -> this
    120:191:void render(float,double,double) -> do
    194:196:void setMessage(java.lang.String) -> do
    200:200:void initGui(boolean) -> do
    207:214:void blockClicked(nidefawl.qubes.util.RayTrace$RayTraceIntersection) -> do
nidefawl.qubes.gui.GuiSelectBlock -> lliJiJL1L1lliJll:
    nidefawl.qubes.font.FontRenderer font -> do
    java.util.List blocks -> do
    nidefawl.qubes.gui.controls.Button fakeButton -> do
    nidefawl.qubes.item.BlockStack sel -> do
    float dir -> case
    float rot -> char
    float lastRot -> else
    42:84:void initGui(boolean) -> do
    90:96:void update() -> for
    100:252:void render(float,double,double) -> do
    255:262:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    266:274:boolean onKeyPress(int,int,int,int) -> do
nidefawl.qubes.gui.GuiSelectWorld -> llJiL1IjjIiJJi1L:
    nidefawl.qubes.font.FontRenderer font -> do
    24:32:void initGui(boolean) -> do
    35:35:void update() -> for
    38:60:void render(float,double,double) -> do
    63:66:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    70:78:boolean onKeyPress(int,int,int,int) -> do
nidefawl.qubes.gui.GuiSettings -> IjiJL1lliJlliJjI:
    int nextID -> break
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.gui.controls.Button back -> do
    java.util.List list -> do
    nidefawl.qubes.gui.GuiSettings$Setting testSetting -> do
    nidefawl.qubes.gui.GuiSettings$Setting distanceSetting -> if
    nidefawl.qubes.gui.GuiSettings$Setting shadowSetting -> for
    nidefawl.qubes.gui.GuiSettings$Setting reflectionSetting -> int
    nidefawl.qubes.gui.GuiSettings$Setting smaaSetting -> new
    nidefawl.qubes.gui.GuiSettings$Setting smaaQSetting -> try
    nidefawl.qubes.gui.GuiSettings$Setting aoSetting -> byte
    60:145:void initGui(boolean) -> do
    148:148:boolean onMouseClick(int,int) -> do
    153:153:void update() -> for
    156:167:void render(float,double,double) -> do
    170:191:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.GuiSettings$1 -> IjiJjIiJIjJiL1L1:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    73:73:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$2 -> jIllJiIjIj1LL1Ij:
    java.lang.Integer[] val$values -> do
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    82:85:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$3 -> Ji1LiJllllIjL1:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    90:93:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$4 -> lljIiJjIL1jIjIll:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    98:101:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$5 -> L1Ji1LJillll1LIj:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    106:110:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$6 -> iJL1llIjJi1LiJIj:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    115:118:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$7 -> L11L1LJiJi1LL11L:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    124:127:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$8 -> lljIIjjIllL1iJll:
    nidefawl.qubes.gui.GuiSettings$Setting val$s -> do
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    178:183:void call(nidefawl.qubes.gui.controls.ComboBox$ComboBoxList,int) -> do
nidefawl.qubes.gui.GuiSettings$Setting -> jIL1Ji1LlliJIjll:
    java.lang.Object[] vals -> do
    nidefawl.qubes.gui.controls.ComboBox box -> do
    39:39:void callback(int) -> do
nidefawl.qubes.gui.Tooltip -> IjIjIjIj1LjIJiIj:
    nidefawl.qubes.gui.Tooltip$ItemToolTip item -> do
nidefawl.qubes.gui.Tooltip$1 -> L1iJJillJiIjjIIj:
nidefawl.qubes.gui.Tooltip$ItemToolTip -> iJ1L1LIjiJ:
    nidefawl.qubes.item.BaseStack stack -> do
    nidefawl.qubes.inventory.slots.Slot slot -> do
    nidefawl.qubes.gui.windows.GuiWindow window -> do
    java.lang.String title -> do
    nidefawl.qubes.font.FontRenderer fr -> do
    nidefawl.qubes.font.FontRenderer fr2 -> if
    21:40:nidefawl.qubes.gui.Tooltip$ItemToolTip set(nidefawl.qubes.item.BaseStack,nidefawl.qubes.inventory.slots.Slot,nidefawl.qubes.gui.windows.GuiWindow) -> do
    44:55:void render(float,double,double) -> do
    59:59:void initGui(boolean) -> do
nidefawl.qubes.gui.controls.AbstractUIOverlay -> jIIjIjjI1LJiL1L1:
    16:16:void initGui(boolean) -> do
nidefawl.qubes.gui.controls.Button -> jIjIIjiJjI1LJiiJ:
    java.lang.String text -> do
    nidefawl.qubes.font.FontRenderer font -> do
    21:29:void render(float,double,double) -> do
    34:34:void initGui(boolean) -> do
nidefawl.qubes.gui.controls.ColorPicker -> IjJiIjjIiJIjiJ1L:
    nidefawl.qubes.gui.controls.Button[] colorPick -> do
    float valH -> case
    float valS -> char
    float valL -> else
    int rgb -> break
    29:81:void render(float,double,double) -> do
    84:103:void onColorChange(int) -> do
    107:124:void initGui(boolean) -> do
    128:133:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> do
nidefawl.qubes.gui.controls.ComboBox -> IjJi1LiJIjL1IjJi:
    nidefawl.qubes.font.FontRenderer font -> do
    int textColorDisabled -> break
    int textColorHover -> catch
    int textColor -> class
    float r -> case
    float g -> char
    float b -> else
    float a -> goto
    java.lang.Object value -> do
    int stringWidth -> const
    boolean isOpen -> new
    int sel -> final
    int id -> float
    java.lang.String string -> do
    boolean drawTitle -> try
    boolean titleLeft -> byte
    boolean canexpandHorizontally -> case
    int maxWidthClosed -> short
    int titleWidth -> super
    nidefawl.qubes.gui.controls.ComboBox$ComboBoxList comboBoxList -> do
    nidefawl.qubes.gui.Gui gui -> do
    int scrollbarwidth -> throw
    56:57:void setValue(java.lang.Object) -> do
    72:72:void initGui(boolean) -> do
    365:366:void setWatchPopup(nidefawl.qubes.gui.controls.ComboBox$ComboBoxList) -> do
    387:456:void render(float,double,double) -> do
    462:474:boolean onClick(nidefawl.qubes.gui.controls.PopupHolder) -> do
    20:20:nidefawl.qubes.font.FontRenderer access$000(nidefawl.qubes.gui.controls.ComboBox) -> do
nidefawl.qubes.gui.controls.ComboBox$CallBack -> lllllliJIjIjL1ll:
    void call(nidefawl.qubes.gui.controls.ComboBox$ComboBoxList,int) -> do
nidefawl.qubes.gui.controls.ComboBox$ComboBoxList -> L1L11LiJIjjIL1Ji:
    nidefawl.qubes.gui.controls.PopupHolder parentScreen -> do
    nidefawl.qubes.gui.controls.ComboBox$CallBack callBack -> do
    nidefawl.qubes.gui.controls.ComboBox box -> do
    java.lang.Object[] values -> do
    int size -> catch
    int heightPerEntry -> class
    boolean showScrollBar -> try
    int scrollOffset -> const
    int showMax -> break
    boolean isScrolling -> new
    int scrollBeginY -> final
    112:114:void initGui(boolean) -> do
    117:150:boolean onKeyPress(int,int,int,int) -> do
    158:174:boolean mouseOver(double,double) -> do
    181:186:boolean handleMouseDown(nidefawl.qubes.gui.Gui,int) -> if
    195:361:void render(float,double,double) -> do
nidefawl.qubes.gui.controls.PopupHolder -> iJllIjJiJiIjllll:
    void setPopup(nidefawl.qubes.gui.controls.AbstractUIOverlay) -> do
    nidefawl.qubes.gui.controls.AbstractUIOverlay getPopup() -> do
nidefawl.qubes.gui.controls.ScrollList -> llllIjllL1llJiIj:
    nidefawl.qubes.font.FontRenderer font -> do
    float scrollOffset -> case
    nidefawl.qubes.gui.controls.Button scrollbarbutton -> do
    float scrollY -> char
    49:57:float getContentHeight() -> do
    62:145:void render(float,double,double) -> do
    149:149:void initGui(boolean) -> do
    152:157:boolean onMouseClick(int,int) -> do
    161:164:boolean onWheelScroll(double,double) -> if
    168:173:double mouseOffsetY() -> do
    177:177:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.controls.TextField -> JijIL1jIL1lllliJ:
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.font.TextInput inputRenderer -> do
    32:35:void setPos(int,int) -> if
    39:42:void setSize(int,int) -> do
    45:58:void render(float,double,double) -> do
    61:61:boolean mouseOver(double,double) -> do
    67:67:void initGui(boolean) -> do
    70:70:boolean handleMouseUp(nidefawl.qubes.gui.Gui,int) -> do
    74:76:boolean handleMouseDown(nidefawl.qubes.gui.Gui,int) -> if
    80:84:boolean onKeyPress(int,int,int,int) -> do
    88:92:boolean onTextInput(int) -> do
    96:96:java.lang.String getText() -> do
    103:103:nidefawl.qubes.font.TextInput getTextInput() -> do
nidefawl.qubes.gui.windows.GuiColor -> JiL1jIIjllL1iJ:
    nidefawl.qubes.gui.controls.ColorPicker colorPick -> do
    15:15:java.lang.String getTitle() -> do
    19:37:void initGui(boolean) -> do
    39:39:boolean canResize() -> if
    43:43:void update() -> for
    46:52:void render(float,double,double) -> do
    58:61:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.windows.GuiCrafting -> llL1L1jIll1LjIiJ:
    nidefawl.qubes.gui.controls.Button btn1 -> do
    nidefawl.qubes.gui.controls.Button btn2 -> if
    float progress -> case
    int ticksDone -> break
    boolean running -> try
    float lastProgress -> char
    nidefawl.qubes.crafting.CraftingManagerClient crafting -> do
    22:25:void start() -> catch
    27:30:void end() -> class
    38:38:java.lang.String getTitle() -> do
    42:75:void initGui(boolean) -> do
    78:86:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    90:104:void update() -> for
    107:138:void render(float,double,double) -> do
    140:146:void onRemoteUpdate(int) -> do
nidefawl.qubes.gui.windows.GuiCraftingSelect -> jIIjIjjIjIIjL1ll:
    nidefawl.qubes.gui.windows.GuiCraftingSelect$RecipeSlot selected -> do
    nidefawl.qubes.gui.GuiBG bg -> do
    java.util.List catButtons -> do
    nidefawl.qubes.gui.controls.TextField txtAmount -> do
    nidefawl.qubes.gui.windows.GuiCraftingSelect$CatButton cat -> do
    nidefawl.qubes.gui.windows.GuiCraftingSelect$Category[] categories -> do
    float entryw -> case
    int cols -> break
    256:256:java.lang.String getTitle() -> do
    264:325:void initGui(boolean) -> do
    328:348:void setCat(nidefawl.qubes.gui.windows.GuiCraftingSelect$CatButton) -> do
    351:406:void initLists(boolean,int) -> do
    409:409:boolean onMouseClick(int,int) -> do
    413:418:void update() -> for
    439:440:void renderFrame(float,double,double) -> for
    442:492:void render(float,double,double) -> do
    495:498:boolean onKeyPress(int,int,int,int) -> do
    504:546:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    549:566:void renderSlotOverlay(nidefawl.qubes.inventory.slots.Slot,float,float) -> do
    606:616:void setRecipe(nidefawl.qubes.gui.windows.GuiCraftingSelect$RecipeSlot) -> do
    618:618:boolean onWheelScroll(double,double) -> if
    622:622:void submit(nidefawl.qubes.font.TextInput) -> do
    625:625:void onEscape(nidefawl.qubes.font.TextInput) -> if
    628:628:boolean requiresTextInput() -> do
    33:33:nidefawl.qubes.gui.windows.GuiCraftingSelect$CatButton access$000(nidefawl.qubes.gui.windows.GuiCraftingSelect) -> do
nidefawl.qubes.gui.windows.GuiCraftingSelect$CatButton -> jIjIL1IjL1:
    nidefawl.qubes.gui.windows.GuiCraftingSelect$Category category -> do
    67:119:void render(float,double,double) -> do
nidefawl.qubes.gui.windows.GuiCraftingSelect$Category -> JiiJiJ1LjIiJ1LiJ:
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
    java.util.List list -> do
nidefawl.qubes.gui.windows.GuiCraftingSelect$Control -> L1L1lliJjIIjiJIj:
    java.lang.String string -> do
    java.util.List list -> if
    boolean expanded -> new
    int rows -> break
    java.util.List slots -> do
    198:215:void render(float,double,double) -> do
    219:235:void initGui(boolean) -> do
    238:250:int layout() -> for
nidefawl.qubes.gui.windows.GuiCraftingSelect$PreviewSlots -> jIllllllL1L1jI1L:
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    nidefawl.qubes.inventory.BaseInventory baseInv -> do
    nidefawl.qubes.inventory.BaseInventory playerInv -> if
    592:597:void update() -> do
    601:601:nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
nidefawl.qubes.gui.windows.GuiCraftingSelect$RecipeSlot -> Jill1LJijIIjiJll:
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    132:132:void initGui(boolean) -> do
    136:178:void render(float,double,double) -> do
nidefawl.qubes.gui.windows.GuiInventory -> ll1L1LjI1LJiiJll:
    13:13:java.lang.String getTitle() -> do
    17:36:void initGui(boolean) -> do
    39:39:void update() -> for
    42:45:void render(float,double,double) -> do
nidefawl.qubes.gui.windows.GuiInventoryBase -> JijIjIIjIjiJJi:
    nidefawl.qubes.inventory.slots.Slots slots -> do
    21:67:void renderSlots(float,double,double) -> int
    69:75:void renderSlotOverlay(nidefawl.qubes.inventory.slots.Slot,float,float) -> do
    77:89:boolean onMouseClick(int,int) -> do
    92:92:boolean canResize() -> if
nidefawl.qubes.gui.windows.GuiWindow -> IjiJiJ1LL1iJIjL1:
    boolean allwaysVisible -> byte
    boolean visible -> case
    nidefawl.qubes.font.FontRenderer font -> do
    int[] bounds -> if
    25:31:void initGui(boolean) -> do
    33:33:java.lang.String getTitle() -> do
    37:40:void onDefocus() -> this
    43:43:void onFocus() -> void
    47:48:void setFocus() -> int
    51:51:boolean hasFocus() -> for
    54:58:void open() -> break
    61:64:void close() -> goto
    67:69:void onClose() -> else
    72:82:boolean mouseOver(double,double) -> do
    85:85:boolean mouseOverResize(double,double) -> for
    89:89:boolean removeOnClose() -> int
    98:98:void updateBounds() -> long
    101:101:boolean canResize() -> if
    106:163:void renderFrame(float,double,double) -> for
    165:190:void onDrag(double,double) -> do
    192:205:void onResize(double,double) -> if
    207:231:boolean onMouseClick(int,int) -> do
    234:234:int getWindowPosX() -> do
    237:237:int getWindowPosY() -> if
nidefawl.qubes.gui.windows.GuiWindowManager -> IjJiIjll1LllJiJi:
    nidefawl.qubes.gui.windows.GuiWindowManager singleton -> do
    java.util.Map windowList -> do
    nidefawl.qubes.gui.windows.GuiWindow windowFocus -> for
    nidefawl.qubes.gui.windows.GuiWindow dragged -> do
    nidefawl.qubes.gui.windows.GuiWindow resized -> if
    nidefawl.qubes.gui.Tooltip tooltip -> do
    24:24:nidefawl.qubes.gui.windows.GuiWindowManager getInstance() -> do
    28:57:void setWindowFocus(nidefawl.qubes.gui.windows.GuiWindow) -> do
    60:88:void do_setWindowFocus(nidefawl.qubes.gui.windows.GuiWindow) -> if
    90:95:int getHighestIndex() -> do
    121:139:nidefawl.qubes.gui.windows.GuiWindow openWindow(java.lang.Class,boolean) -> do
    143:143:nidefawl.qubes.gui.windows.GuiWindow openWindow(java.lang.Class) -> do
    147:152:java.lang.Object getWindow(java.lang.Class) -> do
    156:160:boolean anyWindowVisible() -> do
    165:169:nidefawl.qubes.gui.windows.GuiWindow addWindow(nidefawl.qubes.gui.windows.GuiWindow,boolean) -> do
    242:243:void render(float,double,double) -> do
    246:302:void drawWindows(float,double,double) -> if
    304:308:void renderTooltip(float,double,double) -> for
    312:317:void setTooltip(nidefawl.qubes.gui.Tooltip) -> do
    324:324:void initGui(boolean) -> do
    327:330:boolean requiresTextInput() -> if
    334:337:boolean onTextInput(int) -> do
    341:341:nidefawl.qubes.gui.windows.GuiWindow getWindowFocus() -> do
    344:355:boolean onMouseClick(int,int) -> do
    358:372:nidefawl.qubes.gui.windows.GuiWindow getMouseOver(double,double) -> do
    375:383:void mouseMove(double,double) -> do
    386:390:boolean onKeyPress(int,int,int,int) -> do
    394:398:boolean onWheelScroll(double,double) -> do
    401:422:void onWindowClosed(nidefawl.qubes.gui.windows.GuiWindow) -> for
    424:428:void onWindowOpened(nidefawl.qubes.gui.windows.GuiWindow) -> int
    430:435:void update() -> do
nidefawl.qubes.hex.HexCell -> JiiJjIllIjiJ1L:
    int x -> do
    int z -> if
    nidefawl.qubes.hex.HexagonGridStorage grid -> do
    29:33:double getDistanceCenter(double,double) -> do
    37:37:double getCenterX() -> do
    41:41:double getCenterY() -> if
    63:83:int getClosesCorner(double,double) -> do
    90:90:nidefawl.qubes.hex.HexagonGridStorage getGrid() -> do
nidefawl.qubes.hex.HexagonGrid -> L1IjlliJ1L1L1LiJ:
    double radius -> do
    double height -> if
    double width -> for
    double hwidth -> int
    double ttheight -> new
    double[] sinCos -> do
    int[] offset -> do
    41:41:long blockToGrid(int,int) -> do
    45:53:long toHex(double,double) -> do
    57:57:double getCenterX(int,int) -> do
    61:61:double getCenterY(int,int) -> if
    65:65:double getPointX(int,int,int) -> do
    68:68:double getPointY(int,int,int) -> if
    111:111:long offset(int,int,int) -> do
nidefawl.qubes.hex.HexagonGridStorage -> JijIiJL11LiJ1L1L:
    int max -> do
    java.util.HashMap map -> do
    java.util.HashMap oobmap -> if
    39:40:void putPos(long,java.lang.Object) -> do
    43:55:java.lang.Object getPos(long) -> do
    59:61:boolean outOfBounds(long) -> do
    65:66:java.lang.Object blockToHex(int,int) -> do
    java.lang.Object loadCell(int,int) -> if
    java.lang.Object oobCell(int,int) -> for
    75:75:java.util.Collection getLoaded() -> do
    79:79:void flag(int,int) -> do
nidefawl.qubes.input.DigController -> iJJiiJ1L1LjIIjiJ:
    int stage -> do
    boolean digging -> do
    int speed -> if
    int tick -> for
    nidefawl.qubes.vec.BlockPos mouseOver -> do
    nidefawl.qubes.vec.BlockPos lastMouseOver -> if
    nidefawl.qubes.util.RayTrace$RayTraceIntersection intersect -> do
    int transaction -> int
    nidefawl.qubes.gl.TesselatorState fullBlock -> do
    int[] stageTex -> do
    35:43:void onMouseClick(int,boolean) -> do
    64:64:boolean isDigAnimation() -> do
    71:73:void onGrabChange(boolean) -> do
    75:79:void startDigging() -> new
    81:85:void endDigging() -> try
    91:91:void preRenderUpdate() -> do
    94:111:void update() -> if
    114:120:boolean equalMouseOver() -> if
    125:135:void sendDigState(int) -> if
    138:147:void setBlock(nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos) -> do
    156:158:void init() -> for
    164:168:void reloadTextures() -> int
    171:220:void renderBlockOver(nidefawl.qubes.gl.TesselatorState,nidefawl.qubes.vec.AABBFloat) -> do
    238:238:void renderDigging(nidefawl.qubes.world.World,float) -> do
    242:246:float getSwingProgress(float) -> do
    250:256:void handleServerState(int) -> do
nidefawl.qubes.input.GameMode -> jIjIjIIjL1L11L:
    nidefawl.qubes.input.GameMode PLAY -> do
    nidefawl.qubes.input.GameMode BUILD -> if
    nidefawl.qubes.input.GameMode EDIT -> for
    nidefawl.qubes.input.GameMode SELECT -> int
    nidefawl.qubes.input.GameMode[] $VALUES -> do
    6:6:nidefawl.qubes.input.GameMode[] values() -> values
    6:6:nidefawl.qubes.input.GameMode valueOf(java.lang.String) -> valueOf
nidefawl.qubes.input.InputController -> jIL1JiL1iJllJijI:
    nidefawl.qubes.config.AbstractYMLConfig settings -> do
    nidefawl.qubes.input.Keybinding kb_forward -> do
    nidefawl.qubes.input.Keybinding kb_backward -> if
    nidefawl.qubes.input.Keybinding kb_left -> for
    nidefawl.qubes.input.Keybinding kb_right -> int
    nidefawl.qubes.input.Keybinding kb_sneak -> new
    nidefawl.qubes.input.Keybinding kb_jump -> try
    float strafe -> do
    float forward -> if
    boolean grabbed -> do
    int mX -> do
    int mY -> if
    float jump -> for
    float sneak -> int
    java.util.Map keyToKeyBinding -> do
    java.util.ArrayList keybindings -> do
    97:98:void addKeyBinding(nidefawl.qubes.input.Keybinding) -> do
    100:105:void updateKeybindMap() -> do
    108:108:nidefawl.qubes.input.Keybinding getKeyBinding(int) -> do
    112:143:void update(double,double) -> do
    146:146:boolean isKeyDown(int) -> do
    150:159:void setGrabbed(boolean) -> do
    162:162:boolean grabbed() -> do
    166:354:void initKeybinds() -> if
    358:366:void load() -> for
    368:375:void saveBindings() -> int
    377:377:java.util.Collection getBindings() -> do
nidefawl.qubes.input.InputController$1 -> L1JiiJJijIJill:
    41:41:void setDefaults() -> do
    45:48:void save() -> for
    52:61:void load() -> if
nidefawl.qubes.input.InputController$10 -> IjllIjIjllIj1LiJ:
    231:232:void onDown() -> do
nidefawl.qubes.input.InputController$11 -> L11LL1llL11L1LJi:
    nidefawl.qubes.Game val$game -> do
    236:237:void onDown() -> do
nidefawl.qubes.input.InputController$12 -> llIjIjjIjIiJlljI:
    nidefawl.qubes.Game val$game -> do
    245:249:void onDown() -> do
nidefawl.qubes.input.InputController$13 -> iJJiIjL1IjjI1LiJ:
    nidefawl.qubes.Game val$game -> do
    253:260:void onDown() -> do
nidefawl.qubes.input.InputController$14 -> jIjI1L1Lll1LL1ll:
    nidefawl.qubes.Game val$game -> do
    264:265:void onDown() -> do
nidefawl.qubes.input.InputController$15 -> JiL1iJJiJiL1IjJi:
    269:270:void onDown() -> do
nidefawl.qubes.input.InputController$16 -> IjL11LIjJillL1iJ:
    277:281:void onDown() -> do
nidefawl.qubes.input.InputController$17 -> ll1LIjL11LJiiJIj:
    285:288:void onDown() -> do
nidefawl.qubes.input.InputController$18 -> lliJL11LJijIjI1L:
    292:293:void onDown() -> do
nidefawl.qubes.input.InputController$19 -> jIjIiJIjIjJiJiL1:
    nidefawl.qubes.Game val$game -> do
    297:298:void onDown() -> do
nidefawl.qubes.input.InputController$2 -> IjIjL11LjI1L1LjI:
    nidefawl.qubes.Game val$game -> do
    170:172:void onDown() -> do
nidefawl.qubes.input.InputController$20 -> llJijIJijIllll:
    302:303:void onDown() -> do
nidefawl.qubes.input.InputController$21 -> L11LIjllIjIjL1jI:
    307:310:void onDown() -> do
nidefawl.qubes.input.InputController$22 -> jIjIllIjJi1L1LIj:
    315:316:void onDown() -> do
nidefawl.qubes.input.InputController$23 -> IjlllllljIiJL1L1:
    nidefawl.qubes.Game val$game -> do
    320:322:void onDown() -> do
nidefawl.qubes.input.InputController$24 -> llL11LjIIjIjIjIj:
    328:329:void onDown() -> do
nidefawl.qubes.input.InputController$25 -> IjiJjIiJjIiJJi1L:
    335:338:void onDown() -> do
nidefawl.qubes.input.InputController$26 -> L1jIjIL11L1LiJll:
    342:343:void onDown() -> do
nidefawl.qubes.input.InputController$27 -> JijI1LjIlljIJiIj:
    nidefawl.qubes.Game val$game -> do
    347:352:void onDown() -> do
nidefawl.qubes.input.InputController$3 -> L1jIiJIjjIiJllll:
    nidefawl.qubes.Game val$game -> do
    184:192:void onDown() -> do
nidefawl.qubes.input.InputController$4 -> jIIjIjllL11LiJiJ:
    nidefawl.qubes.Game val$game -> do
    196:197:void onDown() -> do
nidefawl.qubes.input.InputController$5 -> JiIjiJIjjIIjIj:
    nidefawl.qubes.Game val$game -> do
    201:202:void onDown() -> do
nidefawl.qubes.input.InputController$6 -> llL1llL1iJ1LllJi:
    nidefawl.qubes.Game val$game -> do
    206:211:void onDown() -> do
nidefawl.qubes.input.InputController$7 -> L11LL1iJIjJiIj1L:
    nidefawl.qubes.Game val$game -> do
    215:216:void onDown() -> do
nidefawl.qubes.input.InputController$8 -> jI1LIj1LL11LiJjI:
    220:221:void onDown() -> do
nidefawl.qubes.input.InputController$9 -> IjjIJiiJL1iJllJi:
    226:227:void onDown() -> do
nidefawl.qubes.input.Keybinding -> jIjIIjL1JiJiJiIj:
    boolean enabled -> do
    int key -> do
    boolean isPressed -> if
    java.lang.String name -> do
    boolean hasCallback -> for
    boolean staticBinding -> int
    26:27:nidefawl.qubes.input.Keybinding setNoCallBack() -> do
    31:32:nidefawl.qubes.input.Keybinding setStatic() -> if
    35:35:boolean isStaticBinding() -> do
    38:38:boolean hasCallback() -> if
    42:42:java.lang.String getName() -> do
    49:49:boolean isEnabled() -> for
    56:56:boolean isPressed() -> int
    63:63:int getKey() -> do
    71:72:void setEnabled(boolean) -> do
    79:80:void setKey(int) -> do
    90:90:void onDown() -> do
    91:91:void onUp() -> if
    97:106:void update(int) -> if
nidefawl.qubes.input.Keyboard -> jIjI1LL1iJIjL11L:
    java.util.HashMap keyNames -> do
    139:139:boolean isKeyDown(int) -> do
    143:143:boolean getState(int) -> if
    147:148:java.lang.String getKeyName(int) -> do
nidefawl.qubes.input.Mouse -> L1jIjIiJJiJi:
    double dy -> do
    double dx -> if
    double x -> for
    double y -> int
    double scrollDX -> new
    double scrollDY -> try
    double lastX -> byte
    double lastY -> case
    java.nio.DoubleBuffer bx -> do
    java.nio.DoubleBuffer by -> if
    boolean isGrabbed -> do
    28:32:void init() -> do
    34:36:double getDX() -> do
    40:42:double getDY() -> if
    46:46:boolean getState(int) -> do
    50:50:double getX() -> for
    54:54:double getY() -> int
    58:59:void setCursorPosition(int,int) -> do
    63:63:boolean isGrabbed() -> do
    67:72:void setGrabbed(boolean) -> do
    75:82:void setLastPos() -> if
    84:84:boolean isButtonDown(int) -> if
    90:96:void update(double,double) -> do
nidefawl.qubes.input.Selection -> IjIjJiJiIjjIlljI:
    nidefawl.qubes.gl.TesselatorState highlightSelection -> do
    nidefawl.qubes.gl.TesselatorState fullBlock -> if
    nidefawl.qubes.gl.TesselatorState customBB -> for
    boolean quarterMode -> do
    boolean mouseDown -> if
    boolean mouseStateChanged -> for
    nidefawl.qubes.gl.TesselatorState renderBB -> int
    nidefawl.qubes.util.RayTrace rayTrace -> do
    nidefawl.qubes.vec.BlockPos[] pos -> do
    boolean updateBB -> int
    nidefawl.qubes.vec.BlockPos mouseOver -> do
    nidefawl.qubes.vec.AABBFloat selBB -> do
    28:28:nidefawl.qubes.input.GameMode getMode() -> do
    42:47:void init() -> do
    54:57:void resetSelection() -> if
    60:60:boolean hasSelection() -> do
    68:102:void renderBlockHighlight(nidefawl.qubes.world.World,float) -> do
    107:116:void renderMouseOver() -> try
    119:240:void renderBlockOver(nidefawl.qubes.gl.TesselatorState,nidefawl.qubes.vec.AABBFloat) -> do
    244:293:void renderBB() -> for
    296:354:void update(nidefawl.qubes.world.World,double,double,double) -> do
    360:397:void setMouseOver(nidefawl.qubes.util.RayTrace$RayTraceIntersection) -> do
    399:406:void set(int,nidefawl.qubes.vec.BlockPos) -> do
    409:447:void clicked(int,boolean) -> do
    450:450:boolean extendReach() -> if
    454:454:nidefawl.qubes.vec.BlockPos getMin() -> do
    458:458:nidefawl.qubes.vec.BlockPos getMax() -> if
    462:464:int getNumBlocks() -> do
    470:515:void onRelease() -> byte
    518:524:void reset() -> int
    529:532:nidefawl.qubes.util.RayTrace$RayTraceIntersection getHit() -> do
    556:557:void toggleQuarterMode() -> new
nidefawl.qubes.inventory.BaseInventory -> jIiJL1jIJiiJiJL1:
    int id -> do
    int inventorySize -> if
    nidefawl.qubes.item.BaseStack[] stacks -> do
    byte[] flagged -> do
    boolean dirty -> do
    33:33:boolean isDirty() -> do
    37:37:nidefawl.qubes.item.BaseStack getItem(int) -> do
    41:45:nidefawl.qubes.item.BaseStack setItem(int,nidefawl.qubes.item.BaseStack) -> do
    49:49:int getId() -> do
    53:53:int getSize() -> if
    57:64:java.util.List copySlotStacks() -> do
    68:74:void addStack(nidefawl.qubes.item.BaseStack) -> do
    77:78:void setIncr(java.util.Collection) -> do
    80:81:void set(java.util.Collection) -> if
    84:97:void _set(java.util.Collection,boolean) -> do
    100:110:java.util.HashSet getUpdate() -> do
nidefawl.qubes.inventory.InventoryUtil -> L1L1L11LjIJi1L:
    27:36:nidefawl.qubes.nbt.Tag writeToTag(java.util.List) -> do
    45:60:java.util.List readFromTag(nidefawl.qubes.nbt.Tag) -> do
    64:71:int count(nidefawl.qubes.inventory.BaseInventory,nidefawl.qubes.item.BaseStack) -> do
nidefawl.qubes.inventory.PlayerInventory -> jIJiiJ1LjIiJ1LL1:
    nidefawl.qubes.item.BaseStack carried -> do
    33:38:java.util.List copySlotStacks() -> do
    41:52:void set(java.util.List) -> do
    57:59:nidefawl.qubes.item.BaseStack setCarried(nidefawl.qubes.item.BaseStack) -> do
    63:63:nidefawl.qubes.item.BaseStack getCarried() -> do
nidefawl.qubes.inventory.PlayerInventoryCrafting -> L1L1jIIj1LjIll:
    int inputSlots -> for
    int outputSlots -> int
nidefawl.qubes.inventory.slots.Slot -> IjL1IjiJ1LllL1ll:
    int idx -> do
    float x -> do
    float y -> if
    float w -> for
    nidefawl.qubes.inventory.slots.Slots slots -> do
    nidefawl.qubes.item.BaseStack getItem() -> do
    30:30:boolean isAt(double,double) -> do
    boolean transferTo(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    boolean isEmpty() -> do
    nidefawl.qubes.item.BaseStack drain() -> if
    nidefawl.qubes.item.BaseStack put(nidefawl.qubes.inventory.slots.SlotInventory) -> do
    nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    boolean canTake() -> if
    boolean canPut(nidefawl.qubes.item.BaseStack) -> do
nidefawl.qubes.inventory.slots.SlotInventory -> lljIL1llIjL1JiIj:
    nidefawl.qubes.inventory.BaseInventory inv -> do
    24:24:nidefawl.qubes.item.BaseStack getItem() -> do
    29:36:boolean transferTo(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    41:41:boolean isEmpty() -> do
    46:46:nidefawl.qubes.item.BaseStack drain() -> if
    51:51:nidefawl.qubes.item.BaseStack put(nidefawl.qubes.inventory.slots.SlotInventory) -> do
    56:59:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    64:64:boolean canTake() -> if
    69:69:boolean canPut(nidefawl.qubes.item.BaseStack) -> do
nidefawl.qubes.inventory.slots.SlotPreview -> IjjIL11LllL1jI1L:
    nidefawl.qubes.item.BaseStack stack -> do
    16:16:nidefawl.qubes.item.BaseStack getItem() -> do
    21:21:boolean transferTo(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    26:26:boolean isEmpty() -> do
    31:31:nidefawl.qubes.item.BaseStack drain() -> if
    36:36:nidefawl.qubes.item.BaseStack put(nidefawl.qubes.inventory.slots.SlotInventory) -> do
    41:41:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    46:46:boolean canTake() -> if
    51:51:boolean canPut(nidefawl.qubes.item.BaseStack) -> do
nidefawl.qubes.inventory.slots.SlotStack -> JiL11LJi1LL1JijI:
    int slot -> do
    nidefawl.qubes.item.BaseStack stack -> do
    23:25:void read(java.io.DataInput) -> do
    28:30:void write(java.io.DataOutput) -> do
nidefawl.qubes.inventory.slots.SlotStock -> llL1jI1LL1Jillll:
    nidefawl.qubes.item.BaseStack stack -> do
    nidefawl.qubes.inventory.PlayerInventory inv -> do
    nidefawl.qubes.item.BaseStack stackReq -> if
    23:23:nidefawl.qubes.item.BaseStack getItem() -> do
    28:28:boolean transferTo(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    33:33:boolean isEmpty() -> do
    38:38:nidefawl.qubes.item.BaseStack drain() -> if
    43:43:nidefawl.qubes.item.BaseStack put(nidefawl.qubes.inventory.slots.SlotInventory) -> do
    48:48:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    53:53:boolean canTake() -> if
    58:58:boolean canPut(nidefawl.qubes.item.BaseStack) -> do
    62:66:void update() -> do
nidefawl.qubes.inventory.slots.Slots -> ll1LjIiJiJJijIL1:
    java.util.List slots -> do
    int id -> do
    18:18:int getId() -> do
    21:22:void addSlot(nidefawl.qubes.inventory.slots.Slot) -> do
    30:35:nidefawl.qubes.inventory.slots.Slot getSlotAt(double,double) -> do
    42:42:java.util.List getSlots() -> do
    nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
    54:54:nidefawl.qubes.inventory.slots.Slot getSlot(int) -> do
    58:58:boolean canModify() -> do
nidefawl.qubes.inventory.slots.SlotsCrafting -> Ij1LjIiJjIlliJ1L:
    nidefawl.qubes.inventory.PlayerInventoryCrafting inv -> do
    nidefawl.qubes.inventory.slots.SlotInventory result -> do
    boolean locked -> do
    25:25:nidefawl.qubes.inventory.slots.SlotInventory getResult() -> do
    33:33:int getInputSize() -> if
    37:38:void unlock() -> do
    41:42:void lock() -> if
    45:45:boolean canModify() -> do
nidefawl.qubes.inventory.slots.SlotsInventory -> iJ1LIjIjL11LIjL1:
    nidefawl.qubes.inventory.PlayerInventory inv -> if
    31:31:boolean canModify() -> do
nidefawl.qubes.inventory.slots.SlotsInventoryBase -> L1L1JijIjIjIjIJi:
    nidefawl.qubes.inventory.BaseInventory baseInv -> do
    nidefawl.qubes.inventory.PlayerInventory playerInv -> do
    21:31:nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
    42:49:nidefawl.qubes.inventory.slots.Slot getFirstEmpty(nidefawl.qubes.item.BaseStack) -> do
    53:62:nidefawl.qubes.item.BaseStack addStack(nidefawl.qubes.item.BaseStack) -> do
nidefawl.qubes.item.BaseStack -> jIllllL1jI1LjIjI:
    int id -> do
    int data -> if
    int size -> for
    nidefawl.qubes.item.ItemStack tmpStackItem -> do
    nidefawl.qubes.item.BlockStack tmpStackBlock -> do
    boolean isItem() -> do
    23:23:boolean isBlock() -> if
    nidefawl.qubes.item.BaseStack copy() -> do
    nidefawl.qubes.nbt.Tag save() -> do
    boolean isEqualId(nidefawl.qubes.item.BaseStack) -> do
    33:43:nidefawl.qubes.item.BaseStack load(nidefawl.qubes.nbt.Tag) -> do
    46:50:boolean equalStacks(nidefawl.qubes.item.BaseStack,nidefawl.qubes.item.BaseStack) -> do
    nidefawl.qubes.item.Item getItem() -> do
    nidefawl.qubes.block.Block getBlock() -> do
    61:61:java.lang.String getName() -> do
    68:76:nidefawl.qubes.item.BaseStack getTemp(java.lang.Object) -> do
    79:80:void setSize(int) -> do
    82:82:int getSize() -> do
nidefawl.qubes.item.BlockStack -> JilljIIjiJL11L1L:
    nidefawl.qubes.item.StackData stackdata -> do
    29:30:void setStackdata(nidefawl.qubes.item.StackData) -> do
    35:35:nidefawl.qubes.item.StackData getStackdata() -> do
    82:96:nidefawl.qubes.nbt.Tag save() -> do
    99:102:nidefawl.qubes.item.BlockStack copy() -> do
    105:105:nidefawl.qubes.block.Block getBlock() -> do
    109:118:void read(java.io.DataInput) -> do
    121:130:void write(java.io.DataOutput) -> do
    133:136:boolean isEqualId(nidefawl.qubes.item.BaseStack) -> do
    147:147:boolean isItem() -> do
    151:151:nidefawl.qubes.item.Item getItem() -> do
    21:21:nidefawl.qubes.item.BaseStack copy() -> do
nidefawl.qubes.item.IDMappingItems -> IjlliJjIJiL11LjI:
    boolean CHANGED -> do
    boolean LOADED -> if
    int HIGHEST_ITEM_ID -> do
    com.google.common.collect.ImmutableBiMap map -> do
    java.lang.Object sync -> do
    30:65:void load() -> do
    67:108:void save() -> if
    110:139:int get(java.lang.String) -> do
nidefawl.qubes.item.Item -> iJiJIjiJIjjIJijI:
    nidefawl.qubes.item.Item[] registereditems -> if
    short[] registereditemIds -> do
    nidefawl.qubes.item.Item[] item -> do
    nidefawl.qubes.item.Item pickaxe -> do
    nidefawl.qubes.item.Item axe -> if
    nidefawl.qubes.item.ItemGroupLog log -> do
    nidefawl.qubes.item.ItemGroupPlank plank -> do
    int id -> do
    java.lang.String name -> do
    boolean transparent -> do
    java.lang.String[] textures -> do
    nidefawl.qubes.vec.AABBFloat blockBounds -> do
    nidefawl.qubes.models.ItemModel itemModel -> do
    nidefawl.qubes.item.ItemGroup itemGroup -> do
    59:60:void setItemGroup(nidefawl.qubes.item.ItemGroup) -> do
    74:74:void init() -> do
    78:79:nidefawl.qubes.item.Item setModel(nidefawl.qubes.models.ItemModel) -> do
    83:83:java.lang.String[] getTextures() -> do
    87:91:nidefawl.qubes.item.Item setTextures(java.lang.String[]) -> do
    100:100:java.lang.String getName() -> do
    107:129:void preInit() -> if
    132:132:void postInit() -> for
    144:144:nidefawl.qubes.item.Item get(int) -> do
    151:151:int getTexture(nidefawl.qubes.item.ItemStack) -> do
    158:158:nidefawl.qubes.models.ItemModel getItemModel() -> do
    162:172:boolean canMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.block.Block,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
nidefawl.qubes.item.ItemGroup -> iJIjIjJiiJL1jIll:
    int NEXT_GROUP_ID -> do
    int id -> if
    java.util.List items -> do
    19:21:void addItem(nidefawl.qubes.item.Item) -> do
    26:26:java.util.List getItems() -> do
    29:29:nidefawl.qubes.item.Item getItem(int) -> do
nidefawl.qubes.item.ItemGroupLog -> JiIjjIjIJiL1Ijll:
nidefawl.qubes.item.ItemGroupPlank -> Ij1LiJIjiJL1iJJi:
nidefawl.qubes.item.ItemLog -> iJjIJi1LJiJiiJll:
    int index -> if
nidefawl.qubes.item.ItemRenderer -> L1llJi1LiJlliJjI:
    nidefawl.qubes.font.FontRenderer font -> do
    33:34:void init() -> do
    37:59:void drawItem(nidefawl.qubes.item.BaseStack,float,float,float,float) -> do
    69:79:void drawItemOverlay(nidefawl.qubes.item.BaseStack,float,float,float,float) -> if
nidefawl.qubes.item.ItemStack -> L1L1jIjIjIL1IjJi:
    40:43:void read(java.io.DataInput) -> do
    47:50:void write(java.io.DataOutput) -> do
    54:54:boolean isItem() -> do
    61:61:int getItemTexture() -> if
    68:68:nidefawl.qubes.item.Item getItem() -> do
    73:77:nidefawl.qubes.item.BaseStack copy() -> do
    82:87:nidefawl.qubes.nbt.Tag save() -> do
    92:95:boolean isEqualId(nidefawl.qubes.item.BaseStack) -> do
    105:105:nidefawl.qubes.block.Block getBlock() -> do
nidefawl.qubes.item.StackData -> llll1LJiL11LJiiJ:
    nidefawl.qubes.chunk.blockdata.BlockData data -> do
    27:28:void setBlockData(nidefawl.qubes.chunk.blockdata.BlockData) -> do
    30:30:nidefawl.qubes.chunk.blockdata.BlockData getBlockData() -> do
    35:48:void read(java.io.DataInput) -> do
    52:63:void write(java.io.DataOutput) -> do
    66:66:nidefawl.qubes.item.StackData copy() -> do
nidefawl.qubes.lighting.DynamicLight -> L1iJL1IjjIllL1Ij:
    nidefawl.qubes.vec.Vector3f pos -> do
    nidefawl.qubes.vec.Vector3f lastPos -> if
    nidefawl.qubes.vec.Vector3f mot -> for
    nidefawl.qubes.vec.Vector3f lastMot -> int
    nidefawl.qubes.vec.Vector3f renderPos -> new
    nidefawl.qubes.vec.Vector3f color -> try
    float intensity -> do
    float quadratic -> if
    float lightThreshold -> for
    float radius -> int
    int ticks -> do
    30:32:void setPos(nidefawl.qubes.vec.Vector3f) -> do
    34:39:void tickUpdate(nidefawl.qubes.world.WorldClient) -> do
    42:56:void updatePreRender(nidefawl.qubes.world.WorldClient,float) -> do
    59:67:void store(java.nio.FloatBuffer) -> do
nidefawl.qubes.logging.ErrorHandler -> IjJiJiIjIjL1jIIj:
    nidefawl.qubes.logging.IErrorHandler handler -> do
    8:11:void setException(nidefawl.qubes.util.GameError) -> do
    13:14:void setHandler(nidefawl.qubes.logging.IErrorHandler) -> do
nidefawl.qubes.logging.IErrorHandler -> JiJijI1LL1jIIj1L:
    void setException(nidefawl.qubes.util.GameError) -> do
nidefawl.qubes.logging.LogBufferStream -> L1Ji1Lllll1LL1iJ:
    java.io.ByteArrayOutputStream baos -> do
    java.io.PrintStream ps -> do
    17:21:void write(byte[],int,int) -> write
    25:26:void write(byte[]) -> write
    30:36:void flush() -> flush
    40:46:void close() -> close
    50:52:void write(int) -> write
    56:60:java.lang.String getLogString() -> do
nidefawl.qubes.meshing.BlockFace -> L1IjjIIjL1JijIjI:
    nidefawl.qubes.meshing.BlockSurface bs -> do
    float[] v0 -> do
    float[] v1 -> if
    float[] v2 -> for
    float[] v3 -> int
    int[] du -> do
    int[] dv -> if
    byte[] normal -> do
    int faceDir -> do
    int[] pos -> for
    int w -> if
    int h -> for
    int[][] faceVDirections -> do
    int[][] faceVDirectionsNeg -> if
    27:30:int encNormal(int,int,int) -> do
    34:41:int encNegNormal(int,int,int) -> if
    47:123:void initDir() -> do
    241:247:int drawBasic(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> do
    259:275:int drawShadowTextured(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> if
    279:348:int draw(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> for
    352:387:void setUV(nidefawl.qubes.meshing.BlockFaceVert,int) -> do
nidefawl.qubes.meshing.BlockFaceAttr -> IjJiIjiJIjllJijI:
    java.lang.String[] attributes -> do
    nidefawl.qubes.meshing.BlockFaceVert v0 -> do
    nidefawl.qubes.meshing.BlockFaceVert v1 -> if
    nidefawl.qubes.meshing.BlockFaceVert v2 -> for
    nidefawl.qubes.meshing.BlockFaceVert v3 -> int
    nidefawl.qubes.meshing.BlockFaceVert[] v -> do
    boolean useGlobalRenderOffset -> do
    int tex -> do
    float xOff -> do
    float yOff -> if
    float zOff -> for
    int aoMask -> if
    int lightMaskSky -> for
    int lightMaskBlock -> int
    int type -> new
    boolean reverse -> if
    int faceDir -> try
    int normalMap -> byte
    53:54:void setUseGlobalRenderOffset(boolean) -> do
    57:58:void setTex(int) -> do
    61:62:void setNormalMap(int) -> if
    65:72:void setOffset(float,float,float) -> do
    75:82:void setNormal(int,int,int) -> do
    85:87:void setLight(int,int) -> do
    92:129:void rotateUV(int) -> for
    132:146:void putSingleVert(int,nidefawl.qubes.gl.VertexBuffer) -> do
    148:155:void putShadowTexturedSingleVert(int,nidefawl.qubes.gl.VertexBuffer) -> if
    158:163:void putBasicSingleVert(int,nidefawl.qubes.gl.VertexBuffer) -> for
    228:255:void put(nidefawl.qubes.gl.VertexBuffer) -> do
    258:275:void putBasic(nidefawl.qubes.gl.VertexBuffer) -> if
    279:298:void putShadowTextured(nidefawl.qubes.gl.VertexBuffer) -> for
    301:302:void setAO(int) -> int
    305:309:void setType(int) -> new
    311:314:void setPass(int) -> try
    316:319:void flipNormal() -> do
    325:326:void setReverse(boolean) -> if
    332:333:void setFaceDir(int) -> byte
    338:338:int getFaceDir() -> do
    345:360:void calcNormal(nidefawl.qubes.vec.Vector3f) -> do
    397:400:int packNormal(nidefawl.qubes.vec.Vector3f) -> do
    404:404:boolean getReverse() -> do
    409:426:void maskLight(int,int,int,int,int) -> do
    429:429:int maskAO(int,int,int,int) -> do
    434:438:int mix_light(int,int,int,int) -> if
nidefawl.qubes.meshing.BlockFaceVert -> lliJIjll1LIjJiJi:
    int rgba -> do
    float u -> do
    float v -> if
    float x -> for
    float y -> int
    float z -> new
    int dirOffset -> if
    int normal -> for
    int direction -> int
    int pass -> new
    20:26:void setColorRGBAF(float,float,float,float) -> do
    29:31:void setColorRGBA(int,float) -> do
    34:35:void setColorRGB(int) -> do
    38:40:void setUV(float,float) -> do
    43:46:void setPos(float,float,float) -> do
    49:50:void setFaceVertDir(int) -> if
    52:56:void setDirection(int,int,boolean) -> do
    58:59:void setNoDirection() -> do
    63:75:void setNormal(float,float,float) -> if
    81:82:void setPass(int) -> for
    88:92:void flipNormal() -> if
nidefawl.qubes.meshing.BlockRenderer -> iJllL1IjIjllllll:
    int[][] offsets -> do
    nidefawl.qubes.meshing.BlockSurface bs -> do
    nidefawl.qubes.vec.AABBFloat bb -> do
    int shadowDrawMode -> do
    boolean extendFaces -> do
    nidefawl.qubes.world.IBlockWorld w -> do
    nidefawl.qubes.meshing.BlockFaceAttr attr -> do
    nidefawl.qubes.gl.VertexBuffer[] vbuffer -> do
    boolean[] wallDir -> do
    boolean[] fenceDir -> if
    int[] paneDir -> do
    int[] quarters -> if
    int[] quarters2 -> for
    nidefawl.qubes.vec.AABBFloat[] boxes -> do
    nidefawl.qubes.meshing.BlockSurface[] qSurfacesS -> do
    nidefawl.qubes.meshing.BlockSurface[] qSurfaces -> if
    nidefawl.qubes.vec.Vector3f plantNormal -> do
    81:82:void setDefaultBounds() -> do
    89:92:void preRender(nidefawl.qubes.world.World,nidefawl.qubes.meshing.ChunkRenderCache,nidefawl.qubes.meshing.BlockFaceAttr) -> do
    98:100:void setBuffers(nidefawl.qubes.gl.VertexBuffer[],int) -> do
    108:179:int render(int,int,int) -> do
    192:206:int renderWaterLily(nidefawl.qubes.block.Block,int,int,int,int) -> new
    210:210:int setPaneConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    213:339:int renderPane(nidefawl.qubes.block.Block,int,int,int,int) -> try
    343:454:int renderTorch(nidefawl.qubes.block.Block,int,int,int) -> do
    458:458:int setWallConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> do
    461:537:int renderWall(nidefawl.qubes.block.Block,int,int,int,int) -> do
    540:540:int setFenceConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> if
    551:605:int renderFence(nidefawl.qubes.block.Block,int,int,int,int) -> if
    617:679:int renderVines(nidefawl.qubes.block.Block,int,int,int,int) -> for
    683:692:void renderXNeg(nidefawl.qubes.block.Block,float,float,float) -> do
    695:704:void renderXPos(nidefawl.qubes.block.Block,float,float,float) -> if
    706:715:void renderZNeg(nidefawl.qubes.block.Block,float,float,float) -> for
    717:726:void renderZPos(nidefawl.qubes.block.Block,float,float,float) -> int
    728:739:void renderYPos(nidefawl.qubes.block.Block,float,float,float) -> new
    743:752:void renderYNeg(nidefawl.qubes.block.Block,float,float,float) -> try
    755:776:int renderFace(nidefawl.qubes.block.Block,int,float,float,float,int) -> do
    786:794:void putSingleVert(nidefawl.qubes.block.Block,int,int) -> do
    797:801:void incVertCount(nidefawl.qubes.block.Block,int,int) -> if
    804:808:void putTriIndex(nidefawl.qubes.block.Block,int,int[]) -> do
    810:818:void putBuffer(nidefawl.qubes.block.Block,int) -> do
    821:904:int renderSlicedFaces(nidefawl.qubes.block.BlockSliced,int,int,int) -> do
    907:948:int renderPlantFlat(nidefawl.qubes.block.Block,int,int,int,int) -> byte
    952:956:int renderBlock(nidefawl.qubes.block.Block,int,int,int,int,int) -> do
    959:1035:int renderBlockModel(nidefawl.qubes.block.Block,int,int,int,int,int) -> if
    1057:1068:void flipFace() -> if
    1072:1095:void setFaceColorTexture(nidefawl.qubes.block.Block,int,int,int,int,nidefawl.qubes.meshing.BlockSurface,int,int) -> do
    1097:1099:void setFaceColor(nidefawl.qubes.block.Block,int,int,int,int,nidefawl.qubes.meshing.BlockSurface,int) -> do
    1108:1112:void setBlockBounds(nidefawl.qubes.block.Block,int,int,int) -> do
    1115:1121:int getAndRenderBlockFace(nidefawl.qubes.block.Block,int,int,int,int,int,int,int) -> do
    1126:1155:nidefawl.qubes.meshing.BlockSurface getSingleBlockSurface(nidefawl.qubes.block.Block,int,int,int,int,int,boolean,nidefawl.qubes.meshing.BlockSurface,int) -> do
    1167:1167:int renderDoublePlant(nidefawl.qubes.block.Block,int,int,int,int) -> case
    1172:1390:int renderPlant(nidefawl.qubes.block.Block,int,int,int,int) -> int
nidefawl.qubes.meshing.BlockSurface -> L1L1jIjIllL1Ijll:
    boolean transparent -> do
    int type -> do
    int face -> if
    int axis -> for
    int x -> int
    int y -> new
    int z -> try
    int pass -> byte
    boolean extraFace -> if
    boolean resolved -> for
    boolean calcLight -> int
    int maskedLightSky -> case
    int maskedLightBlock -> char
    int maskedAO -> else
    boolean isAirAbove -> new
    int texture -> goto
    boolean renderTypeTransition -> try
    int faceColor -> long
    int[][] offset -> do
    31:31:int maskAO(int,int,int,int) -> do
    35:39:int mix_light(int,int,int,int) -> if
    42:61:void maskLight(int,int,int,int,nidefawl.qubes.block.Block) -> do
    87:108:void calcAO(nidefawl.qubes.world.IBlockWorld) -> do
    111:118:int vertexAO(boolean,boolean,boolean) -> do
    130:137:boolean isOccludingAt(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    141:191:void calcPosZ(nidefawl.qubes.world.IBlockWorld) -> if
    194:245:void calcNegZ(nidefawl.qubes.world.IBlockWorld) -> for
    248:297:void calcPosX(nidefawl.qubes.world.IBlockWorld) -> int
    299:348:void calcNegX(nidefawl.qubes.world.IBlockWorld) -> new
    351:402:void calcPosY(nidefawl.qubes.world.IBlockWorld) -> try
    404:454:void calcNegY(nidefawl.qubes.world.IBlockWorld) -> byte
    458:489:boolean mergeWith(nidefawl.qubes.meshing.ChunkRenderCache,nidefawl.qubes.meshing.BlockSurface) -> do
    493:517:void resolve(nidefawl.qubes.meshing.ChunkRenderCache) -> do
    520:537:void reset() -> do
    539:558:nidefawl.qubes.meshing.BlockSurface copy() -> do
nidefawl.qubes.meshing.BlockSurfaceAir -> JiiJjIlliJL1Ij1L:
    11:11:nidefawl.qubes.meshing.BlockSurface copy() -> do
nidefawl.qubes.meshing.BlockSurfaceHidden -> llL1JijIJiL1iJjI:
    17:17:nidefawl.qubes.meshing.BlockSurface copy() -> do
nidefawl.qubes.meshing.ChunkRenderCache -> lljIIjjIL1iJjIL1:
    nidefawl.qubes.chunk.Chunk[] chunks -> do
    nidefawl.qubes.world.WorldClient world -> do
    int baseX -> do
    int baseZ -> if
    32:33:void set(int,int,nidefawl.qubes.chunk.Chunk) -> do
    36:36:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    40:41:void flush() -> do
    44:48:int getData(int,int,int) -> do
    53:57:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    63:67:int getType(int,int,int) -> if
    72:76:int getWater(int,int,int) -> for
    81:85:int getLight(int,int,int) -> int
    95:133:boolean cache(nidefawl.qubes.world.WorldClient,nidefawl.qubes.render.region.MeshedRegion,int,int) -> do
    137:137:nidefawl.qubes.chunk.Chunk getWest() -> do
    140:140:nidefawl.qubes.chunk.Chunk getEast() -> if
    143:143:nidefawl.qubes.chunk.Chunk getNorth() -> for
    146:146:nidefawl.qubes.chunk.Chunk getSouth() -> int
    166:169:boolean isNormalBlock(int,int,int,int) -> do
    174:174:boolean setTypeData(int,int,int,int,int,int) -> do
    183:183:int getBiomeFaceColor(int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
nidefawl.qubes.meshing.MeshThread -> jIJiIj1L1LiJllll:
    long sleepTime -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    java.util.LinkedList results -> do
    java.util.LinkedList finish -> if
    boolean hasResults -> do
    boolean isRunning -> if
    nidefawl.qubes.meshing.MeshUpdateTask[] tasks -> do
    int tasksRunning -> do
    int id -> if
    37:38:void init() -> do
    42:65:void run() -> run
    68:72:void onInterruption() -> int
    77:94:nidefawl.qubes.render.region.MeshedRegion finishTask() -> do
    99:108:boolean offer(nidefawl.qubes.world.WorldClient,nidefawl.qubes.render.region.MeshedRegion,int,int) -> do
    112:112:boolean busy() -> do
    116:116:boolean hasTasks() -> if
    120:125:nidefawl.qubes.meshing.MeshUpdateTask getNextTask() -> do
    131:132:void flush() -> if
    135:138:void stopThread() -> for
    140:140:boolean isRunning() -> for
nidefawl.qubes.meshing.MeshUpdateTask -> iJjIjI1LL1iJIjJi:
    nidefawl.qubes.meshing.Mesher mesher -> do
    nidefawl.qubes.meshing.BlockRenderer blockRenderer -> do
    nidefawl.qubes.meshing.ChunkRenderCache ccache -> do
    nidefawl.qubes.meshing.BlockFaceAttr attr -> do
    int worldInstance -> do
    boolean meshed -> do
    nidefawl.qubes.render.region.MeshedRegion mr -> do
    nidefawl.qubes.gl.VertexBuffer[] vbuffer -> do
    int shadowDrawMode -> if
    46:54:boolean prepare(nidefawl.qubes.world.WorldClient,nidefawl.qubes.render.region.MeshedRegion,int,int) -> do
    58:100:boolean finish(int) -> do
    104:104:boolean isValid(int) -> if
    108:169:boolean updateFromThread() -> do
    174:174:nidefawl.qubes.render.region.MeshedRegion getRegion() -> do
nidefawl.qubes.meshing.Mesher -> IjllIjllllIjIjIj:
    int[] dims -> do
    nidefawl.qubes.meshing.BlockSurface[] mask2 -> do
    nidefawl.qubes.meshing.BlockSurfaceAir air -> do
    nidefawl.qubes.meshing.BlockSurfaceHidden hidden -> do
    short[] renderTypeBlocks -> do
    int nextBlockIDX -> for
    nidefawl.qubes.meshing.BlockSurface[] scratchPad -> if
    int scratchpadidx -> do
    java.util.List[] meshes -> do
    nidefawl.qubes.meshing.BlockSurface bs1 -> do
    nidefawl.qubes.meshing.BlockSurface bs2 -> if
    nidefawl.qubes.vec.AABBFloat fullBB -> do
    nidefawl.qubes.meshing.BlockSurface[] extraWaterFaces -> for
    int extraIdx -> int
    nidefawl.qubes.meshing.ChunkRenderCache cache -> do
    int strategy -> new
    int yPos -> try
    int ySlice -> byte
    int avgUsage -> if
    45:55:int computeHeight(int,int,int,int,int,int,nidefawl.qubes.meshing.BlockSurface) -> do
    65:172:void setMask2(int,int[],int[],int) -> do
    181:202:void mesh(nidefawl.qubes.meshing.ChunkRenderCache,int) -> do
    205:309:void meshRound(nidefawl.qubes.meshing.ChunkRenderCache) -> do
    314:386:nidefawl.qubes.meshing.BlockSurface getBlockSurface(int,int,int,int,int) -> do
    391:393:nidefawl.qubes.meshing.BlockSurface next() -> do
    399:399:java.util.List getMeshes(int) -> do
    408:408:int getRenderType1Blocks() -> do
    418:418:short getBlockPos(int) -> do
nidefawl.qubes.models.BlockModelManager -> iJjIJiL1iJllIjIj:
    nidefawl.qubes.models.BlockModelManager instance -> do
    java.util.HashMap models -> do
    java.util.HashMap textures -> if
    21:21:nidefawl.qubes.models.BlockModelManager getInstance() -> do
    29:29:void init() -> do
    34:88:void reload() -> if
nidefawl.qubes.models.ItemModel -> Ji1LllIjjIiJjI:
    int HIGHEST_MODEL_ID -> do
    nidefawl.qubes.models.ItemModel[] registeredmodels -> if
    short[] registeredmodelIds -> do
    nidefawl.qubes.models.ItemModel[] model -> do
    nidefawl.qubes.models.ItemModel modelPickaxe -> do
    nidefawl.qubes.models.ItemModel modelAxe -> if
    int id -> if
    java.lang.String[] models -> do
    java.lang.String[] textures -> if
    nidefawl.qubes.models.qmodel.ModelQModel[] loadedModels -> do
    java.lang.String name -> do
    33:54:void preInit() -> do
    57:57:void postInit() -> if
    75:76:nidefawl.qubes.models.ItemModel setModels(java.lang.String[]) -> do
    80:80:java.lang.String[] getModels() -> do
nidefawl.qubes.models.ItemModelManager -> llL1iJiJlljIL1:
    nidefawl.qubes.models.ItemModelManager instance -> do
    java.util.HashMap models -> do
    23:23:nidefawl.qubes.models.ItemModelManager getInstance() -> do
    30:30:void init() -> do
    35:77:void reload() -> if
nidefawl.qubes.models.qmodel.KeyFrame -> L1JiJi1LIjllL1Ji:
    float time -> do
    int idx -> do
    nidefawl.qubes.models.qmodel.KeyFrame next -> do
    26:26:int getIdx() -> do
    32:32:nidefawl.qubes.models.qmodel.KeyFrame getNext() -> do
nidefawl.qubes.models.qmodel.ModelBlock -> llIjllIj1LiJiJll:
    nidefawl.qubes.models.qmodel.QModelTriGroup[] groups -> do
    nidefawl.qubes.vec.Vector3f tmpVec -> do
    54:105:void render(float) -> do
nidefawl.qubes.models.qmodel.ModelLoaderQModel -> L1jIllJiiJiJllll:
    int offset -> do
    nidefawl.qubes.assets.AssetBinary asset -> do
    java.util.List listVertex -> do
    java.util.List listTri -> if
    java.util.List listGroups -> for
    java.util.List listMaterials -> int
    java.util.List listTextures -> new
    java.util.List listBones -> try
    java.util.List listActions -> byte
    java.util.Map mapGroups -> do
    java.util.Map mapMaterials -> if
    java.lang.String path -> do
    nidefawl.qubes.models.qmodel.QModelType modelType -> do
    47:53:byte[] readBytes(int) -> do
    65:66:float readFloat() -> do
    70:70:nidefawl.qubes.vec.Vector3f readVec3() -> do
    78:78:nidefawl.qubes.vec.Vector4f readVec4() -> do
    82:89:int readInt() -> do
    92:97:int readUShort() -> if
    100:103:int readUByte() -> for
    112:115:java.lang.String readString(int) -> do
    119:121:void loadModel(java.lang.String) -> do
    124:237:void loadModel(nidefawl.qubes.assets.AssetBinary) -> do
    246:252:nidefawl.qubes.models.qmodel.QModelBone findJoint(java.lang.String) -> do
    272:273:void resetOffset() -> do
    275:275:nidefawl.qubes.models.qmodel.ModelBlock buildBlockModel() -> do
    279:284:nidefawl.qubes.models.qmodel.ModelQModel buildModel() -> do
    293:293:nidefawl.qubes.models.qmodel.QModelVertex getVertex(int) -> do
    297:297:java.lang.String getModelName() -> do
    301:301:nidefawl.qubes.models.qmodel.QModelTriGroup getGroup(java.lang.String) -> do
nidefawl.qubes.models.qmodel.ModelLoaderQModel$1 -> iJllL1JiiJIjJill:
    int[] $SwitchMap$nidefawl$qubes$models$qmodel$QModelType -> do
nidefawl.qubes.models.qmodel.ModelQModel -> llIjL1iJjIjIJill:
    nidefawl.qubes.models.qmodel.ModelLoaderQModel loader -> do
    nidefawl.qubes.gl.VertexBuffer buf -> do
    nidefawl.qubes.gl.GLTriBuffer gpuBuf -> do
    boolean needsDraw -> do
    long reRender -> do
    36:47:void release() -> do
    56:56:void animate(int,float) -> do
    64:64:void setHeadOrientation(float,float) -> do
    void render(float) -> do
    74:84:void bindTextures() -> if
nidefawl.qubes.models.qmodel.ModelRigged -> JiL1L11LL11LIj1L:
    nidefawl.qubes.models.qmodel.QModelPoseBone rootJoint -> do
    java.util.ArrayList poseBones -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone head -> if
    nidefawl.qubes.models.qmodel.QModelPoseBone neck -> for
    nidefawl.qubes.models.qmodel.QModelAction action -> do
    int numIdx -> do
    int[] vPos -> do
    nidefawl.qubes.vec.Quaternion q -> do
    nidefawl.qubes.vec.Matrix4f tmpMat1 -> do
    nidefawl.qubes.vec.Matrix4f tmpMat2 -> if
    nidefawl.qubes.vec.Vector3f tmpVec -> do
    58:63:void setAction(int) -> do
    70:74:nidefawl.qubes.models.qmodel.QModelPoseBone getPoseBone(nidefawl.qubes.models.qmodel.QModelBone) -> do
    85:123:void animate(int,float) -> do
    131:140:nidefawl.qubes.vec.Matrix4f buildFinalPose(nidefawl.qubes.models.qmodel.QModelVertex) -> do
    160:220:void render(float) -> do
    228:313:void setHeadOrientation(float,float) -> do
nidefawl.qubes.models.qmodel.ModelStatic -> JiIjjI1LJijIjIjI:
    nidefawl.qubes.vec.Vector3f tmpVec -> do
    27:73:void render(float) -> do
nidefawl.qubes.models.qmodel.QBoneAnimation -> IjllJiL1JijI1LL1:
    nidefawl.qubes.models.qmodel.KeyFrame[] frames -> do
    float animLength -> do
    27:44:nidefawl.qubes.models.qmodel.KeyFrame getFrameAt(int,float) -> do
    50:59:void addFrame(nidefawl.qubes.models.qmodel.KeyFrame) -> do
nidefawl.qubes.models.qmodel.QModelAction -> jIL1Ijll1LiJJiIj:
    int idx -> do
    int flags -> if
    java.lang.String name -> do
    float fps -> do
    int startFrame -> for
    int endFrame -> int
    java.util.Map map -> do
nidefawl.qubes.models.qmodel.QModelBone -> iJIjjIjI1LL1IjL1:
    int idx -> do
    int flags -> if
    java.lang.String name -> do
    java.lang.String parentName -> if
    nidefawl.qubes.vec.Matrix4f matRest -> do
    nidefawl.qubes.vec.Matrix4f matRestInv -> if
    java.util.List children -> do
    nidefawl.qubes.vec.Vector3f tail -> do
    nidefawl.qubes.vec.Vector3f tailLocal -> if
    nidefawl.qubes.models.qmodel.QModelBone parent -> do
    54:55:void addChild(nidefawl.qubes.models.qmodel.QModelBone) -> do
    76:76:java.lang.String stringInfo() -> do
    80:80:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelKeyFrameMatrix -> llJiiJiJ1LllJi1L:
    nidefawl.qubes.vec.Matrix4f mat -> do
nidefawl.qubes.models.qmodel.QModelMaterial -> jIllL1llIjJiiJL1:
    java.lang.String name -> do
    nidefawl.qubes.vec.Vector4f ambient -> do
    nidefawl.qubes.vec.Vector4f diffuse -> if
    nidefawl.qubes.vec.Vector4f specular -> for
    nidefawl.qubes.vec.Vector4f emissive -> int
    float specular_hardness -> do
    float transparency -> if
    int mode -> do
    java.lang.String texture -> if
    int idx -> if
nidefawl.qubes.models.qmodel.QModelPoseBone -> llIjL11LiJIj1LjI:
    java.util.List children -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> do
    nidefawl.qubes.vec.Matrix4f deformInterp -> if
    nidefawl.qubes.models.qmodel.QModelBone restbone -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone parent -> do
    boolean animate -> do
    37:38:void addChild(nidefawl.qubes.models.qmodel.QModelPoseBone) -> do
    51:55:void interpolateFrame(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f,float) -> do
    72:72:nidefawl.qubes.vec.Matrix4f getMatDeform() -> do
    89:89:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelTexture -> IjJiJijIL1IjiJL1:
    int idx -> do
    java.lang.String name -> do
    java.lang.String path -> if
    int glid -> if
    26:32:int get() -> do
    36:38:void release() -> do
nidefawl.qubes.models.qmodel.QModelTriGroup -> iJjI1LjIL11LjIIj:
    int idx -> do
    int flags -> if
    java.lang.String name -> do
    int[] triIdx -> do
    int materialIdx -> for
    nidefawl.qubes.models.qmodel.QModelMaterial material -> do
    java.util.List listTri -> do
    43:43:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelTriangle -> IjIjllll1LL11L1L:
    int idx -> do
    int[] vertIdx -> do
    nidefawl.qubes.vec.Vector3f[] normal -> do
    float[][] texCoord -> do
    int smoothing -> if
    int group -> for
    int flags -> int
    53:53:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelType -> Ji1L1LJi1LL1Jill:
    nidefawl.qubes.models.qmodel.QModelType STATIC -> do
    nidefawl.qubes.models.qmodel.QModelType RIGGED -> if
    nidefawl.qubes.models.qmodel.QModelType BLOCK -> for
    nidefawl.qubes.models.qmodel.QModelType[] $VALUES -> do
    10:10:nidefawl.qubes.models.qmodel.QModelType[] values() -> values
    10:10:nidefawl.qubes.models.qmodel.QModelType valueOf(java.lang.String) -> valueOf
    18:26:nidefawl.qubes.models.qmodel.QModelType get(int) -> do
nidefawl.qubes.models.qmodel.QModelVertex -> IjllJilliJL1jIIj:
    int idx -> do
    int flags -> if
    int refCount -> for
    int[] bones -> do
    float[] weights -> do
    int numBones -> int
nidefawl.qubes.models.voxel.ModelVox -> llL1iJL1L11LL1Ji:
    nidefawl.qubes.gl.VertexBuffer buf -> do
    nidefawl.qubes.gl.VertexBuffer shadowBuf -> if
    nidefawl.qubes.gl.GLQuadBuffer gpuBuf -> do
    nidefawl.qubes.gl.GLQuadBuffer gpuShadowBuf -> if
    nidefawl.qubes.assets.AssetVoxModel asset -> do
    nidefawl.qubes.models.voxel.ModelVoxPalette palette -> do
    nidefawl.qubes.vec.BlockPos size -> do
    byte[] volume -> do
    boolean needsDraw -> do
    long reRender -> do
    231:239:void release() -> do
nidefawl.qubes.models.voxel.ModelVoxPalette -> iJ1LllL1L1lljIL1:
    int[] table -> do
    20:34:void fromBytes(byte[]) -> do
    41:297:nidefawl.qubes.models.voxel.ModelVoxPalette fillDefault() -> do
nidefawl.qubes.modules.CoreModule -> JiL1L1JiiJjIIj:
    24:33:void onLoad(nidefawl.qubes.util.Side) -> do
nidefawl.qubes.modules.Module -> L1IjiJIjJiJill1L:
    void onLoad(nidefawl.qubes.util.Side) -> do
    15:15:void onServerStarted(nidefawl.qubes.server.GameServer) -> do
    21:21:java.lang.String getModuleName() -> do
nidefawl.qubes.modules.ModuleLoader -> llllJiJiL1iJllL1:
    java.util.Set modules -> do
    nidefawl.qubes.modules.Module[] modulesArray -> do
    java.lang.String overrideModules -> do
    32:44:void addURLs(java.net.URL[]) -> do
    47:76:void scanModules(java.io.File) -> do
    78:104:void scanModules() -> do
    106:115:void loadModules() -> if
    142:142:nidefawl.qubes.modules.Module[] getModulesArray() -> do
    149:150:void setOverrideModules(java.lang.String) -> do
nidefawl.qubes.modules.ModuleLoader$1 -> iJiJIjL1llllIjll:
    52:52:boolean accept(java.io.File) -> accept
nidefawl.qubes.nbt.Tag -> iJiJiJIjIjJiIjll:
    java.lang.String name -> do
    697:697:java.lang.String getName() -> do
    nidefawl.qubes.nbt.Tag$TagType getType() -> do
    void writeData(java.io.DataOutput) -> do
    void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    709:712:void write(nidefawl.qubes.nbt.Tag,java.io.DataOutput) -> do
    715:723:nidefawl.qubes.nbt.Tag read(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    727:757:nidefawl.qubes.nbt.Tag newFromType(nidefawl.qubes.nbt.Tag$TagType) -> if
    762:768:java.lang.String readString(java.io.DataInput) -> do
    772:779:void writeString(java.lang.String,java.io.DataOutput) -> do
    782:783:void setName(java.lang.String) -> do
    790:794:nidefawl.qubes.nbt.Tag$TagList wrapStringList(java.util.Collection) -> do
    802:806:java.util.ArrayList unwrapStringList(java.util.Collection) -> do
    14:14:nidefawl.qubes.nbt.Tag access$000(nidefawl.qubes.nbt.Tag$TagType) -> do
nidefawl.qubes.nbt.Tag$1 -> llllIjllllIjllJi:
    int[] $SwitchMap$nidefawl$qubes$nbt$Tag$TagType -> do
nidefawl.qubes.nbt.Tag$Byte -> IjjIL1Ji1LJijI1L:
    byte byteVal -> do
    69:70:void writeData(java.io.DataOutput) -> do
    74:74:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    84:86:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    89:89:byte getByte() -> do
nidefawl.qubes.nbt.Tag$ByteArray -> jIIjiJjI1LIjIjiJ:
    byte[] data -> do
    110:112:void writeData(java.io.DataOutput) -> do
    116:116:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    126:134:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    141:141:byte[] getArray() -> do
nidefawl.qubes.nbt.Tag$Compound -> IjllJiL1iJjIJill:
    java.util.Map data -> do
    321:321:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    331:340:void writeData(java.io.DataOutput) -> do
    344:363:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    366:366:java.util.Map getMap() -> do
    370:373:void set(java.lang.String,nidefawl.qubes.nbt.Tag) -> do
    376:377:void setInt(java.lang.String,int) -> do
    380:381:void setByteArray(java.lang.String,byte[]) -> do
    384:385:nidefawl.qubes.nbt.Tag$ByteArray getByteArray(java.lang.String) -> do
    389:389:nidefawl.qubes.nbt.Tag get(java.lang.String) -> do
    398:399:nidefawl.qubes.vec.Vector3f getVec3(java.lang.String) -> do
    403:404:void setVec3(java.lang.String,nidefawl.qubes.vec.Vector3f) -> do
    407:408:java.util.UUID getUUID(java.lang.String) -> do
    412:413:void setUUID(java.lang.String,java.util.UUID) -> do
    416:417:int getByte(java.lang.String) -> do
    421:422:void setByte(java.lang.String,int) -> if
    426:427:void setBoolean(java.lang.String,boolean) -> do
    430:431:int getInt(java.lang.String) -> if
    435:435:boolean getBoolean(java.lang.String) -> do
    440:441:java.util.List getList(java.lang.String) -> do
    450:451:void setList(java.lang.String,nidefawl.qubes.nbt.Tag$TagList) -> do
    458:459:void setString(java.lang.String,java.lang.String) -> do
    466:467:java.lang.String getString(java.lang.String) -> do
nidefawl.qubes.nbt.Tag$Double -> L1IjL1jIjIllL1Ij:
    double doubleVal -> do
    158:159:void writeData(java.io.DataOutput) -> do
    163:163:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    173:175:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$End -> L11LL1IjjIL1jIll:
    43:43:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    48:48:void writeData(java.io.DataOutput) -> do
    52:52:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Float -> IjIjIjjIllL1jIjI:
    float floatVal -> do
    477:478:void writeData(java.io.DataOutput) -> do
    482:482:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    492:494:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Int -> JilllliJiJJiJiL1:
    int data -> do
    518:519:void writeData(java.io.DataOutput) -> do
    523:523:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    533:535:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    538:538:int getInt() -> do
nidefawl.qubes.nbt.Tag$Long -> iJjIL1IjIjJilljI:
    long data -> do
    593:594:void writeData(java.io.DataOutput) -> do
    598:598:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    608:610:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Short -> iJL1IjJiJiL1jIJi:
    short data -> do
    668:669:void writeData(java.io.DataOutput) -> do
    673:673:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    683:685:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$StringTag -> jIiJL1JiJijIiJjI:
    java.lang.String data -> if
    559:559:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    569:571:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    575:576:void writeData(java.io.DataOutput) -> do
    583:583:java.lang.String getString() -> if
nidefawl.qubes.nbt.Tag$TagList -> IjIjJiIjL1jIIjL1:
    java.util.List data -> do
    nidefawl.qubes.nbt.Tag$TagType tagType -> do
    243:256:void writeData(java.io.DataOutput) -> do
    260:260:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    268:268:int getSize() -> do
    273:294:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    297:297:java.util.List getList() -> do
    301:307:void add(nidefawl.qubes.nbt.Tag) -> do
    310:310:nidefawl.qubes.nbt.Tag$TagType getListTagType() -> if
nidefawl.qubes.nbt.Tag$TagType -> IjL11LL1iJ1LiJll:
    nidefawl.qubes.nbt.Tag$TagType END -> do
    nidefawl.qubes.nbt.Tag$TagType BYTE -> if
    nidefawl.qubes.nbt.Tag$TagType SHORT -> for
    nidefawl.qubes.nbt.Tag$TagType INT -> int
    nidefawl.qubes.nbt.Tag$TagType LONG -> new
    nidefawl.qubes.nbt.Tag$TagType FLOAT -> try
    nidefawl.qubes.nbt.Tag$TagType DOUBLE -> byte
    nidefawl.qubes.nbt.Tag$TagType BYTEARRAY -> case
    nidefawl.qubes.nbt.Tag$TagType STRING -> char
    nidefawl.qubes.nbt.Tag$TagType LIST -> else
    nidefawl.qubes.nbt.Tag$TagType COMPOUND -> goto
    nidefawl.qubes.nbt.Tag$TagType VEC3 -> long
    nidefawl.qubes.nbt.Tag$TagType UUID -> this
    nidefawl.qubes.nbt.Tag$TagType[] $VALUES -> do
    16:16:nidefawl.qubes.nbt.Tag$TagType[] values() -> values
    16:16:nidefawl.qubes.nbt.Tag$TagType valueOf(java.lang.String) -> valueOf
    19:19:int getID() -> do
    23:23:nidefawl.qubes.nbt.Tag$TagType fromID(int) -> do
nidefawl.qubes.nbt.Tag$UUIDTag -> jIjIllllL1IjL1L1:
    java.util.UUID data -> do
    634:636:void writeData(java.io.DataOutput) -> do
    640:640:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    650:652:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    655:655:java.util.UUID getUUID() -> do
nidefawl.qubes.nbt.Tag$Vec3Tag -> jIjIllJijIIj1LIj:
    nidefawl.qubes.vec.Vector3f vec3 -> do
    201:204:void writeData(java.io.DataOutput) -> do
    208:208:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    218:220:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    231:231:nidefawl.qubes.vec.Vector3f getVec3() -> do
nidefawl.qubes.nbt.TagReadLimiter -> L1jIlllliJJiJiJi:
    nidefawl.qubes.nbt.TagReadLimiter UNLIMITED -> do
    int totalReadBytes -> do
    int limit -> if
    int maxStackDepth -> for
    int stackDepth -> int
    25:29:void add(int) -> do
    31:35:void push() -> do
    37:38:void pop() -> if
nidefawl.qubes.nbt.TagReadLimiter$1 -> iJL1lliJjIllIj1L:
    7:7:void add(int) -> do
    8:8:void push() -> do
    9:9:void pop() -> if
nidefawl.qubes.nbt.TagReader -> iJiJIjiJiJll1L1L:
    29:30:nidefawl.qubes.nbt.Tag readTagFromCompressedBytes(byte[]) -> do
    34:39:byte[] writeTagToCompresedBytes(nidefawl.qubes.nbt.Tag) -> do
    43:45:nidefawl.qubes.nbt.Tag readTagFromFile(java.io.File) -> do
    49:52:void writeTagToFile(nidefawl.qubes.nbt.Tag,java.io.File) -> do
nidefawl.qubes.network.Connection -> iJ1LjIIjjIL1JiiJ:
    java.net.Socket socket -> do
    java.io.DataInputStream inStream -> do
    java.io.DataOutputStream outStream -> do
    nidefawl.qubes.network.ReaderThread readThread -> do
    nidefawl.qubes.network.WriterThread writeThread -> do
    boolean isConnected -> do
    boolean cleanUp -> if
    java.util.concurrent.LinkedBlockingQueue incoming -> do
    java.util.concurrent.LinkedBlockingQueue outgoing -> if
    java.io.InputStream sIn -> do
    java.lang.Throwable readWriteException -> do
    int disconnectFrom -> do
    java.lang.String disconnectReason -> do
    42:45:void startThreads() -> do
    48:48:boolean isConnected() -> do
    52:59:boolean readPackets() -> if
    63:72:boolean writePackets() -> for
    78:81:void onError(java.lang.Exception) -> do
    84:87:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    90:110:void validateConnection() -> if
    113:131:void onDisconnect() -> int
    134:136:void interruptThreads() -> for
    139:162:void disconnect(int,java.lang.String) -> do
    165:165:boolean finished() -> int
    169:169:java.net.InetSocketAddress getAddr() -> do
    173:173:nidefawl.qubes.network.packet.Packet pollPacket() -> do
    177:177:java.util.concurrent.LinkedBlockingQueue getIncoming() -> do
    181:181:int getDisconnectFrom() -> do
    185:185:java.lang.String getDisconnectReason() -> do
nidefawl.qubes.network.Handler -> iJ1LJiL1iJjIIj1L:
    boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    void onDisconnect(int,java.lang.String) -> do
    26:26:void handleHandshake(nidefawl.qubes.network.packet.PacketHandshake) -> do
    29:29:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    33:33:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    36:36:void handleSpawnInWorld(nidefawl.qubes.network.packet.PacketSSpawnInWorld) -> do
    39:39:void handleAuth(nidefawl.qubes.network.packet.PacketAuth) -> do
    42:42:void handleMovement(nidefawl.qubes.network.packet.PacketCMovement) -> do
    46:46:void handleChunkDataMulti(nidefawl.qubes.network.packet.PacketSChunkData,int) -> do
    49:49:void handleSetBlock(nidefawl.qubes.network.packet.PacketCSetBlock) -> do
    53:53:void handleSetBlocks(nidefawl.qubes.network.packet.PacketCSetBlocks) -> do
    56:56:void handleBlock(nidefawl.qubes.network.packet.PacketSSetBlock) -> do
    59:59:void handleMultiBlock(nidefawl.qubes.network.packet.PacketSSetBlocks) -> do
    63:66:void handlePackets(java.util.concurrent.LinkedBlockingQueue) -> do
    69:69:void handleLightChunk(nidefawl.qubes.network.packet.PacketSLightChunk) -> do
    76:76:void handleTrackChunk(nidefawl.qubes.network.packet.PacketSTrackChunk) -> do
    82:82:void handleClientSettings(nidefawl.qubes.network.packet.PacketCSettings) -> do
    89:89:void handleSwitchWorld(nidefawl.qubes.network.packet.PacketCSwitchWorld) -> do
    96:96:void handleChat(nidefawl.qubes.network.packet.PacketChatMessage) -> do
    103:103:void handleChannels(nidefawl.qubes.network.packet.PacketChatChannels) -> do
    110:110:void handleWorldTime(nidefawl.qubes.network.packet.PacketSWorldTime) -> do
    117:117:void handleTeleport(nidefawl.qubes.network.packet.PacketSTeleport) -> do
    123:123:void handleSync(nidefawl.qubes.network.packet.PacketSyncBlocks) -> do
    130:130:void handleTeleportAck(nidefawl.qubes.network.packet.PacketCTeleportAck) -> do
    136:136:void handleEntityUntrack(nidefawl.qubes.network.packet.PacketSEntityUnTrack) -> do
    142:142:void handleEntityTrack(nidefawl.qubes.network.packet.PacketSEntityTrack) -> do
    148:148:void handleEntityMove(nidefawl.qubes.network.packet.PacketSEntityMove) -> do
    154:154:void handleWorldBiomes(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    157:157:void handleDigState(nidefawl.qubes.network.packet.PacketCDigState) -> do
    160:160:void handleServerDigState(nidefawl.qubes.network.packet.PacketSDigState) -> do
    163:163:void handleDebugBBs(nidefawl.qubes.network.packet.PacketSDebugBB) -> do
    166:166:void handleInvClick(nidefawl.qubes.network.packet.PacketCInvClick) -> do
    169:169:void handleInvSync(nidefawl.qubes.network.packet.PacketSInvSync) -> do
    172:172:void handleCrafting(nidefawl.qubes.network.packet.PacketCCrafting) -> do
    175:175:void handleCraftingProgress(nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
    178:178:void handleInvSyncIncr(nidefawl.qubes.network.packet.PacketSInvSyncIncr) -> do
nidefawl.qubes.network.ReaderThread -> Ij1L1LJijIlljIJi:
    int ACTIVE_THREADS -> do
    nidefawl.qubes.network.Connection conn -> do
    boolean interrupted -> do
    16:20:void interruptThread() -> do
    24:45:void run() -> run
nidefawl.qubes.network.StreamIO -> lllliJJijIllJijI:
    void read(java.io.DataInput) -> do
    void write(java.io.DataOutput) -> do
nidefawl.qubes.network.WriterThread -> JiIj1LL1Ij1LJiiJ:
    int ACTIVE_THREADS -> do
    nidefawl.qubes.network.Connection conn -> do
    boolean interrupted -> do
    15:19:void interruptThread() -> do
    23:46:void run() -> run
nidefawl.qubes.network.client.ClientHandler -> IjL1llL1L1L11Lll:
    int state -> do
    nidefawl.qubes.network.client.NetworkClient client -> do
    long time -> do
    int disconnectFrom -> if
    java.lang.String disconnectReason -> do
    nidefawl.qubes.world.WorldClient world -> do
    nidefawl.qubes.entity.PlayerSelf player -> do
    nidefawl.qubes.chunk.client.ChunkManagerClient chunkManager -> do
    java.util.zip.Inflater inflate -> do
    int i10Meg -> for
    byte[] tmpBuffer -> do
    58:65:void update() -> do
    69:70:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    74:85:void handleHandshake(nidefawl.qubes.network.packet.PacketHandshake) -> do
    88:97:void handleSync(nidefawl.qubes.network.packet.PacketSyncBlocks) -> do
    100:115:void handleAuth(nidefawl.qubes.network.packet.PacketAuth) -> do
    119:119:java.lang.String getHandlerName() -> do
    124:125:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    128:128:int getState() -> do
    142:146:void onDisconnect(int,java.lang.String) -> do
    148:150:java.lang.String getDisconnectReason() -> if
    155:170:void handleSpawnInWorld(nidefawl.qubes.network.packet.PacketSSpawnInWorld) -> do
    176:182:void handleTeleport(nidefawl.qubes.network.packet.PacketSTeleport) -> do
    185:186:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    189:192:void byteToShortArray(byte[],short[],int) -> do
    198:225:void handleChunkDataMulti(nidefawl.qubes.network.packet.PacketSChunkData,int) -> do
    228:298:void processChunkData(nidefawl.qubes.network.packet.PacketSChunkData,byte[],int) -> do
    306:316:byte[] inflate(byte[]) -> do
    321:321:boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    325:326:void handleBlock(nidefawl.qubes.network.packet.PacketSSetBlock) -> do
    329:355:void handleMultiBlock(nidefawl.qubes.network.packet.PacketSSetBlocks) -> do
    358:371:void handleLightChunk(nidefawl.qubes.network.packet.PacketSLightChunk) -> do
    373:377:void handleTrackChunk(nidefawl.qubes.network.packet.PacketSTrackChunk) -> do
    380:381:void handleChat(nidefawl.qubes.network.packet.PacketChatMessage) -> do
    384:386:void handleChannels(nidefawl.qubes.network.packet.PacketChatChannels) -> do
    392:396:void handleWorldTime(nidefawl.qubes.network.packet.PacketSWorldTime) -> do
    402:406:void handleEntityUntrack(nidefawl.qubes.network.packet.PacketSEntityUnTrack) -> do
    412:422:void handleEntityTrack(nidefawl.qubes.network.packet.PacketSEntityTrack) -> do
    428:441:void handleEntityMove(nidefawl.qubes.network.packet.PacketSEntityMove) -> do
    445:447:void handleWorldBiomes(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    449:450:void handleServerDigState(nidefawl.qubes.network.packet.PacketSDigState) -> do
    452:457:void handleDebugBBs(nidefawl.qubes.network.packet.PacketSDebugBB) -> do
    460:467:void handleInvSync(nidefawl.qubes.network.packet.PacketSInvSync) -> do
    469:476:void handleInvSyncIncr(nidefawl.qubes.network.packet.PacketSInvSyncIncr) -> do
    478:488:void handleCraftingProgress(nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
    38:38:void access$000(nidefawl.qubes.network.client.ClientHandler,nidefawl.qubes.network.packet.PacketSChunkData,byte[],int) -> do
nidefawl.qubes.network.client.ClientHandler$1 -> IjiJllL1iJiJiJll:
    nidefawl.qubes.network.packet.PacketSChunkData val$packet -> do
    int val$flags -> do
    nidefawl.qubes.network.client.ClientHandler this$0 -> do
    202:211:java.lang.Runnable call() -> do
    219:219:boolean requiresComplete() -> do
    199:199:java.lang.Object call() -> call
nidefawl.qubes.network.client.ClientHandler$1$1 -> JiIjL1llL1jIJiL1:
    byte[] val$decompressData -> do
    nidefawl.qubes.network.client.ClientHandler$1 this$1 -> do
    207:208:void run() -> run
nidefawl.qubes.network.client.NetworkClient -> llll1LjIll1L1LiJ:
    nidefawl.qubes.network.client.ClientHandler handler -> do
    nidefawl.qubes.network.Connection conn -> do
    int netVersion -> do
    27:47:void update() -> do
    49:70:void processLogin() -> if
    72:72:nidefawl.qubes.network.client.ClientHandler getClient() -> do
    76:76:boolean isConnected() -> do
    81:82:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    85:86:void disconnect(java.lang.String) -> do
    90:91:void onKick(int,java.lang.String) -> do
nidefawl.qubes.network.client.ThreadConnect -> L1jIL1L1jIiJll1L:
    java.lang.String host -> do
    int port -> do
    java.lang.Thread thread -> do
    boolean finished -> do
    boolean cancelled -> if
    boolean connected -> for
    java.lang.String stateStr -> if
    26:63:void run() -> run
    66:70:void startThread() -> do
    73:73:java.lang.String getState() -> do
    76:77:void cancel() -> if
nidefawl.qubes.network.packet.AbstractPacketWorldRef -> JiIj1LjIJiJi:
    int worldID -> do
    20:21:void readPacket(java.io.DataInput) -> do
    25:26:void writePacket(java.io.DataOutput) -> do
    29:29:int getWorldId() -> do
nidefawl.qubes.network.packet.InvalidPacketException -> llllllL11LL1L1ll:
    java.lang.Class clazz -> do
    22:22:java.lang.Class getClazz() -> do
nidefawl.qubes.network.packet.Packet -> jIJilliJIjIjiJJi:
    int NEXT_PACKET_ID -> do
    java.lang.Class[] packets -> do
    boolean[] sentByServer -> do
    boolean[] sentByClient -> if
    java.util.Map classToIDMap -> do
    int id -> if
    nidefawl.qubes.network.packet.Packet lastSuccess -> do
    70:82:nidefawl.qubes.network.packet.Packet read(java.io.DataInput) -> do
    86:88:void write(nidefawl.qubes.network.packet.Packet,java.io.DataOutput) -> do
    92:92:nidefawl.qubes.network.packet.Packet makePacket(int) -> do
    void readPacket(java.io.DataInput) -> do
    void writePacket(java.io.DataOutput) -> do
    void handle(nidefawl.qubes.network.Handler) -> do
    102:110:nidefawl.qubes.network.packet.Packet makePacket(java.lang.Class) -> do
    114:114:int getID() -> do
    118:123:void register(java.lang.Class,boolean,boolean) -> do
    132:132:java.lang.String readString(java.io.DataInput) -> do
    136:143:java.lang.String readString(java.io.DataInput,int) -> do
    146:153:void writeString(java.lang.String,java.io.DataOutput) -> do
    156:168:nidefawl.qubes.item.BaseStack readStack(java.io.DataInput) -> do
    174:185:void writeStack(nidefawl.qubes.item.BaseStack,java.io.DataOutput) -> do
nidefawl.qubes.network.packet.PacketAuth -> L1lliJL11LJiiJll:
    java.lang.String name -> do
    boolean success -> do
    29:31:void readPacket(java.io.DataInput) -> do
    35:37:void writePacket(java.io.DataOutput) -> do
    41:42:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCCrafting -> jIjIIj1LiJ1LiJ:
    int id -> do
    int action -> if
    25:27:void readPacket(java.io.DataInput) -> do
    31:33:void writePacket(java.io.DataOutput) -> do
    37:38:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCDigState -> JiIjIjJi1LiJll1L:
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> if
    nidefawl.qubes.item.BaseStack stack -> do
    int stage -> for
    34:40:void readPacket(java.io.DataInput) -> do
    44:50:void writePacket(java.io.DataOutput) -> do
    56:58:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCInvClick -> IjIjIjiJL1L11L:
    int id -> do
    int idx -> if
    int button -> for
    int action -> int
    nidefawl.qubes.item.BaseStack stack -> do
    31:36:void readPacket(java.io.DataInput) -> do
    40:45:void writePacket(java.io.DataOutput) -> do
    49:50:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCMovement -> IjIjL1JiJiL1L1ll:
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> do
    27:31:void readPacket(java.io.DataInput) -> do
    35:41:void writePacket(java.io.DataOutput) -> do
    47:48:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSetBlock -> L11LL1L1jIiJJiL1:
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> if
    nidefawl.qubes.item.BlockStack stack -> do
    33:40:void readPacket(java.io.DataInput) -> do
    44:49:void writePacket(java.io.DataOutput) -> do
    55:58:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSetBlocks -> iJjI1LiJ1LjIL1Ji:
    int x -> if
    int y -> for
    int z -> int
    int x2 -> new
    int y2 -> try
    int z2 -> byte
    nidefawl.qubes.item.BlockStack stack -> do
    int flags -> case
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> char
    47:60:void readPacket(java.io.DataInput) -> do
    64:75:void writePacket(java.io.DataOutput) -> do
    81:83:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSettings -> jIJill1LiJjIlliJ:
    int chunkLoadDistance -> do
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:30:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSwitchWorld -> IjIjJiIjjIL1jIL1:
    int flags -> do
    21:22:void readPacket(java.io.DataInput) -> do
    26:27:void writePacket(java.io.DataOutput) -> do
    33:34:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCTeleportAck -> jIL1IjIjlliJlljI:
    int sync -> if
    21:23:void readPacket(java.io.DataInput) -> do
    27:29:void writePacket(java.io.DataOutput) -> do
    35:36:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketChatChannels -> IjIjllL1llL1Ij:
    java.util.ArrayList list -> do
    40:45:void readPacket(java.io.DataInput) -> do
    52:56:void writePacket(java.io.DataOutput) -> do
    68:69:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketChatMessage -> Ji1LL1lljIL11LJi:
    java.lang.String channel -> do
    java.lang.String message -> if
    21:23:void readPacket(java.io.DataInput) -> do
    27:29:void writePacket(java.io.DataOutput) -> do
    33:34:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketDisconnect -> JiiJJi1LllJiiJjI:
    int code -> do
    java.lang.String message -> do
    20:22:void readPacket(java.io.DataInput) -> do
    26:28:void writePacket(java.io.DataOutput) -> do
    32:33:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketHandshake -> JillllJiJiIj1L:
    int version -> do
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:30:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketPing -> JiL1IjJiIjL1iJll:
    long time -> do
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:30:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSChunkData -> ll1LJi1LJijIjI1L:
    int len -> if
    byte[] blocks -> do
    int flags -> for
    int[][] coords -> do
    23:33:void readPacket(java.io.DataInput) -> do
    37:46:void writePacket(java.io.DataOutput) -> do
    52:60:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSCraftingProgress -> jIiJL1jIIjiJJijI:
    int id -> do
    int action -> if
    long currentTime -> do
    long startTime -> if
    long endTime -> for
    int recipe -> for
    29:35:void readPacket(java.io.DataInput) -> do
    39:45:void writePacket(java.io.DataOutput) -> do
    49:50:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSDebugBB -> L1ll1LiJJiiJllL1:
    java.util.List boxes -> do
    24:31:void readPacket(java.io.DataInput) -> do
    35:40:void writePacket(java.io.DataOutput) -> do
    46:47:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSDigState -> iJiJIjjI1LIjiJIj:
    int stage -> if
    23:25:void readPacket(java.io.DataInput) -> do
    29:31:void writePacket(java.io.DataOutput) -> do
    37:39:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityMove -> IjiJllJiJiL1Ij:
    int entId -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> if
    float yawBodyOffset -> for
    37:46:void readPacket(java.io.DataInput) -> do
    50:62:void writePacket(java.io.DataOutput) -> do
    68:69:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityTrack -> jIllllL1jIiJIjll:
    int entId -> do
    int entType -> if
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float yawbody -> if
    float pitch -> for
    nidefawl.qubes.nbt.Tag data -> do
    35:45:void readPacket(java.io.DataInput) -> do
    49:66:void writePacket(java.io.DataOutput) -> do
    72:73:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityUnTrack -> jIiJL1lljIjIIjIj:
    int entId -> do
    30:31:void readPacket(java.io.DataInput) -> do
    35:36:void writePacket(java.io.DataOutput) -> do
    42:43:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSInvSync -> Jill1LJiL1IjJiJi:
    int invId -> do
    int invSize -> if
    java.util.Collection stacks -> do
    31:40:void readPacket(java.io.DataInput) -> do
    44:50:void writePacket(java.io.DataOutput) -> do
    54:55:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSInvSyncIncr -> IjiJjIjIiJJiIjll:
    int invId -> do
    java.util.Collection stacks -> do
    30:38:void readPacket(java.io.DataInput) -> do
    42:47:void writePacket(java.io.DataOutput) -> do
    51:52:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSLightChunk -> L11LiJIjL1JiIjll:
    int coordX -> if
    int coordZ -> for
    byte[] data -> do
    short min -> do
    short max -> if
    22:30:void readPacket(java.io.DataInput) -> do
    34:41:void writePacket(java.io.DataOutput) -> do
    47:50:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSSetBlock -> jIllJiIjL11LL1jI:
    int x -> if
    int y -> for
    int z -> int
    int type -> new
    int light -> try
    29:36:void readPacket(java.io.DataInput) -> do
    40:46:void writePacket(java.io.DataOutput) -> do
    52:54:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSSetBlocks -> iJjIjIJijIIjJijI:
    int chunkX -> if
    int chunkZ -> for
    short[] positions -> do
    short[] blocks -> if
    byte[] lights -> do
    short[] data -> for
    nidefawl.qubes.chunk.blockdata.BlockData[] bdata -> do
    int numBlockData -> int
    43:73:void readPacket(java.io.DataInput) -> do
    77:98:void writePacket(java.io.DataOutput) -> do
    104:106:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSSpawnInWorld -> JiIjL11LL11LL1L1:
    nidefawl.qubes.world.IWorldSettings worldSettings -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    int flags -> do
    int entId -> if
    int worldType -> for
    31:37:void readPacket(java.io.DataInput) -> do
    41:48:void writePacket(java.io.DataOutput) -> do
    54:55:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSTeleport -> IjJillllL1IjIjJi:
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> if
    int sync -> for
    31:37:void readPacket(java.io.DataInput) -> do
    41:49:void writePacket(java.io.DataOutput) -> do
    55:56:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSTrackChunk -> iJL1iJL1ll1LiJ1L:
    int x -> if
    int z -> for
    boolean add -> do
    24:29:void readPacket(java.io.DataInput) -> do
    33:37:void writePacket(java.io.DataOutput) -> do
    41:43:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSWorldBiomes -> jIiJ1LjI1L1LIjL1:
    int numBiomes -> if
    int[] coordsX -> do
    int[] coordsZ -> if
    byte[] biomes -> do
    34:44:void readPacket(java.io.DataInput) -> do
    48:55:void writePacket(java.io.DataOutput) -> do
    61:63:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSWorldTime -> jIIj1LIjllJillJi:
    long time -> do
    long daylen -> if
    boolean isFixed -> do
    25:29:void readPacket(java.io.DataInput) -> do
    33:37:void writePacket(java.io.DataOutput) -> do
    43:46:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSyncBlocks -> L1L1iJjIL1L11Lll:
    short[] blockIds -> do
    23:32:void readPacket(java.io.DataInput) -> do
    36:39:void writePacket(java.io.DataOutput) -> do
    43:44:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.server.ListenThread -> iJjIlljIllL1Jill:
    java.net.ServerSocket serverSocket -> do
    nidefawl.qubes.network.server.NetworkServer server -> do
    boolean finished -> do
    boolean started -> if
    24:40:void run() -> run
    42:62:void halt() -> do
nidefawl.qubes.network.server.NetworkServer -> L1IjjIJiiJjIJiiJ:
    boolean isRunning -> do
    nidefawl.qubes.network.server.ListenThread listenThread -> do
    nidefawl.qubes.server.GameServer server -> do
    long packetTimeout -> do
    long pingDelay -> if
    int netVersion -> do
    java.util.ArrayList handlersPlay -> do
    java.util.ArrayList handlersLogin -> if
    38:39:void startListener() -> do
    43:48:void addConnection(java.net.Socket) -> do
    51:61:void halt() -> if
    64:102:void update() -> for
    105:106:void addServerHandlerPlay(nidefawl.qubes.entity.Player,nidefawl.qubes.network.server.ServerHandlerLogin,nidefawl.qubes.network.server.ServerHandlerPlay) -> do
nidefawl.qubes.network.server.ServerHandler -> L1JiiJlljIll1Lll:
    int state -> do
    nidefawl.qubes.network.Connection conn -> do
    java.net.InetSocketAddress addr -> do
    java.lang.String handlerName -> do
    long time -> do
    nidefawl.qubes.server.GameServer server -> do
    nidefawl.qubes.network.server.NetworkServer netServer -> do
    41:71:void update() -> do
    75:76:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    81:81:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    85:85:java.lang.String getHandlerName() -> do
    90:91:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    94:95:void kick(java.lang.String) -> do
    98:98:boolean finished() -> do
nidefawl.qubes.network.server.ServerHandlerLogin -> L1JiL11LJiJi:
    java.lang.String name -> if
    25:36:void handleHandshake(nidefawl.qubes.network.packet.PacketHandshake) -> do
    40:40:void onDisconnect(int,java.lang.String) -> do
    44:52:void handleAuth(nidefawl.qubes.network.packet.PacketAuth) -> do
    56:86:void handleClientSettings(nidefawl.qubes.network.packet.PacketCSettings) -> do
    90:90:boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    95:95:boolean finished() -> do
    100:101:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    104:118:void handleSync(nidefawl.qubes.network.packet.PacketSyncBlocks) -> do
nidefawl.qubes.network.server.ServerHandlerPlay -> iJJiL1iJlljIL1L1:
    nidefawl.qubes.entity.PlayerServer player -> do
    int posSyncSent -> if
    int posSyncRecv -> for
    34:34:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    37:55:void update() -> do
    59:79:void handleSwitchWorld(nidefawl.qubes.network.packet.PacketCSwitchWorld) -> do
    83:83:java.lang.String getHandlerName() -> do
    88:89:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    94:105:void onDisconnect(int,java.lang.String) -> do
    108:109:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    112:114:void handleSetBlock(nidefawl.qubes.network.packet.PacketCSetBlock) -> do
    118:201:void handleSetBlocks(nidefawl.qubes.network.packet.PacketCSetBlocks) -> do
    205:205:boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    209:209:nidefawl.qubes.entity.Player getPlayer() -> do
    213:221:void handleChat(nidefawl.qubes.network.packet.PacketChatMessage) -> do
    225:234:void handleMovement(nidefawl.qubes.network.packet.PacketCMovement) -> do
    237:238:void handleTeleportAck(nidefawl.qubes.network.packet.PacketCTeleportAck) -> do
    241:253:void resyncPosition() -> if
    256:257:void handleDigState(nidefawl.qubes.network.packet.PacketCDigState) -> do
    260:275:void handleInvClick(nidefawl.qubes.network.packet.PacketCInvClick) -> do
    277:287:void handleCrafting(nidefawl.qubes.network.packet.PacketCCrafting) -> do
nidefawl.qubes.noise.AbstractNoiseGen -> jIIj1LIjJijIIj1L:
nidefawl.qubes.noise.RiverNoise2D -> L1JiJi1LIjL1Ji1L:
    double[][] dWeights -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise n1 -> do
    double scale -> do
    int maxI -> do
    int size -> if
    72:74:double dist2d(double,double,double,double) -> do
    78:103:nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult generate(int,int) -> do
    5:5:double[][] access$000() -> do
nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult -> JiL11L1LjI1LiJjI:
    double[] dNoise -> do
    int size -> do
    int maxI -> if
    19:35:double getBlur(int,int,int) -> do
    6:6:double[] access$100(nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult) -> do
nidefawl.qubes.noise.TerrainNoise -> iJjIllL11LiJJi1L:
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise noise -> do
    double scaleX -> do
    double scaleY -> if
    double scaleZ -> for
    int nOctaves -> do
    21:32:double get(int,int,int) -> do
nidefawl.qubes.noise.TerrainNoise2D -> iJjIllIj1LIjL1ll:
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise noise -> do
    double scaleX -> do
    double scaleZ -> if
    int nOctaves -> do
    19:29:double get(int,int) -> do
nidefawl.qubes.noise.TerrainNoiseCustom1 -> iJjIiJJijIiJ1LIj:
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise noise -> do
    double scaleX -> do
    double scaleY -> if
    double scaleZ -> for
    int nOctaves -> do
    21:32:double get(int,int,int) -> do
nidefawl.qubes.noise.opennoise.OpenSimplexNoise -> L1jI1L1L1LjIjIL1:
    double eval(double,double,double) -> do
    double eval(double,double) -> do
nidefawl.qubes.noise.opennoise.OpenSimplexNoiseJava -> IjiJjIIjjIIjjIL1:
    short[] perm -> do
    short[] permGradIndex3D -> if
    byte[] gradients2D -> do
    byte[] gradients3D -> if
    byte[] gradients4D -> for
    77:185:double eval(double,double) -> do
    193:747:double eval(double,double,double) -> do
    2067:2068:double extrapolate(int,int,double,double) -> do
    2074:2075:double extrapolate(int,int,int,double,double,double) -> do
    2090:2091:int fastFloor(double) -> do
nidefawl.qubes.perf.TimingHelper -> JiiJL1IjlliJ:
    boolean useNanos -> do
    boolean init -> if
    int LEN -> do
    long[] nanos -> do
    long[] millis -> if
    long[] calls -> for
    long[] beginNanos -> int
    long[] beginMillis -> new
    boolean[] on -> do
    java.lang.String[] names -> do
    java.util.HashMap map -> do
    int jObjectIdx -> if
    java.util.Stack stack -> do
    63:77:boolean start(int) -> do
    80:83:void startSilent(int) -> do
    96:113:long end(int) -> do
    192:196:void reset() -> do
nidefawl.qubes.player.PlayerData -> IjJijI1LjIIjL1Ji:
    java.util.UUID world -> do
    boolean flying -> do
    int chunkLoadDistance -> do
    java.util.HashSet joinedChannels -> do
    java.util.HashMap worldPositions -> do
    java.util.List invStacks -> do
    java.util.List[] invCraftStacks -> do
    32:57:void load(nidefawl.qubes.nbt.Tag$Compound) -> do
    60:77:nidefawl.qubes.nbt.Tag save() -> do
nidefawl.qubes.render.AbstractRenderer -> IjL1IjiJJi1LjIJi:
    boolean recompileShaders -> do
    java.util.List resourcesShaders -> do
    java.util.List resourcesShadersNew -> if
    java.util.List resourcesFramebuffers -> for
    25:37:void addResource(nidefawl.qubes.util.IManagedResource) -> do
    41:47:void release() -> do
    53:54:void pushCurrentShaders() -> if
    60:66:void popNewShaders() -> for
    72:76:void releaseNewShaders() -> int
    81:97:void releaseAll(nidefawl.qubes.util.EResourceType) -> do
nidefawl.qubes.render.AbstractRenderer$1 -> jIJi1LlljIlliJIj:
    int[] $SwitchMap$nidefawl$qubes$util$EResourceType -> do
nidefawl.qubes.render.FinalRenderer -> JijIJiL1iJlllljI:
    nidefawl.qubes.shader.Shader shaderBloomCombine -> do
    nidefawl.qubes.shader.Shader shaderFinal -> if
    nidefawl.qubes.shader.Shader shaderBlur -> for
    nidefawl.qubes.shader.Shader shaderDeferred -> int
    nidefawl.qubes.shader.Shader shaderDeferredWater -> new
    nidefawl.qubes.shader.Shader shaderDeferredFirstPerson -> try
    nidefawl.qubes.shader.Shader shaderInterpLum -> byte
    nidefawl.qubes.shader.Shader shaderThreshold -> case
    nidefawl.qubes.shader.Shader shaderSSR -> char
    nidefawl.qubes.shader.Shader shaderSSRBlur -> else
    nidefawl.qubes.shader.Shader shaderSSRCombine -> goto
    nidefawl.qubes.shader.Shader shaderDownsample4x -> long
    nidefawl.qubes.shader.Shader shaderDownsample4xLum -> this
    nidefawl.qubes.shader.Shader shaderNormals -> void
    nidefawl.qubes.gl.FrameBuffer fbScene -> case
    nidefawl.qubes.gl.FrameBuffer fbSSR -> do
    nidefawl.qubes.gl.FrameBuffer fbSSRBlurredX -> if
    nidefawl.qubes.gl.FrameBuffer fbSSRBlurredY -> for
    nidefawl.qubes.gl.FrameBuffer fbSSRCombined -> int
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> new
    nidefawl.qubes.gl.FrameBuffer fbSSAO -> try
    nidefawl.qubes.gl.FrameBuffer fbFinal -> byte
    nidefawl.qubes.gl.FrameBuffer fbBlur1 -> char
    nidefawl.qubes.gl.FrameBuffer fbBlur2 -> else
    nidefawl.qubes.gl.FrameBuffer[] fbLuminanceDownsample -> do
    nidefawl.qubes.gl.FrameBuffer[] fbLuminanceInterp -> if
    int blurTexture -> do
    int preWaterDepthTex -> if
    boolean startup -> if
    int ssr -> for
    int frame -> int
    nidefawl.qubes.render.post.SMAA smaa -> do
    int[][] kawaseKernelSizePasses -> do
    java.nio.FloatBuffer scaleMatBuf -> do
    74:134:void renderDeferred(nidefawl.qubes.world.World,float,int) -> do
    136:137:void bindFB() -> new
    139:140:void clearFrameBuffer() -> try
    152:194:void calcLum(nidefawl.qubes.world.World,float) -> do
    196:215:void renderBlur(nidefawl.qubes.world.World,float) -> if
    218:247:int blur(int,int,int,nidefawl.qubes.gl.FrameBuffer) -> do
    253:255:void render(nidefawl.qubes.world.World,float,int) -> if
    258:262:void renderReflAndBlur(nidefawl.qubes.world.World,float) -> for
    273:325:void renderReflection(nidefawl.qubes.world.World,float) -> try
    329:368:void renderFinal(nidefawl.qubes.world.World,float) -> int
    380:384:void copyPreWaterDepth() -> byte
    386:392:void copySceneDepthBuffer() -> case
    394:422:void renderBloom(nidefawl.qubes.world.World,float) -> new
    427:596:void initShaders() -> char
    600:627:void initAO(int,int) -> do
    637:648:void updateHBAOSettings() -> else
    650:658:void initAA() -> goto
    661:782:void resize(int,int) -> if
    786:788:void release() -> do
    793:795:void init() -> long
    800:802:void setSSR(int) -> do
nidefawl.qubes.render.FinalRenderer$1 -> llL1ll1LllJill1L:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    433:437:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$2 -> JiiJllL1IjlljIll:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    445:448:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$3 -> iJ1LlliJ1LL1IjjI:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    454:457:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$4 -> L1Ij1LIjiJIj1L1L:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    463:466:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$5 -> L1JiIjiJiJ1LL1:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    473:476:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$6 -> jI1LIjL1iJL1L1iJ:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    483:485:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$7 -> iJlliJjIiJllL1L1:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    496:498:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.LightCompute -> IjiJL1L1llJi1Lll:
    nidefawl.qubes.shader.Shader shaderComputerLight -> do
    int[] lightTiles -> do
    int maxLights -> do
    int lightFloatSize -> if
    nidefawl.qubes.shader.ShaderBuffer lights -> do
    int lightTilesTex -> for
    boolean startup -> if
    int[] debugResults -> if
    int numLights -> int
    48:69:void initShaders() -> new
    75:81:void init() -> try
    84:94:void resize(int,int) -> do
    97:121:void updateLights(nidefawl.qubes.world.WorldClient,float) -> do
    123:151:void render(nidefawl.qubes.world.WorldClient,float,int) -> do
    155:242:void renderDebug() -> byte
    245:245:int getTexture() -> do
nidefawl.qubes.render.ShadowRenderer -> L11LjIlllliJIjJi:
    nidefawl.qubes.shader.Shader shadowShader -> do
    boolean startup -> if
    int renderMode -> do
    int SHADOW_BUFFER_SIZE -> if
    java.lang.String[] shaderNames -> do
    nidefawl.qubes.gl.FrameBuffer fbShadow -> do
    45:77:void initShaders() -> new
    81:83:void init() -> try
    88:131:void renderMultiPass(nidefawl.qubes.world.World,float) -> do
    136:172:void renderMultiPassTextured(nidefawl.qubes.world.World,float) -> if
    175:180:void renderShadowPass(nidefawl.qubes.world.World,float) -> for
    183:190:void resize(int,int) -> do
    193:193:int getDepthTex() -> do
    197:197:int getDebugTexture() -> if
    201:201:float getTextureSize() -> do
nidefawl.qubes.render.ShadowRenderer$1 -> iJJiiJJiJiIjJiL1:
    nidefawl.qubes.render.ShadowRenderer this$0 -> do
    51:54:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.WorldRenderer -> JillL1iJIjIj1LjI:
    nidefawl.qubes.vec.Vector3f skyColor -> do
    nidefawl.qubes.vec.Vector3f fogColor -> if
    java.util.HashMap debugBBs -> do
    int rendered -> do
    boolean startup -> if
    int texWaterNoise -> if
    nidefawl.qubes.shader.Shader terrainShader -> do
    nidefawl.qubes.shader.Shader terrainShaderFar -> if
    nidefawl.qubes.shader.Shader skyShader -> for
    nidefawl.qubes.shader.Shader waterShader -> int
    nidefawl.qubes.shader.Shader shaderModelVoxel -> new
    nidefawl.qubes.shader.Shader shaderModelQ -> try
    nidefawl.qubes.shader.Shader shaderModelfirstPerson -> byte
    nidefawl.qubes.gl.TesselatorState skybox1 -> do
    nidefawl.qubes.gl.TesselatorState skybox2 -> if
    nidefawl.qubes.shader.Shader shaderZPre -> case
    nidefawl.qubes.models.voxel.ModelVox vox -> do
    nidefawl.qubes.models.qmodel.ModelRigged qmodel -> do
    int idx -> for
    nidefawl.qubes.vec.Vector3f mPos -> for
    float modelRot -> do
    float lastModelRot -> if
    51:61:java.lang.String getPassName(int) -> do
    95:166:void initShaders() -> new
    169:247:void reloadModel() -> try
    251:287:void init() -> byte
    293:354:void renderWorld(nidefawl.qubes.world.World,float) -> do
    397:398:void renderModelsUsingProgram(nidefawl.qubes.world.World,nidefawl.qubes.shader.Shader,int,float) -> do
    407:473:void renderQModels(nidefawl.qubes.world.World,nidefawl.qubes.shader.Shader,int,float) -> if
    479:486:void renderTransparent(nidefawl.qubes.world.World,float) -> if
    489:552:void renderFirstPerson(nidefawl.qubes.world.World,float) -> for
    555:574:void renderNormals(nidefawl.qubes.world.World,float) -> int
    577:590:void renderTerrainWireFrame(nidefawl.qubes.world.World,float) -> new
    597:644:void renderDebugBB(nidefawl.qubes.world.World,float) -> try
    647:718:void resize(int,int) -> do
    727:728:void setModelPos(float,float,float) -> do
    731:737:void tickUpdate() -> case
nidefawl.qubes.render.WorldRenderer$1 -> iJiJiJlliJ1LIj1L:
    nidefawl.qubes.render.WorldRenderer this$0 -> do
    102:105:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.WorldRenderer$2 -> iJ1LiJJiL1JiJi1L:
    nidefawl.qubes.render.WorldRenderer this$0 -> do
    114:117:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.WorldRenderer$3 -> jI1LIjjIIjL1jI1L:
    nidefawl.qubes.render.WorldRenderer this$0 -> do
    173:173:boolean accept(java.io.File) -> accept
nidefawl.qubes.render.gui.SingleBlockDraw -> JiIjJiJi1LllL1Ij:
    int vbo -> do
    int vboIndices -> if
    nidefawl.qubes.gl.ReallocIntBuffer vboBuf -> do
    nidefawl.qubes.gl.ReallocIntBuffer vboIdxBuf -> if
    nidefawl.qubes.gl.BufferedMatrix modelMatrix -> do
    nidefawl.qubes.gl.BufferedMatrix projMatrix -> if
    float x -> do
    float y -> if
    float z -> for
    float scale -> int
    float rotX -> new
    float rotY -> try
    float rotZ -> byte
    54:61:void init() -> do
    67:108:void drawBlockDefault(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    110:123:void drawBlock(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> if
    126:152:void doRender(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> for
    159:162:void setOffset(float,float,float) -> do
    168:169:void setScale(float) -> do
    178:181:void setRotation(float,float,float) -> if
nidefawl.qubes.render.gui.SingleBlockRenderAtlas -> ll1LIjiJll1LL1Ji:
    nidefawl.qubes.render.gui.SingleBlockRenderAtlas instance -> do
    byte[] defaultData -> do
    nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas[] textures -> do
    java.util.Map map -> do
    boolean rendering -> do
    63:63:float getTexW() -> do
    66:66:float getX(int) -> do
    69:69:float getY(int) -> if
    72:72:int getXPx(int) -> do
    75:75:int getYPx(int) -> if
    81:94:nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas getFirstFreeTextureAtlas() -> do
    100:100:nidefawl.qubes.render.gui.SingleBlockRenderAtlas getInstance() -> do
    107:112:boolean needsRender(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    117:125:nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas getAtlas(int,boolean) -> do
    129:149:void preRender(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData,nidefawl.qubes.gl.BufferedMatrix,nidefawl.qubes.gl.BufferedMatrix) -> do
    153:158:void postRender() -> do
    162:162:void init() -> if
    166:174:void setupTextureAtlas(nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas) -> do
    177:185:void reset() -> for
    190:195:int getTexture(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    199:204:int getTextureIdx(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> if
nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas -> lljI1L1LjIjI1LiJ:
    int[] hashes -> do
    int idx -> do
    nidefawl.qubes.gl.FrameBuffer frameBuffer -> do
    47:56:int getTextureIdx(int) -> do
    59:59:boolean hasFree() -> do
nidefawl.qubes.render.gui.SingleBlockRenderer -> llIjjI1LiJllJiL1:
    nidefawl.qubes.vec.BlockPos offset -> do
    nidefawl.qubes.util.SingleBlockWorld singleBlockWorld -> do
    nidefawl.qubes.gl.VertexBuffer singleBlockBuffer -> do
    32:46:nidefawl.qubes.gl.VertexBuffer renderSingleBlock(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    51:52:void putBuffer(nidefawl.qubes.block.Block,int) -> do
    54:55:void putSingleVert(nidefawl.qubes.block.Block,int,int) -> do
    57:58:void incVertCount(nidefawl.qubes.block.Block,int,int) -> if
    61:62:void putTriIndex(nidefawl.qubes.block.Block,int,int[]) -> do
nidefawl.qubes.render.post.HBAOPlus -> nidefawl.qubes.render.post.HBAOPlus:
    boolean hasContext -> hasContext
    void createContext(int,int) -> createContext
    void deleteContext() -> deleteContext
    void renderAO() -> renderAO
    void setProjMatrix(long) -> setProjMatrix
    void setViewMatrix(long) -> setViewMatrix
    void setOutputFBO(int) -> setOutputFBO
    void setDepthTex(int) -> setDepthTex
    void setRenderMask(int) -> setRenderMask
    void setNormalTex(int) -> setNormalTex
    void setBias(float) -> setBias
    void setNormalDecodeScaleBias(float,float) -> setNormalDecodeScaleBias
    void setRadius(float) -> setRadius
    void setDetailAO(float) -> setDetailAO
    void setCoarseAO(float) -> setCoarseAO
    void setPowerExponent(float) -> setPowerExponent
    void setDepthStorage(int) -> setDepthStorage
    void setDepthClampMode(int) -> setDepthClampMode
    void setDepthThreshold(boolean,float,float) -> setDepthThreshold
    void setBlur(boolean,int,float) -> setBlur
    void setBlurSharpen(boolean,float,float,float) -> setBlurSharpen
    void debugControl(int) -> debugControl
    java.lang.String[] getCallStack() -> getCallStack
nidefawl.qubes.render.post.SMAA -> L1iJiJIjjIllJiJi:
    nidefawl.qubes.util.SimpleResourceManager mgr -> do
    nidefawl.qubes.shader.Shader shaderAAEdge -> do
    nidefawl.qubes.shader.Shader shaderAABlendWeight -> if
    nidefawl.qubes.shader.Shader shaderAANeighborBlend -> for
    nidefawl.qubes.gl.FrameBuffer fbAAEdge -> do
    nidefawl.qubes.gl.FrameBuffer fbAAWeightBlend -> if
    int areaTex -> do
    int searchTex -> if
    java.lang.String[] qualDefines -> do
    java.lang.String[] qualDesc -> if
    91:108:void init(int,int) -> do
    112:145:int makeAATexture(byte[],int,int,int,int,int) -> do
    149:151:void releaseAll(nidefawl.qubes.util.EResourceType) -> do
    158:219:void render(int,int) -> if
nidefawl.qubes.render.post.SMAA$1 -> llIjJiiJiJIjIjjI:
    int val$quality -> do
    nidefawl.qubes.render.post.SMAA this$0 -> do
    58:61:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.region.MeshedRegion -> iJIjIjllL1IjJi:
    int[] vertexCount -> do
    int[] elementCount -> if
    boolean[] hasPass -> do
    int rX -> do
    int rZ -> if
    int rY -> for
    boolean xNeg -> do
    boolean xPos -> if
    boolean zPos -> for
    boolean zNeg -> int
    nidefawl.qubes.vec.AABBInt aabb -> do
    int[] frustumStates -> for
    boolean needsUpdate -> new
    boolean isUpdating -> try
    boolean isRenderable -> byte
    boolean isValid -> case
    int failedCached -> int
    boolean hasAnyPass -> char
    int[] vbo -> int
    int[] vboIndices -> new
    int shadowDrawMode -> else
    boolean frustumStateChanged -> else
    int occlusionQueryState -> new
    int occlusionResult -> try
    int occlFrameSkips -> byte
    int distance -> case
    nidefawl.qubes.vec.Vector3f queryPos -> do
    long totalBytes -> do
    long[] alloc -> do
    long[] totalBytesPass -> if
    int nextBuffer -> char
    90:111:void renderRegion(float,int,int,int) -> do
    203:221:void preUploadBuffers() -> do
    227:268:void uploadBuffer(int,nidefawl.qubes.gl.VertexBuffer,int) -> do
    272:287:void release() -> if
    290:290:int getNumVertices(int) -> do
    294:294:boolean hasPass(int) -> do
    298:309:void updateBB() -> for
    313:313:java.lang.String toString() -> toString
    319:319:boolean hasAnyPass() -> do
nidefawl.qubes.render.region.RegionRenderer -> iJJi1LiJIjJi1LIj:
    int RENDER_DISTANCE -> do
    int OFFS_OVER -> if
    int LENGTH_OVER -> for
    int HEIGHT_SLICES -> int
    java.util.Comparator compareUpdateRenderers -> do
    java.util.Comparator compareRenderers -> if
    int rendered -> new
    int occlCulled -> try
    int renderChunkX -> byte
    int renderChunkY -> case
    int renderChunkZ -> char
    java.util.ArrayList renderList -> if
    java.util.ArrayList shadowRenderList -> for
    java.util.ArrayList regionsToUpdate -> int
    boolean needsSortingUpdateRenderers -> if
    int[] occlQueries -> do
    nidefawl.qubes.render.region.MeshedRegion[] occlQueriesRunning -> do
    int queriesRunning -> else
    nidefawl.qubes.shader.Shader occlQueryShader -> do
    boolean startup -> for
    float camX -> do
    float camY -> if
    float camZ -> for
    nidefawl.qubes.render.region.MeshedRegion[][] regions -> do
    int drawMode -> goto
    int drawInstances -> long
    int numV -> this
    nidefawl.qubes.gl.ReallocIntBuffer[] buffers -> do
    nidefawl.qubes.gl.ReallocIntBuffer[] idxShortBuffers -> if
    java.util.ArrayList justrendered -> do
    114:118:void init() -> new
    122:139:void initShaders() -> try
    142:156:nidefawl.qubes.render.region.MeshedRegion[][] create() -> do
    160:203:void reposition(int,int) -> if
    206:217:nidefawl.qubes.render.region.MeshedRegion getByChunkCoord(int,int,int) -> do
    220:226:nidefawl.qubes.render.region.MeshedRegion getByRegionCoord(int,int,int) -> if
    230:246:void resetAll() -> byte
    249:253:void setRenderDistance(int) -> do
    256:281:void reRender() -> case
    285:302:void flagBlock(int,int,int) -> do
    305:318:void flagChunk(int,int) -> do
    321:322:void setDrawMode(int) -> if
    329:344:void renderMainPost(nidefawl.qubes.world.World,float,nidefawl.qubes.render.WorldRenderer) -> do
    346:414:void renderMainPre(nidefawl.qubes.world.World,float,nidefawl.qubes.render.WorldRenderer) -> if
    417:489:void renderMain(nidefawl.qubes.world.World,float,nidefawl.qubes.render.WorldRenderer) -> for
    491:510:void renderRegions(nidefawl.qubes.world.World,float,int,int,int) -> do
    513:516:void flushRegions() -> char
    518:519:void putRegion(nidefawl.qubes.render.region.MeshedRegion) -> do
    524:651:void update(nidefawl.qubes.world.WorldClient,float,float,float,int,int,float) -> do
    656:675:void updateFrustum(nidefawl.qubes.render.region.MeshedRegion) -> if
    677:698:void tickUpdate() -> else
    701:705:void sortUpdateRenderers() -> goto
    709:710:void sortRenderers() -> long
    715:721:int sortUpdateRenderersCompare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> do
    727:733:int sortRenderersCompare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> if
nidefawl.qubes.render.region.RegionRenderer$1 -> L1iJJiL1jIjIJiIj:
    nidefawl.qubes.render.region.RegionRenderer this$0 -> do
    50:50:int compare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> do
    47:47:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.render.region.RegionRenderer$2 -> L1L1L1JiL1jIL1Ji:
    nidefawl.qubes.render.region.RegionRenderer this$0 -> do
    56:56:int compare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> do
    53:53:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.server.GameServer -> L1L1JiJiiJiJiJiJ:
    nidefawl.qubes.config.ServerConfig config -> do
    nidefawl.qubes.server.commands.CommandHandler commands -> do
    nidefawl.qubes.network.server.NetworkServer networkServer -> do
    boolean running -> do
    boolean finished -> if
    nidefawl.qubes.world.WorldServer[] worlds -> do
    java.util.HashMap worldsMap -> do
    long lastTick -> do
    long lastSaveTick -> if
    int lastSaveStep -> do
    nidefawl.qubes.util.GameError reportedException -> do
    int nextWorldID -> if
    java.util.concurrent.ConcurrentLinkedQueue commandQueue -> do
    nidefawl.qubes.server.PlayerManager playerManager -> do
    nidefawl.qubes.chat.ChannelManager channelManager -> do
    54:73:void run() -> run
    76:127:void load() -> for
    130:130:int getNextWorldID() -> do
    134:173:void loop() -> do
    175:182:void resyncTime() -> int
    185:193:void updateTick() -> new
    195:201:void saveAndUnloadData() -> try
    204:204:boolean isRunning() -> do
    211:236:void onShutdown() -> byte
    240:248:void loadConfig() -> if
    251:251:nidefawl.qubes.config.ServerConfig getConfig() -> do
    255:255:nidefawl.qubes.server.commands.CommandHandler getCommandHandler() -> do
    260:261:void setException(nidefawl.qubes.util.GameError) -> do
    264:264:nidefawl.qubes.server.PlayerManager getPlayerManager() -> do
    268:268:nidefawl.qubes.world.WorldServer getWorld(java.util.UUID) -> do
    272:272:nidefawl.qubes.world.WorldServer getSpawnWorld() -> do
    280:287:void save(boolean) -> do
    294:294:nidefawl.qubes.world.WorldServer[] getWorlds() -> do
    302:302:nidefawl.qubes.chat.ChannelManager getChatChannelMgr() -> do
    306:306:long getServerTime() -> do
nidefawl.qubes.server.GameServer$1 -> jIiJL1iJIjIjlljI:
    nidefawl.qubes.server.GameServer this$0 -> do
    89:89:boolean accept(java.io.File) -> accept
nidefawl.qubes.server.PlayerChunkTracker -> ll1LL1JiL1JiiJJi:
    java.util.Map map -> do
    java.util.Set flaggedInstances -> do
    nidefawl.qubes.world.WorldServer worldServer -> do
    int ticksLastCheck -> do
    java.util.List blocksToSend -> do
    nidefawl.qubes.vec.BlockBoundingBox box2 -> do
    154:191:void update(nidefawl.qubes.entity.PlayerServer) -> do
    201:204:void trackPlayerChunk(nidefawl.qubes.entity.PlayerServer,int,int) -> do
    214:228:void untrackPlayerChunk(nidefawl.qubes.entity.PlayerServer,int,int) -> if
    236:246:void removePlayer(nidefawl.qubes.entity.PlayerServer) -> if
    254:273:void addPlayer(nidefawl.qubes.entity.PlayerServer) -> for
    284:291:nidefawl.qubes.server.PlayerChunkTracker$Entry getEntry(int,int,boolean) -> do
    302:310:void flagBlock(int,int,int) -> do
    322:386:void sendBlockChanges() -> do
    393:398:nidefawl.qubes.network.server.ServerHandlerPlay[] getHandlerArr(nidefawl.qubes.server.PlayerChunkTracker$Entry) -> do
    418:426:boolean isRequired(int,int) -> do
    433:444:void recheckIfRequiredChunksLoaded(boolean) -> do
    454:464:void flagLights(int,int,nidefawl.qubes.vec.BlockBoundingBox) -> do
    481:489:void flagLights(int,int,int,int,int,int,int,int) -> do
nidefawl.qubes.server.PlayerChunkTracker$Entry -> JiL1L11LL1jIL1:
    int x -> do
    int z -> if
    java.util.List players -> do
    long hash -> do
    boolean wholeChunkUpdate -> do
    java.util.Set flaggedBlocks -> do
    nidefawl.qubes.vec.BlockBoundingBox flaggedLights -> do
    boolean hasFlaggedLights -> if
    76:77:void addPlayer(nidefawl.qubes.entity.PlayerServer) -> do
    85:86:void removePlayer(nidefawl.qubes.entity.PlayerServer) -> if
    94:94:boolean isEmpty() -> do
    119:124:void flag(int,int,int) -> do
nidefawl.qubes.server.PlayerEntityTracker -> L1iJ1LL1llJi1L1L:
    java.util.Map map -> do
    nidefawl.qubes.entity.PlayerServer player -> do
    52:53:void leaveWorld() -> do
    57:65:void joinWorld(nidefawl.qubes.world.WorldServer) -> do
    68:95:void update() -> if
    98:110:void track(nidefawl.qubes.entity.Entity) -> do
    118:127:nidefawl.qubes.network.packet.PacketSEntityTrack getPacket(nidefawl.qubes.server.PlayerEntityTracker$Entry) -> do
    130:140:void untrack(nidefawl.qubes.entity.Entity) -> if
nidefawl.qubes.server.PlayerEntityTracker$Entry -> ll1L1L1LjIjIJi1L:
    nidefawl.qubes.entity.Entity entity -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    float yawBodyOffset -> for
nidefawl.qubes.server.PlayerManager -> iJJiJiiJL1L1llJi:
    java.io.File directory -> do
    java.util.Map players -> do
    java.util.Map playersLowerCase -> if
    nidefawl.qubes.entity.PlayerServer[] serverPlayers -> do
    nidefawl.qubes.server.GameServer server -> do
    37:38:void init() -> do
    40:40:java.io.File getPlayerFile(java.lang.String) -> do
    44:57:nidefawl.qubes.player.PlayerData loadPlayer(java.lang.String) -> do
    61:68:void savePlayer(java.lang.String,nidefawl.qubes.player.PlayerData) -> do
    71:97:nidefawl.qubes.entity.PlayerServer addPlayer(java.lang.String) -> do
    101:106:void removePlayer(nidefawl.qubes.entity.PlayerServer) -> do
    109:120:void savePlayers() -> if
    122:122:nidefawl.qubes.entity.PlayerServer getPlayer(java.lang.String) -> if
    148:156:void updateTick() -> for
nidefawl.qubes.server.commands.Command -> lljIlllllliJjIL1:
    java.util.HashSet aliases -> do
    java.lang.String name -> do
    22:22:boolean matches(java.lang.String,java.lang.String[],java.lang.String) -> do
    26:26:void testPermission(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> do
    void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
    31:31:java.lang.String getName() -> do
    35:35:boolean runSynchronized() -> do
nidefawl.qubes.server.commands.CommandException -> jIL1L1iJIjJillll:
nidefawl.qubes.server.commands.CommandHandler -> iJJiL1IjiJJijIL1:
    java.util.HashSet commands -> do
    35:45:void handle(nidefawl.qubes.server.commands.ICommandSource,java.lang.String) -> do
    49:62:void executeCommand(nidefawl.qubes.server.commands.ICommandSource,nidefawl.qubes.server.commands.Command,java.lang.String,java.lang.String[],java.lang.String) -> do
nidefawl.qubes.server.commands.ICommandSource -> iJJillIjiJllL1Ij:
    void preExecuteCommand(nidefawl.qubes.server.commands.Command) -> do
    void onUnknownCommand(java.lang.String,java.lang.String) -> if
    nidefawl.qubes.server.GameServer getServer() -> do
    void onError(nidefawl.qubes.server.commands.Command,nidefawl.qubes.server.commands.CommandException) -> do
nidefawl.qubes.server.commands.PreparedCommand -> llL1L1IjJiiJJill:
    nidefawl.qubes.server.commands.ICommandSource source -> do
    nidefawl.qubes.server.commands.Command c -> do
    java.lang.String cmd -> do
    java.lang.String[] args -> do
    java.lang.String line -> if
    20:28:void run() -> do
nidefawl.qubes.server.compress.CompressChunks -> lljIJiiJllllL1Ji:
    java.util.Collection chunks -> do
    int worldid -> do
    int[][] coords -> do
    nidefawl.qubes.network.server.ServerHandlerPlay[] handlers -> do
    boolean hasLight -> do
    29:33:void shortToByteArray(short[],byte[],int) -> do
    37:109:int fill(byte[]) -> do
    114:138:void finish(byte[]) -> do
    143:160:boolean isValid() -> do
nidefawl.qubes.server.compress.CompressLight -> JiJiiJllL1iJIjjI:
    nidefawl.qubes.chunk.Chunk chunks -> do
    int worldid -> do
    int chunkLen -> if
    nidefawl.qubes.network.server.ServerHandlerPlay[] handlers -> do
    int coordZ -> for
    int coordX -> int
    nidefawl.qubes.vec.BlockBoundingBox box -> do
    29:36:int fill(byte[]) -> do
    41:64:void finish(byte[]) -> do
    69:86:boolean isValid() -> do
nidefawl.qubes.server.compress.CompressThread -> Ijll1LllL1L1llIj:
    java.lang.Thread thread -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    nidefawl.qubes.server.GameServer server -> do
    19:47:void run() -> run
    50:54:void startNewThread(nidefawl.qubes.server.GameServer) -> do
    57:58:void submit(nidefawl.qubes.server.compress.ICompressTask) -> do
nidefawl.qubes.server.compress.ICompressTask -> L1IjJiiJlliJL1ll:
    int fill(byte[]) -> do
    void finish(byte[]) -> do
    boolean isValid() -> do
nidefawl.qubes.shader.AbstractUniform -> IjllJijIllIjlliJ:
    java.lang.String name -> do
    int loc -> do
    boolean first -> do
    13:13:boolean validLoc() -> do
    18:18:void release() -> do
nidefawl.qubes.shader.IShaderDef -> JiiJlljIL1IjJi1L:
    java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.shader.Shader -> iJIjIjiJiJL1JiL1:
    int SHADERS -> do
    int fragShader -> if
    int vertShader -> for
    int geometryShader -> int
    int computeShader -> new
    int shader -> try
    java.lang.String name -> do
    java.util.HashMap locations -> do
    java.util.HashMap uniforms -> if
    java.util.HashMap missinglocations -> for
    boolean valid -> do
    java.util.HashMap map -> int
    java.nio.IntBuffer buf -> do
    int lastBoundShader -> byte
    37:38:void incUniformCalls() -> do
    42:57:int getUniformLocation(java.lang.String) -> do
    67:67:java.lang.String getName() -> do
    74:231:void load(nidefawl.qubes.assets.AssetManager,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    241:261:void linkProgram() -> if
    264:266:int getStatus(int,int) -> do
    270:278:java.lang.String getLog(int,int) -> do
    281:293:void enable() -> for
    296:299:void disable() -> int
    301:341:void release() -> long
    344:348:void setProgramUniform1i(java.lang.String,int) -> do
    357:361:void setProgramUniform2f(java.lang.String,float,float) -> do
    363:367:void setProgramUniform1f(java.lang.String,float) -> do
    369:373:void setProgramUniform3f(java.lang.String,float,float,float) -> do
    375:389:nidefawl.qubes.shader.AbstractUniform getUniform(java.lang.String,java.lang.Class) -> do
    393:397:void setProgramUniform4f(java.lang.String,float,float,float,float) -> do
    409:413:void setProgramUniformMatrix4(java.lang.String,boolean,java.nio.FloatBuffer,boolean) -> do
    439:439:nidefawl.qubes.util.EResourceType getType() -> do
nidefawl.qubes.shader.ShaderBuffer -> iJJiJiIjIjL1L1L1:
    java.util.List buffers -> do
    int nextIdx -> do
    java.lang.String name -> do
    int buffer -> for
    int len -> if
    int bindingPoint -> int
    java.util.List shaders -> if
    java.nio.ByteBuffer buf -> if
    java.nio.FloatBuffer bufFloat -> do
    java.nio.IntBuffer bufInt -> do
    java.nio.ByteBuffer readbuf -> do
    46:47:nidefawl.qubes.shader.ShaderBuffer setSize(int) -> do
    50:70:void update() -> do
    72:87:void setup() -> if
    90:97:void rebindShaders() -> for
    100:113:void bindBuffers(nidefawl.qubes.shader.Shader) -> do
    119:127:void addShader(nidefawl.qubes.shader.Shader) -> if
    129:129:java.nio.FloatBuffer getFloatBuffer() -> do
    137:154:java.nio.ByteBuffer map(boolean) -> do
    158:159:void unmap() -> int
    161:162:void unbind() -> new
    164:165:void bind() -> try
nidefawl.qubes.shader.ShaderCompileError -> llJi1LiJjIllll1L:
    java.lang.String name -> do
    java.lang.String log -> if
    nidefawl.qubes.shader.ShaderSource code -> do
    nidefawl.qubes.shader.Shader shader -> do
    34:34:java.lang.String getName() -> do
    38:38:java.lang.String getLog() -> if
    46:46:nidefawl.qubes.shader.ShaderSource getShaderSource() -> do
nidefawl.qubes.shader.ShaderSource -> JiL11LiJ1LIjIjJi:
    java.util.regex.Pattern patternInclude -> do
    java.util.regex.Pattern patternDefine -> if
    java.util.regex.Pattern patternAttr -> for
    java.util.regex.Pattern lineErrorAMD -> int
    java.util.regex.Pattern lineErrorNVIDIA -> new
    java.util.HashMap sources -> do
    java.util.HashMap sourceNames -> if
    java.lang.String processed -> do
    int nInclude -> do
    java.lang.String attrTypes -> if
    nidefawl.qubes.shader.Shader shader -> do
    41:42:void load(nidefawl.qubes.assets.AssetManager,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    44:149:java.lang.String readParse(nidefawl.qubes.assets.AssetManager,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef,boolean) -> do
    157:187:java.lang.String getGlobalDef(java.lang.String) -> if
    190:190:boolean isEmpty() -> do
    193:193:java.lang.String getSource() -> do
    196:234:java.lang.String decorateErrors(java.lang.String) -> do
    237:237:java.lang.String getAttrTypes() -> if
nidefawl.qubes.shader.Shaders -> jIIjjIlliJL1jIJi:
    nidefawl.qubes.util.SimpleResourceManager shaders -> do
    nidefawl.qubes.util.SimpleResourceManager newshaders -> if
    boolean startup -> do
    nidefawl.qubes.shader.Shader depthBufShader -> do
    nidefawl.qubes.shader.Shader normals -> if
    nidefawl.qubes.shader.Shader wireframe -> for
    nidefawl.qubes.shader.Shader textured -> int
    nidefawl.qubes.shader.Shader colored -> new
    nidefawl.qubes.shader.Shader colored3D -> try
    nidefawl.qubes.shader.Shader textured3D -> byte
    nidefawl.qubes.shader.Shader renderUINT -> case
    nidefawl.qubes.shader.Shader singleblock -> char
    nidefawl.qubes.shader.Shader gui -> else
    nidefawl.qubes.shader.Shader item -> goto
    nidefawl.qubes.shader.Shader tonemap -> long
    17:23:void reinit() -> do
    26:34:void init() -> if
    51:116:void initShaders() -> for
nidefawl.qubes.shader.Uniform1f -> lljIIj1LL1:
    float lastX -> do
    14:19:boolean set(float) -> do
    24:28:boolean set() -> if
nidefawl.qubes.shader.Uniform1i -> L1iJJiJi1L1L1LL1:
    int lastX -> if
    14:21:boolean set(int) -> do
    26:30:boolean set() -> if
nidefawl.qubes.shader.Uniform2f -> Ij1L1LL1jIll1LIj:
    float lastX -> do
    float lastY -> if
    15:23:boolean set(float,float) -> do
    28:32:boolean set() -> if
nidefawl.qubes.shader.Uniform3f -> L1IjJijIIjiJJiIj:
    float lastX -> do
    float lastY -> if
    float lastZ -> for
    18:27:boolean set(float,float,float) -> do
    32:36:boolean set() -> if
nidefawl.qubes.shader.Uniform4f -> JiiJllIjiJL1L1iJ:
    float lastX -> do
    float lastY -> if
    float lastZ -> for
    float lastW -> int
    17:27:boolean set(float,float,float,float) -> do
    32:36:boolean set() -> if
nidefawl.qubes.shader.UniformBuffer -> iJ1LIjJijIJijIJi:
    int nextIdx -> do
    nidefawl.qubes.shader.UniformBuffer[] buffers -> do
    java.lang.String name -> do
    int buffer -> for
    int len -> if
    java.nio.FloatBuffer floatBuffer -> do
    int bindingPoint -> int
    nidefawl.qubes.shader.UniformBuffer uboMatrix3D -> do
    nidefawl.qubes.shader.UniformBuffer uboMatrix2D -> if
    nidefawl.qubes.shader.UniformBuffer uboMatrixShadow -> for
    nidefawl.qubes.shader.UniformBuffer uboSceneData -> int
    nidefawl.qubes.shader.UniformBuffer LightInfo -> new
    nidefawl.qubes.shader.UniformBuffer VertexDirections -> try
    nidefawl.qubes.shader.UniformBuffer TBNMat -> byte
    java.util.List shaders -> do
    boolean once -> do
    39:40:nidefawl.qubes.shader.UniformBuffer addMat4() -> do
    43:44:nidefawl.qubes.shader.UniformBuffer addVec4() -> if
    47:48:nidefawl.qubes.shader.UniformBuffer addFloat() -> for
    51:52:void setPosition(int) -> do
    54:55:void reset() -> do
    57:58:void put(java.nio.FloatBuffer) -> do
    60:61:void put(float[]) -> do
    63:64:void put(float) -> do
    66:67:void skip() -> if
    70:74:void put(float,float,float) -> do
    76:77:void putNeg(float,float,float) -> if
    79:88:void update() -> for
    90:99:void setup() -> int
    139:144:void init() -> new
    146:147:void reinit() -> try
    150:157:void rebindShaders() -> byte
    160:173:void bindBuffers(nidefawl.qubes.shader.Shader) -> do
    180:188:void addShader(nidefawl.qubes.shader.Shader) -> if
    197:318:void updateUBO(nidefawl.qubes.world.WorldClient,float) -> do
    324:384:void updateTBNMatrices() -> else
    389:460:void updateVertDir() -> goto
    465:471:void updateOrtho() -> case
    474:477:void setNormalMat(java.nio.FloatBuffer) -> if
    485:491:void updatePxOffset() -> char
nidefawl.qubes.shader.UniformMat4 -> JiiJllL1lljIjI:
    float[] last -> do
    boolean transpose -> if
    java.nio.FloatBuffer buf -> do
    19:38:boolean set(java.nio.FloatBuffer,boolean) -> do
    56:60:void release() -> do
nidefawl.qubes.texture.ColorMap -> IjjIIjIjiJiJjIll:
    nidefawl.qubes.texture.ColorMap grass -> do
    nidefawl.qubes.texture.ColorMap foliage -> if
    int[] data -> do
    int w -> do
    32:45:void set(nidefawl.qubes.assets.AssetTexture) -> do
nidefawl.qubes.texture.PNGDecoder -> llIjL1IjjIll1LiJ:
    byte[] SIGNATURE -> do
    java.io.InputStream input -> do
    java.util.zip.CRC32 crc -> do
    byte[] buffer -> if
    int chunkLength -> do
    int chunkType -> if
    int chunkRemaining -> for
    int width -> int
    int height -> new
    int bitdepth -> try
    int colorType -> byte
    int bytesPerPixel -> case
    byte[] palette -> for
    byte[] paletteA -> int
    byte[] transPixel -> new
    boolean $assertionsDisabled -> do
    107:107:int getHeight() -> do
    111:111:int getWidth() -> if
    230:306:void decode(java.nio.ByteBuffer,int,nidefawl.qubes.texture.PNGDecoder$Format) -> do
    332:333:void copy(java.nio.ByteBuffer,byte[]) -> do
    336:355:void copyRGBtoABGR(java.nio.ByteBuffer,byte[]) -> if
    358:377:void copyRGBtoRGBA(java.nio.ByteBuffer,byte[]) -> for
    380:399:void copyRGBtoBGRA(java.nio.ByteBuffer,byte[]) -> int
    402:405:void copyRGBAtoABGR(java.nio.ByteBuffer,byte[]) -> new
    408:411:void copyRGBAtoBGRA(java.nio.ByteBuffer,byte[]) -> try
    414:417:void copyRGBAtoRGB(java.nio.ByteBuffer,byte[]) -> byte
    420:424:void copyGreyscaleToARGB(java.nio.ByteBuffer,byte[]) -> case
    427:446:void copyPALtoARGB(java.nio.ByteBuffer,byte[]) -> char
    449:452:void copyRGBAtoARGB(java.nio.ByteBuffer,byte[]) -> else
    454:473:void copyRGBtoARGB(java.nio.ByteBuffer,byte[]) -> goto
    476:495:void copyPALtoABGR(java.nio.ByteBuffer,byte[]) -> long
    498:517:void copyPALtoRGBA(java.nio.ByteBuffer,byte[]) -> this
    520:539:void copyPALtoBGRA(java.nio.ByteBuffer,byte[]) -> void
    542:549:void expand4(byte[],byte[]) -> do
    552:561:void expand2(byte[],byte[]) -> if
    564:577:void expand1(byte[],byte[]) -> for
    580:598:void unfilter(byte[],byte[]) -> int
    601:605:void unfilterSub(byte[]) -> do
    608:612:void unfilterUp(byte[],byte[]) -> new
    615:624:void unfilterAverage(byte[],byte[]) -> try
    627:647:void unfilterPaeth(byte[],byte[]) -> byte
    650:707:void readIHDR() -> do
    710:716:void readPLTE() -> if
    719:741:void readtRNS() -> for
    744:758:void closeChunk() -> int
    761:767:void openChunk() -> new
    770:774:void openChunk(int) -> do
    777:780:void checkChunkLength(int) -> if
    783:789:int readChunk(byte[],int,int) -> do
    793:799:void refillInflater(java.util.zip.Inflater) -> do
    802:823:void readChunkUnzip(java.util.zip.Inflater,byte[],int,int) -> do
    827:834:void readFully(byte[],int,int) -> do
    837:837:int readInt(byte[],int) -> do
    845:852:void skip(long) -> do
    855:860:boolean checkSignature(byte[]) -> do
nidefawl.qubes.texture.PNGDecoder$1 -> IjIjJi1L1LIjllJi:
    int[] $SwitchMap$nidefawl$qubes$texture$PNGDecoder$Format -> do
nidefawl.qubes.texture.PNGDecoder$Format -> jIIjL1L1IjJijIjI:
    nidefawl.qubes.texture.PNGDecoder$Format ALPHA -> do
    nidefawl.qubes.texture.PNGDecoder$Format LUMINANCE -> if
    nidefawl.qubes.texture.PNGDecoder$Format LUMINANCE_ALPHA -> for
    nidefawl.qubes.texture.PNGDecoder$Format RGB -> int
    nidefawl.qubes.texture.PNGDecoder$Format RGBA -> new
    nidefawl.qubes.texture.PNGDecoder$Format BGRA -> try
    nidefawl.qubes.texture.PNGDecoder$Format ABGR -> byte
    nidefawl.qubes.texture.PNGDecoder$Format ARGB -> case
    int numComponents -> do
    boolean hasAlpha -> do
    nidefawl.qubes.texture.PNGDecoder$Format[] $VALUES -> do
    14:14:nidefawl.qubes.texture.PNGDecoder$Format[] values() -> values
    14:14:nidefawl.qubes.texture.PNGDecoder$Format valueOf(java.lang.String) -> valueOf
nidefawl.qubes.texture.TMgr -> Jillll1LIj1LIj1L:
    11:11:int getNoise() -> do
    15:15:int getBlocks() -> if
    19:19:int getItems() -> for
    27:27:int getEmpty() -> int
    39:39:int getNormals() -> new
nidefawl.qubes.texture.TextureManager -> L11LJiiJll1LJi:
    nidefawl.qubes.texture.TextureManager instance -> do
    int texNoise -> do
    int texEmpty -> if
    int texEmptyNormal -> for
    java.nio.ByteBuffer directBuf -> do
    int texEmptyWhite -> int
    39:39:nidefawl.qubes.texture.TextureManager getInstance() -> do
    44:55:void init() -> do
    58:67:void reload() -> if
    75:78:int makeNewTexture(byte[],int,int,boolean,boolean,int) -> do
    82:82:int makeNewTexture(nidefawl.qubes.assets.AssetTexture,boolean,boolean,int) -> do
    92:140:void uploadTexture(byte[],int,int,int,int,int,boolean,boolean,int) -> do
    147:147:void destroy() -> for
nidefawl.qubes.texture.TextureUtil -> iJL1jIjIJijIJi1L:
    13:20:byte[] genNoise(int) -> do
    165:183:int getAverageColor(byte[],int,int) -> do
    191:191:int clampRGB(int) -> do
    200:241:byte[] makeMipMap(byte[],int,int,int) -> do
    250:260:void clampAlpha(byte[],int,int) -> do
    263:275:byte[] toBytesRGBA(int[]) -> do
    279:288:int[] toIntRGBA(byte[]) -> do
    292:308:byte[] toBytesRGBA(java.awt.image.BufferedImage) -> do
    319:319:float getR(int) -> do
    322:322:float getG(int) -> if
    325:325:float getB(int) -> for
    329:342:int mixRGB(int,int,float) -> do
    346:363:int mix3RGB(int,int,int) -> do
nidefawl.qubes.texture.array.BlockNormalMapArray -> JiJilliJJiL1Ijll:
    nidefawl.qubes.texture.array.BlockNormalMapArray instance -> do
    27:27:nidefawl.qubes.texture.array.BlockNormalMapArray getInstance() -> do
    37:42:void findMaxTileWidth() -> do
    47:75:void collectTextures(nidefawl.qubes.assets.AssetManager) -> do
    78:137:void uploadTextures() -> if
    141:146:void upscaleTextures() -> for
    151:170:void postUpload() -> int
nidefawl.qubes.texture.array.BlockTextureArray -> IjiJL1L1iJjIjIIj:
    nidefawl.qubes.texture.array.BlockTextureArray instance -> do
    30:30:nidefawl.qubes.texture.array.BlockTextureArray getInstance() -> do
    38:56:void postUpload() -> int
    59:106:void uploadTextures() -> if
    110:115:void upscaleTextures() -> for
    118:145:void collectTextures(nidefawl.qubes.assets.AssetManager) -> do
nidefawl.qubes.texture.array.ItemTextureArray -> iJL1L1jI1LIjIj:
    nidefawl.qubes.texture.array.ItemTextureArray instance -> do
    30:30:nidefawl.qubes.texture.array.ItemTextureArray getInstance() -> do
    40:89:void uploadTextures() -> if
    94:99:void upscaleTextures() -> for
    102:129:void collectTextures(nidefawl.qubes.assets.AssetManager) -> do
    133:152:void postUpload() -> int
nidefawl.qubes.texture.array.TextureArray -> jIjIIjL1jIJiL1Ij:
    java.util.HashMap texNameToAssetMap -> do
    java.util.HashMap blockIDToAssetList -> if
    java.util.HashMap slotTextureMap -> for
    boolean firstInit -> do
    int[] textures -> do
    int glid -> do
    int tileSize -> if
    int numTextures -> for
    int numMipmaps -> int
    int subtypeBits -> new
    42:49:void unload() -> new
    51:52:void init() -> try
    56:87:void reload() -> byte
    91:94:void free() -> else
    102:108:java.nio.ByteBuffer put(java.nio.ByteBuffer,byte[]) -> do
    112:112:int getTextureIdx(int,int) -> do
    115:116:void setTexture(int,int,int) -> do
    121:127:void calculateSubtypeBits() -> case
    129:148:void findMaxTileWidth() -> do
    151:156:void upscaleTextures() -> for
    160:168:void initGLStorage() -> char
    void uploadTextures() -> if
    void collectTextures(nidefawl.qubes.assets.AssetManager) -> do
    void postUpload() -> int
nidefawl.qubes.util.BlockColl -> Ji1L1LL1iJllJiIj:
    int x -> do
    int y -> if
    int z -> for
    int type -> int
    nidefawl.qubes.vec.AABB blockBB -> do
nidefawl.qubes.util.ByteArrIO -> lliJllIjL1iJiJll:
    17:21:int writeInt(byte[],int,int) -> do
    24:26:int writeShort(byte[],int,int) -> if
    36:37:void write(byte[],int,int) -> if
    40:42:int readShort(byte[],int) -> do
    46:47:int readUnsignedByte(byte[],int) -> if
    56:60:int readInt(byte[],int) -> for
    69:70:void writeByte(byte[],int,int) -> do
nidefawl.qubes.util.CharSequenceIterator -> Ij1LJiIjL1lliJll:
    java.lang.CharSequence sequence -> do
    int pos -> do
    24:24:boolean hasNext() -> hasNext
    29:29:java.lang.Character next() -> do
    35:37:char nextChar() -> do
    42:42:void remove() -> remove
    12:12:java.lang.Object next() -> next
nidefawl.qubes.util.ClipboardHelper -> jIJill1LjIjIiJ1L:
    10:11:void setClipboardString(java.lang.String) -> do
    14:15:java.lang.String getClipboardString() -> do
nidefawl.qubes.util.CollisionQuery -> JilljIJiL1IjJiiJ:
    java.util.ArrayList collisions -> do
    java.util.ArrayList tempList -> if
    nidefawl.qubes.vec.AABBFloat[] tmpBBs -> do
    int numCollisions -> do
    nidefawl.qubes.vec.AABBFloat tmpBB -> do
    23:26:nidefawl.qubes.util.BlockColl get() -> do
    29:66:void query(nidefawl.qubes.world.World,nidefawl.qubes.vec.AABB) -> do
    69:69:int getNumCollisions() -> do
    72:72:nidefawl.qubes.util.BlockColl get(int) -> do
nidefawl.qubes.util.CrashInfo -> nidefawl.qubes.util.CrashInfo:
    java.lang.String title -> title
    java.lang.String desc -> desc
    java.lang.String outBuf -> outBuf
    java.lang.String errBuf -> errBuf
    java.lang.String exc -> exc
    40:42:void setLogBuf(java.lang.String) -> setLogBuf
    48:50:void setErrBuf(java.lang.String) -> setErrBuf
    56:61:void setException(java.lang.Throwable) -> setException
nidefawl.qubes.util.EResourceType -> llIjjIllll1LIj:
    nidefawl.qubes.util.EResourceType SHADER -> do
    nidefawl.qubes.util.EResourceType FRAMEBUFFER -> if
    nidefawl.qubes.util.EResourceType[] $VALUES -> do
    10:10:nidefawl.qubes.util.EResourceType[] values() -> values
    10:10:nidefawl.qubes.util.EResourceType valueOf(java.lang.String) -> valueOf
nidefawl.qubes.util.GameContext -> IjL1llL1L1iJIjiJ:
    java.lang.Thread mainThread -> do
    nidefawl.qubes.util.Side side -> do
    nidefawl.qubes.util.GameError initError -> do
    22:23:void setMainThread(java.lang.Thread) -> do
    31:31:java.lang.Thread getMainThread() -> do
    38:38:nidefawl.qubes.util.Side getSide() -> do
    42:44:void setSideAndPath(nidefawl.qubes.util.Side,java.lang.String) -> do
    51:60:void earlyInit() -> do
    66:66:nidefawl.qubes.util.GameError getInitError() -> do
    73:91:void lateInit() -> if
nidefawl.qubes.util.GameError -> iJ1LiJllIjjIiJL1:
nidefawl.qubes.util.GameMath -> IjJiiJIjllL1IjL1:
    float[] m -> do
    float[] inv -> if
    12:12:float cos(float) -> do
    15:15:float sin(float) -> if
    20:20:float atan(float) -> for
    25:25:float atan2(float,float) -> do
    39:40:int floor(double) -> do
    48:88:void invertMat4x(java.nio.FloatBuffer,java.nio.FloatBuffer) -> do
    117:117:float coTangent(float) -> int
    121:121:float degreesToRadians(float) -> new
    125:125:float sqrtf(float) -> try
    129:132:int randomI(long) -> do
    135:135:int lhToZ(long) -> if
    138:138:int lhToX(long) -> for
    141:141:long toLong(int,int) -> do
    144:146:double dist2d(double,double,double,double) -> do
    150:156:int log2(int) -> do
    159:159:int signum(float) -> do
    162:162:boolean isNormalFloat(float) -> do
    172:172:float clamp(float,float,float) -> do
    175:178:int distSq3Di(int,int,int,int,int,int) -> do
    194:213:float pow(float,int) -> do
    217:231:double getAngle(double,double,double,double) -> if
    234:234:float tan(float) -> byte
    239:239:float easeInOutCubic(float) -> case
nidefawl.qubes.util.Half -> JijIjI1LIjIjL1Ji:
    41:61:int fromFloat(float) -> do
nidefawl.qubes.util.IManagedResource -> iJllJijIL1llJi1L:
    void release() -> long
    nidefawl.qubes.util.EResourceType getType() -> do
nidefawl.qubes.util.IResourceManager -> iJ1LIj1LJiIjL11L:
    void addResource(nidefawl.qubes.util.IManagedResource) -> do
nidefawl.qubes.util.Project -> JiIjll1LlljIiJJi:
    float[] IDENTITY_MATRIX -> do
    java.nio.FloatBuffer finalMatrix -> do
    java.nio.FloatBuffer tempMatrix -> if
    float[] in -> if
    float[] out -> for
    nidefawl.qubes.vec.Vector3f tmp3 -> do
    nidefawl.qubes.vec.Vector3f tmp4 -> if
    nidefawl.qubes.vec.Vector3f tmp5 -> for
    45:78:boolean gluUnProject(float,float,float,java.nio.FloatBuffer,java.nio.FloatBuffer,java.nio.IntBuffer,java.nio.FloatBuffer) -> do
    90:155:boolean __gluInvertMatrixf(java.nio.FloatBuffer,java.nio.FloatBuffer) -> do
    162:165:void __gluMakeIdentityf(java.nio.FloatBuffer) -> do
    172:178:void __gluMultMatricesf(java.nio.FloatBuffer,java.nio.FloatBuffer,java.nio.FloatBuffer) -> do
    188:196:void __gluMultMatrixVecf(java.nio.FloatBuffer,float[],float[]) -> do
    199:210:void fovProjMat(float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    213:221:void orthoMat(float,float,float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    229:261:void lookAt(float,float,float,float,float,float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
nidefawl.qubes.util.RayTrace -> L1iJjI1LiJ1L1LiJ:
    nidefawl.qubes.vec.Vector3f dirFrac -> do
    nidefawl.qubes.vec.AABBFloat bb -> do
    nidefawl.qubes.util.RayTrace$RayTraceIntersection intersection -> do
    nidefawl.qubes.vec.BlockPos quarter -> do
    boolean quarterMode -> do
    41:42:void reset() -> do
    45:142:void doRaytrace(nidefawl.qubes.world.World,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,int) -> do
    146:173:boolean callback(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    185:185:float intbound(float,float) -> do
    190:190:boolean hasHit() -> do
    193:193:nidefawl.qubes.util.RayTrace$RayTraceIntersection getHit() -> do
    201:201:nidefawl.qubes.vec.AABBFloat getTempBB() -> do
    211:222:void setIntersection(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,float,int) -> do
nidefawl.qubes.util.RayTrace$HitType -> IjlliJjIJiJiJi1L:
    nidefawl.qubes.util.RayTrace$HitType BLOCK -> do
    nidefawl.qubes.util.RayTrace$HitType NONE -> if
    nidefawl.qubes.util.RayTrace$HitType[] $VALUES -> do
    13:13:nidefawl.qubes.util.RayTrace$HitType[] values() -> values
    13:13:nidefawl.qubes.util.RayTrace$HitType valueOf(java.lang.String) -> valueOf
nidefawl.qubes.util.RayTrace$RayTraceIntersection -> iJ1LJiL11Lll1LiJ:
    nidefawl.qubes.util.RayTrace$HitType hit -> do
    int blockId -> do
    nidefawl.qubes.vec.BlockPos blockPos -> do
    nidefawl.qubes.vec.BlockPos q -> if
    nidefawl.qubes.vec.Vector3f pos -> do
    float distance -> do
    int face -> if
nidefawl.qubes.util.RegionEntry -> IjJiIjjIllllllL1:
    void addKey(int) -> do
    int getMinX() -> do
    int getMinZ() -> if
    int getMaxX() -> for
    int getMaxZ() -> int
nidefawl.qubes.util.RegionMap -> JiiJjIL1L1Ij:
    com.google.common.collect.Multimap mmap -> do
    byte bits -> do
    int halfSize -> do
    23:23:int toRegion(int) -> do
    31:42:void add(nidefawl.qubes.util.RegionEntry) -> do
    68:68:int rkey(int,int) -> do
    88:99:java.util.Collection getRegions(int,int,int) -> do
nidefawl.qubes.util.RenderUtil -> jIiJJiIj1LIj1LJi:
    124:124:int packNormal(nidefawl.qubes.vec.Vector3f) -> do
    127:131:int packNormal(float,float,float) -> do
    134:134:int packTexCoord(float,float) -> do
nidefawl.qubes.util.Renderable -> L1Ijll1LllIjL1Ij:
    void render(float,double,double) -> do
    void initGui(boolean) -> do
nidefawl.qubes.util.ServerStats -> JijIL1ll1LiJjIL1:
    java.util.concurrent.ConcurrentHashMap map -> do
    15:20:void add(java.lang.String,long) -> do
nidefawl.qubes.util.Side -> iJ1LiJ1LiJjIll1L:
    nidefawl.qubes.util.Side CLIENT -> do
    nidefawl.qubes.util.Side SERVER -> if
    nidefawl.qubes.util.Side[] $VALUES -> do
    3:3:nidefawl.qubes.util.Side[] values() -> values
    3:3:nidefawl.qubes.util.Side valueOf(java.lang.String) -> valueOf
nidefawl.qubes.util.SimpleResourceManager -> JijIiJIjllL1L1jI:
    java.util.List resources -> do
    20:21:void addResource(nidefawl.qubes.util.IManagedResource) -> do
    25:28:void release() -> do
    32:38:void releaseAll(nidefawl.qubes.util.EResourceType) -> do
nidefawl.qubes.util.SingleBlockWorld -> llL1iJIjiJL1IjIj:
    int id -> do
    int data -> if
    nidefawl.qubes.vec.BlockPos pos -> do
    int airId -> for
    int airData -> int
    int light -> new
    nidefawl.qubes.chunk.blockdata.BlockData bdata -> do
    nidefawl.qubes.biome.Biome biome -> do
    32:35:void set(int,int,int,int,int) -> do
    47:50:int getType(int,int,int) -> if
    60:60:boolean is(int,int,int) -> do
    80:82:int getData(int,int,int) -> do
    87:90:boolean isNormalBlock(int,int,int,int) -> do
    95:95:boolean setTypeData(int,int,int,int,int,int) -> do
    100:100:int getLight(int,int,int) -> int
    105:105:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    112:113:void setBlockData(nidefawl.qubes.chunk.blockdata.BlockData) -> do
    129:129:int getBiomeFaceColor(int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    134:134:int getWater(int,int,int) -> for
nidefawl.qubes.util.SnakeIterator -> llIj1LjIIjJiIjjI:
    int dx -> do
    int dz -> if
    int currentFace -> for
    int pos -> int
    int legPos -> new
    int legsize -> try
    int currentLeg -> byte
    int max -> case
    int[][] direction -> do
    18:25:void reset() -> do
    31:49:void next() -> if
    53:53:int getX() -> do
    56:56:int getZ() -> if
nidefawl.qubes.util.Stats -> JijI1LJiIjJiIjiJ:
    int fpsCounter -> do
    int uniformCalls -> if
    float avgFrameTime -> do
    double timeMeshing -> do
    double timeRendering -> if
    double fpsInteval -> for
    int regionUpdates -> for
nidefawl.qubes.util.StringUtil -> lllliJ1LL1iJjIiJ:
    8:18:java.lang.String[] dropArrIdx(java.lang.String[],int) -> do
    23:26:long parseLong(java.lang.String,long,int) -> do
    32:34:java.util.UUID parseUUID(java.lang.String,java.util.UUID) -> do
    40:42:int parseInt(java.lang.String,int) -> do
nidefawl.qubes.util.SysInfo -> iJJi1LL1JiiJ1LL1:
    java.lang.String osName -> do
    boolean isWindows -> do
    boolean is64Bit -> if
    java.lang.String javaVersion -> if
    long memoryMb -> do
    java.lang.String javaMachineVersion -> for
    java.lang.String lwjglVersion -> int
    java.lang.String openGLVersion -> new
    java.lang.String openGLVendor -> try
nidefawl.qubes.util.Timer -> Ji1LJillL1L11Lll:
    int tickspersec -> if
    long ms -> for
    long ns -> int
    long last -> new
    int ticks -> do
    float partialTick -> do
    long el -> do
    long absTime -> if
    25:83:long getTime() -> do
    87:93:void calculate() -> do
nidefawl.qubes.util.TripletIntHash -> ll1LiJJi1LiJ:
    6:8:int toHash(int,int,int) -> do
    11:11:int getX(int) -> do
    14:14:int getZ(int) -> if
    17:17:int getY(int) -> for
nidefawl.qubes.util.TripletLongHash -> L1ll1L1LL1L1L11L:
    6:8:long toHash(long,long,long) -> do
    11:11:int getX(long) -> do
    14:14:int getZ(long) -> if
    17:17:int getY(long) -> for
nidefawl.qubes.util.TripletShortHash -> iJjIll1LL11LL1Ji:
    6:6:short toHash(int,int,int) -> do
    9:9:int getX(int) -> do
    12:12:int getZ(int) -> if
    15:15:int getY(int) -> for
nidefawl.qubes.vec.AABB -> llJijIiJllJiJi1L:
    double minX -> do
    double minY -> if
    double minZ -> for
    double maxX -> int
    double maxY -> new
    double maxZ -> try
    33:33:double getWidth() -> do
    36:36:double getHeight() -> if
    39:39:double getLength() -> for
    43:49:void offset(double,double,double) -> do
    52:64:void expandTo(double,double,double) -> if
    77:83:void set(double,double,double,double,double,double) -> do
    88:89:void set(nidefawl.qubes.vec.AABB) -> do
    92:93:void set(nidefawl.qubes.vec.AABBFloat) -> do
    97:97:double getCenterX() -> int
    105:105:double getCenterZ() -> new
    109:113:void centerXZ(double,double,double) -> for
    126:142:double getXOffset(nidefawl.qubes.vec.AABB,double) -> do
    146:162:double getZOffset(nidefawl.qubes.vec.AABB,double) -> if
    166:182:double getYOffset(nidefawl.qubes.vec.AABB,double) -> for
    187:187:java.lang.String toString() -> toString
    192:198:void read(java.io.DataInput) -> do
    202:208:void write(java.io.DataOutput) -> do
nidefawl.qubes.vec.AABBFloat -> iJjIiJIjL1llJiIj:
    float minX -> do
    float minY -> if
    float minZ -> for
    float maxX -> int
    float maxY -> new
    float maxZ -> try
    long negativeZeroFloatBits -> do
    35:41:void offset(float,float,float) -> do
    44:56:void expandBounds(float,float,float) -> if
    69:75:void set(float,float,float,float,float,float) -> do
    80:81:void set(nidefawl.qubes.vec.AABBFloat) -> do
    116:122:boolean intersects(nidefawl.qubes.vec.AABB) -> do
    128:128:java.lang.String toString() -> toString
    144:195:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    200:205:boolean min(float,float) -> do
    208:213:boolean max(float,float) -> if
nidefawl.qubes.vec.AABBInt -> jI1L1LL1llJijIJi:
    int minX -> do
    int minY -> if
    int minZ -> for
    int maxX -> int
    int maxY -> new
    int maxZ -> try
    70:76:void set(int,int,int,int,int,int) -> do
    81:82:void set(nidefawl.qubes.vec.AABBInt) -> do
    115:115:java.lang.String toString() -> toString
    119:126:nidefawl.qubes.nbt.Tag$Compound saveTag() -> do
    139:139:boolean contains(int,int,int) -> do
    143:143:boolean contains(nidefawl.qubes.vec.BlockPos) -> do
nidefawl.qubes.vec.BlockBoundingBox -> JillL11LjIIjL1jI:
    int lowX -> do
    int highX -> if
    int lowY -> for
    int highY -> int
    int lowZ -> new
    int highZ -> try
    30:32:void expandTo(int,int,int,int,int,int) -> do
    35:54:void flag(int,int,int) -> do
    62:64:void checkBounds(int,int,int) -> if
    67:73:void set(int,int,int,int,int,int) -> if
    76:77:nidefawl.qubes.vec.BlockBoundingBox copyTo(nidefawl.qubes.vec.BlockBoundingBox) -> do
    81:81:int getLength() -> do
    85:85:int getWidth() -> if
    89:89:int getHeight() -> for
    93:93:int getVolume() -> int
    112:113:void reset() -> do
    123:125:void extend(nidefawl.qubes.vec.BlockBoundingBox) -> do
    132:132:java.lang.String toString() -> toString
    139:139:short getMinHash() -> do
    145:145:short getMaxHash() -> if
    154:154:nidefawl.qubes.vec.BlockBoundingBox fromShorts(short,short) -> do
nidefawl.qubes.vec.BlockPos -> L1L1IjL1iJiJiJ1L:
    int x -> do
    int y -> if
    int z -> for
    24:24:java.lang.String toString() -> toString
    29:33:boolean equals(java.lang.Object) -> equals
    38:38:int hashCode() -> hashCode
    42:42:nidefawl.qubes.vec.BlockPos copy() -> do
    50:53:void set(int,int,int) -> do
    58:61:void offset(int) -> do
    64:67:void read(java.io.DataInput) -> do
    70:73:void write(java.io.DataOutput) -> do
    78:81:void set(nidefawl.qubes.vec.BlockPos) -> do
    86:86:int getVolume() -> do
    95:95:boolean isEqualTo(int,int,int) -> do
nidefawl.qubes.vec.Dir -> L1iJ1L1LllL11LL1:
    12:12:int getDirX(int) -> do
    16:16:int getDirZ(int) -> if
    20:20:int getDirY(int) -> for
    28:28:boolean isTopBottom(int) -> do
    53:67:java.lang.String asString(int) -> do
nidefawl.qubes.vec.Frustum -> iJJiJilliJiJiJL1:
    nidefawl.qubes.vec.Vector4f[] frustum -> do
    nidefawl.qubes.vec.Vector3f up -> do
    nidefawl.qubes.vec.Vector3f forward -> if
    nidefawl.qubes.vec.Vector3f cam -> for
    nidefawl.qubes.vec.Vector3f tmp -> int
    nidefawl.qubes.vec.Vector3f X -> new
    nidefawl.qubes.vec.Vector3f Y -> try
    nidefawl.qubes.vec.Vector3f Z -> byte
    float znear -> do
    float zfar -> if
    float ratio -> for
    float tang -> int
    float angle -> new
    float sphereFactorY -> try
    float sphereFactorX -> byte
    34:46:void setCamInternals(float,float,float,float) -> do
    81:111:void set(nidefawl.qubes.vec.Matrix4f) -> do
    116:121:void normalize(int) -> do
    124:124:float planeDistance(nidefawl.qubes.vec.Vector4f,float,float,float) -> do
    166:195:int sphereInFrustum(nidefawl.qubes.vec.Vector3f,float) -> do
    246:246:int checkFrustum(nidefawl.qubes.vec.AABBInt,float) -> do
    256:277:int checkFrustum(nidefawl.qubes.vec.AABBInt) -> do
    281:302:void setPos(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.gl.BufferedMatrix) -> do
nidefawl.qubes.vec.Matrix4f -> JiIjiJIjlliJJill:
    float m00 -> do
    float m01 -> if
    float m02 -> for
    float m03 -> int
    float m10 -> new
    float m11 -> try
    float m12 -> byte
    float m13 -> case
    float m20 -> char
    float m21 -> else
    float m22 -> goto
    float m23 -> long
    float m30 -> this
    float m31 -> void
    float m32 -> break
    float m33 -> catch
    51:56:java.lang.String toString() -> toString
    64:64:nidefawl.qubes.vec.Matrix4f setIdentity() -> if
    73:90:nidefawl.qubes.vec.Matrix4f setIdentity(nidefawl.qubes.vec.Matrix4f) -> do
    98:98:nidefawl.qubes.vec.Matrix4f setZero() -> for
    107:124:nidefawl.qubes.vec.Matrix4f setZero(nidefawl.qubes.vec.Matrix4f) -> if
    133:133:nidefawl.qubes.vec.Matrix4f load(nidefawl.qubes.vec.Matrix4f) -> for
    143:162:nidefawl.qubes.vec.Matrix4f load(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    198:216:nidefawl.qubes.vec.Matrix4f load(float[]) -> do
    254:270:nidefawl.qubes.vec.Matrix4f store(java.nio.FloatBuffer) -> do
    412:449:nidefawl.qubes.vec.Matrix4f mul(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    486:499:nidefawl.qubes.vec.Vector3f transform(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    536:548:nidefawl.qubes.vec.Vector3f transformTransposed(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> if
    556:556:nidefawl.qubes.vec.Matrix4f transpose() -> int
    565:565:nidefawl.qubes.vec.Matrix4f translate(float,float,float) -> do
    583:583:nidefawl.qubes.vec.Matrix4f scale(nidefawl.qubes.vec.Vector3f) -> do
    592:592:nidefawl.qubes.vec.Matrix4f scale(float) -> do
    595:607:nidefawl.qubes.vec.Matrix4f scale(float,float,float) -> if
    618:632:nidefawl.qubes.vec.Matrix4f scale(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    642:642:nidefawl.qubes.vec.Matrix4f rotate(float,float,float,float) -> do
    653:653:nidefawl.qubes.vec.Matrix4f rotate(float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    722:766:nidefawl.qubes.vec.Matrix4f rotate(float,float,float,float,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    776:776:nidefawl.qubes.vec.Matrix4f translate(float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    787:795:nidefawl.qubes.vec.Matrix4f translate(float,float,float,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    804:804:nidefawl.qubes.vec.Matrix4f transpose(nidefawl.qubes.vec.Matrix4f) -> int
    814:850:nidefawl.qubes.vec.Matrix4f transpose(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> if
    857:878:float determinant() -> do
    890:890:float determinant3x3(float,float,float,float,float,float,float,float,float) -> do
    900:900:nidefawl.qubes.vec.Matrix4f invert() -> new
    955:1008:nidefawl.qubes.vec.Matrix4f invert(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> for
    1060:1065:void transformVec(nidefawl.qubes.vec.Vector3f) -> do
    1069:1117:void mulMat(nidefawl.qubes.vec.Matrix4f) -> do
    1201:1217:void addWeighted(nidefawl.qubes.vec.Matrix4f,float) -> do
nidefawl.qubes.vec.Quaternion -> iJL1llL1jI1LL1iJ:
    float x -> do
    float y -> if
    float z -> for
    float w -> int
    68:68:nidefawl.qubes.vec.Quaternion setIdentity() -> do
    77:81:nidefawl.qubes.vec.Quaternion setIdentity(nidefawl.qubes.vec.Quaternion) -> do
    295:295:java.lang.String toString() -> toString
nidefawl.qubes.vec.StackChangeCallBack -> jI1LjIllJiJiJi:
    void onChange(nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.vec.TransformStack -> L1iJL1IjllIjllL1:
    nidefawl.qubes.vec.Vector3f[] stack -> do
    int stackSize -> do
    nidefawl.qubes.vec.Vector3f tmp -> do
    nidefawl.qubes.vec.StackChangeCallBack cb -> do
    24:34:void translate(float,float,float) -> do
    36:40:void push() -> do
    42:47:void push(float,float,float) -> if
    49:54:void pop() -> if
    56:60:nidefawl.qubes.vec.Vector3f get() -> do
    63:64:void setCallBack(nidefawl.qubes.vec.StackChangeCallBack) -> do
    79:81:void setScissors(int,int,int,int) -> do
nidefawl.qubes.vec.Vec3D -> L1IjIjllL1iJIjiJ:
    double x -> do
    double y -> if
    double z -> for
    24:24:nidefawl.qubes.vec.BlockPos toBlock() -> do
    28:31:void set(nidefawl.qubes.vec.Vec3D) -> do
    143:152:java.lang.String toString() -> toString
    205:208:double distanceSq(nidefawl.qubes.vec.Vec3D) -> do
nidefawl.qubes.vec.Vector3f -> L1jIL11LIjIjiJL1:
    nidefawl.qubes.vec.Vector3f ZERO -> do
    nidefawl.qubes.vec.Vector3f ONE -> if
    float x -> do
    float y -> if
    float z -> for
    56:57:void set(nidefawl.qubes.vec.Vector3f) -> do
    63:66:void set(float,float,float) -> do
    72:72:float lengthSquared() -> do
    85:88:nidefawl.qubes.vec.Vector3f translate(float,float,float) -> do
    103:107:nidefawl.qubes.vec.Vector3f add(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    123:127:nidefawl.qubes.vec.Vector3f sub(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> if
    144:149:nidefawl.qubes.vec.Vector3f cross(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> for
    208:208:float dot(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    244:248:nidefawl.qubes.vec.Vector3f scale(float) -> do
    257:261:nidefawl.qubes.vec.Vector3f store(java.nio.FloatBuffer) -> do
    268:277:java.lang.String toString() -> toString
    300:301:void setX(float) -> do
    309:310:void setY(float) -> if
    318:319:void setZ(float) -> for
    332:332:float length() -> if
    341:346:nidefawl.qubes.vec.Vector3f normalise() -> do
    350:355:nidefawl.qubes.vec.Vector3f normaliseNull() -> if
    373:376:void addVec(nidefawl.qubes.vec.Vector3f) -> if
    385:388:float distanceSq(float,float,float) -> do
    392:395:void write(java.io.DataOutput) -> do
    398:401:void read(java.io.DataInput) -> do
    414:415:void subtract(nidefawl.qubes.vec.Vector3f) -> for
    418:423:void interp(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,float,nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.vec.Vector4f -> JiL1JillL1llIjll:
    float x -> do
    float y -> if
    float z -> for
    float w -> int
    57:61:void set(float,float,float,float) -> do
    67:67:float lengthSquared() -> do
    239:239:java.lang.String toString() -> toString
    308:308:float length() -> if
nidefawl.qubes.world.BlockPlacer -> jIjIjIllJilljI1L:
    nidefawl.qubes.entity.PlayerServer player -> do
    nidefawl.qubes.item.BlockStack stack -> do
    long startTime -> do
    nidefawl.qubes.worldgen.biome.HexBiome biome -> do
    nidefawl.qubes.worldgen.trees.Tree tree -> do
    int resolved -> do
    nidefawl.qubes.vec.BlockPos pos -> do
    43:43:nidefawl.qubes.entity.Player getPlayer() -> do
    46:46:nidefawl.qubes.world.World getWorld() -> do
    50:63:nidefawl.qubes.worldgen.trees.Tree getTree() -> do
    66:70:nidefawl.qubes.worldgen.biome.HexBiome getBiome() -> do
    75:108:void tryMine(nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.item.BaseStack,int,int) -> do
    110:255:void tryPlace(nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.item.BlockStack,int) -> do
    265:274:void tryHarvest(int,int,int) -> do
    288:297:boolean canPlaceDefault(nidefawl.qubes.block.Block,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,int,int,int) -> do
    307:312:void placeDefault(nidefawl.qubes.vec.BlockPos,int,int,int) -> do
    317:322:nidefawl.qubes.chunk.blockdata.BlockData getBlockData() -> do
nidefawl.qubes.world.IBlockWorld -> JijI1LL1IjjIIjll:
    int getType(int,int,int) -> if
    int getData(int,int,int) -> do
    boolean isNormalBlock(int,int,int,int) -> do
    boolean setTypeData(int,int,int,int,int,int) -> do
    int getLight(int,int,int) -> int
    nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    int getBiomeFaceColor(int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    int getWater(int,int,int) -> for
nidefawl.qubes.world.IWorldSettings -> iJL1IjiJiJIjJi:
    long getSeed() -> do
    java.util.UUID getUUID() -> do
    long getTime() -> if
    int getId() -> do
    java.lang.String getName() -> do
    long getDayLen() -> for
    boolean isFixedTime() -> do
    void setTime(long) -> do
    void setDayLen(long) -> if
    void setFixedTime(boolean) -> do
nidefawl.qubes.world.SunLightModel -> jIiJIjlliJJiJill:
    float dayLightIntensity -> do
    float nightNoon -> if
    float dayNoon -> for
    float lightAngleUp -> int
    nidefawl.qubes.vec.Matrix4f sunModelView -> do
    nidefawl.qubes.vec.Matrix4f moonModelView -> if
    nidefawl.qubes.vec.Vector3f sunPosition -> do
    nidefawl.qubes.vec.Vector3f moonPosition -> if
    nidefawl.qubes.vec.Vector3f lightPosition -> for
    nidefawl.qubes.vec.Vector3f lightDirection -> int
    nidefawl.qubes.vec.Vector3f tmp1 -> new
    long time -> do
    long dayLen -> if
    float sunPathRotation -> new
    float moonPathRotation -> try
    42:72:void updateFrame(float) -> do
    74:75:void setDayLen(long) -> do
    77:78:void setTime(long) -> if
    93:102:float getSunAngle(float) -> do
    111:111:nidefawl.qubes.vec.Vector3f getLightPosition() -> do
    114:114:float getLightAngleUp() -> do
    118:118:float getDayLightIntensity() -> if
    122:122:float getDayNoonFloat() -> for
    126:126:float getNightNoonFloat() -> int
nidefawl.qubes.world.World -> IjIjJijIiJ1LIj1L:
    java.util.ArrayList lights -> do
    int worldHeight -> do
    int worldHeightMinusOne -> if
    int worldHeightBits -> for
    int worldHeightBitsPlusFour -> int
    int worldSeaLevel -> new
    long seed -> do
    nidefawl.qubes.chunk.ChunkManager chunkMgr -> do
    java.util.Random rand -> do
    java.util.UUID uuid -> do
    int id -> try
    nidefawl.qubes.world.IWorldSettings settings -> do
    nidefawl.qubes.worldgen.biome.IBiomeManager biomeManager -> do
    java.lang.String name -> do
    nidefawl.qubes.chunk.ChunkManager makeChunkManager() -> do
    73:85:float getSunAngle(float) -> do
    101:101:int getType(nidefawl.qubes.vec.BlockPos) -> do
    111:111:int getData(nidefawl.qubes.vec.BlockPos) -> if
    115:123:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    127:135:int getType(int,int,int) -> if
    139:147:int getWater(int,int,int) -> for
    151:159:int getData(int,int,int) -> do
    166:182:boolean setData(int,int,int,int,int) -> do
    190:206:boolean setType(int,int,int,int,int) -> if
    210:226:boolean setBlockData(int,int,int,nidefawl.qubes.chunk.blockdata.BlockData,int) -> do
    230:230:boolean setBlockData(nidefawl.qubes.vec.BlockPos,nidefawl.qubes.chunk.blockdata.BlockData,int) -> do
    235:249:boolean setTypeData(int,int,int,int,int,int) -> do
    253:253:void updateLight(int,int,int) -> do
    void flagBlock(int,int,int) -> if
    258:258:nidefawl.qubes.chunk.Chunk getChunk(int,int) -> do
    263:263:void onLoad() -> do
    266:269:void removeLight(int) -> do
    272:282:void addLight(nidefawl.qubes.vec.Vector3f) -> do
    285:307:void spawnLights(nidefawl.qubes.vec.BlockPos) -> do
    311:315:int getHeight(int,int) -> do
    318:318:nidefawl.qubes.chunk.ChunkManager getChunkManager() -> if
    323:323:java.util.UUID getUUID() -> do
    331:331:long getTime() -> do
    335:335:long getDayLength() -> if
    349:349:int getId() -> do
    357:357:void updateLightHeightMap(nidefawl.qubes.chunk.Chunk,int,int,int,int,boolean) -> do
    360:370:nidefawl.qubes.chunk.Chunk getChunkIfNeightboursLoaded(int,int) -> if
    374:375:boolean canSeeSky(int,int,int) -> do
    379:380:boolean isTransparent(int,int,int) -> if
    392:395:int getLight(int,int,int) -> int
    408:408:void flagChunkLightUpdate(int,int) -> do
    411:411:java.lang.String getName() -> do
    419:419:nidefawl.qubes.world.IWorldSettings getSettings() -> do
    425:428:boolean isNormalBlock(int,int,int,int) -> do
    java.util.List getEntityList() -> do
    441:441:int getBiomeFaceColor(int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    445:445:nidefawl.qubes.worldgen.biome.HexBiome getHex(int,int) -> do
nidefawl.qubes.world.WorldClient -> Ij1L1L1L1LllJiJi:
    float dayLightIntensity -> do
    float nightNoon -> if
    float dayNoon -> for
    float lightAngleUp -> int
    nidefawl.qubes.vec.Matrix4f sunModelView -> do
    nidefawl.qubes.vec.Matrix4f moonModelView -> if
    nidefawl.qubes.vec.Vector3f sunPosition -> do
    nidefawl.qubes.vec.Vector3f moonPosition -> if
    nidefawl.qubes.vec.Vector3f lightPosition -> for
    nidefawl.qubes.vec.Vector3f lightDirection -> int
    nidefawl.qubes.vec.Vector3f tmp1 -> new
    java.util.HashMap entities -> do
    java.util.ArrayList entityList -> if
    54:57:nidefawl.qubes.worldgen.biome.IBiomeManager createBiomeManager(int) -> do
    63:63:nidefawl.qubes.chunk.ChunkManager makeChunkManager() -> do
    67:97:void updateFrame(float) -> do
    99:99:nidefawl.qubes.vec.Vector3f getLightPosition() -> do
    102:102:float getLightAngleUp() -> do
    106:106:float getDayLightIntensity() -> if
    110:110:float getDayNoonFloat() -> for
    114:114:float getNightNoonFloat() -> int
    118:119:void flagBlock(int,int,int) -> if
    123:136:void tickUpdate() -> if
    141:143:void onLeave() -> for
    146:153:boolean addEntity(nidefawl.qubes.entity.Entity) -> do
    157:163:boolean removeEntity(nidefawl.qubes.entity.Entity) -> if
    168:168:nidefawl.qubes.entity.Entity getEntity(int) -> do
    172:172:java.util.List getEntityList() -> do
nidefawl.qubes.world.WorldServer -> IjIjjIIjL11LlljI:
    nidefawl.qubes.server.GameServer server -> do
    nidefawl.qubes.server.PlayerChunkTracker chunkTracker -> do
    java.util.List players -> do
    nidefawl.qubes.chunk.server.ChunkManagerServer chunkServer -> do
    nidefawl.qubes.worldgen.terrain.ITerrainGen generator -> do
    nidefawl.qubes.worldgen.populator.IChunkPopulator populator -> do
    java.util.Set lightUpdateQueue -> do
    nidefawl.qubes.blocklight.BlockLightThread lightUpdater -> do
    java.util.HashMap entities -> do
    java.util.ArrayList entityList -> if
    java.util.Iterator updateIt -> do
    56:60:void onLeave() -> if
    64:66:void onLoad() -> do
    72:72:nidefawl.qubes.worldgen.terrain.ITerrainGen getGenerator() -> do
    76:85:void tickUpdate() -> for
    88:90:void resyncTime() -> int
    93:98:void broadcastPacket(nidefawl.qubes.network.packet.Packet) -> do
    101:101:nidefawl.qubes.chunk.ChunkManager makeChunkManager() -> do
    105:105:nidefawl.qubes.server.GameServer getServer() -> do
    110:173:void updateChunks() -> new
    179:180:void unloadUnused() -> try
    183:194:void addPlayer(nidefawl.qubes.entity.PlayerServer) -> do
    197:203:void removePlayer(nidefawl.qubes.entity.PlayerServer) -> if
    207:218:boolean addEntity(nidefawl.qubes.entity.Entity) -> do
    222:233:boolean removeEntity(nidefawl.qubes.entity.Entity) -> if
    236:236:nidefawl.qubes.vec.Vector3f getSpawnPosition() -> do
    240:244:void save(boolean) -> do
    247:248:void flagBlock(int,int,int) -> if
    251:251:nidefawl.qubes.server.PlayerChunkTracker getPlayerChunkTracker() -> do
    255:257:void calcSunLight(nidefawl.qubes.chunk.Chunk) -> do
    261:288:void updateLightHeightMap(nidefawl.qubes.chunk.Chunk,int,int,int,int,boolean) -> do
    291:293:void updateLight(int,int,int) -> do
    296:297:void flagChunkLightUpdate(int,int) -> do
    302:302:nidefawl.qubes.worldgen.populator.IChunkPopulator getChunkPopulator() -> do
    347:347:java.util.List getEntityList() -> do
    353:353:int getWorldType() -> if
    359:359:nidefawl.qubes.worldgen.biome.IBiomeManager getBiomeManager() -> do
nidefawl.qubes.world.WorldSettings -> IjjIL1JijIll1LiJ:
    long time -> do
    long dayLen -> if
    boolean isFixedTime -> do
    long seed -> for
    java.util.UUID uuid -> do
    java.io.File dir -> do
    int id -> do
    java.lang.String generatorName -> do
    java.lang.String worldName -> if
    26:26:long getDayLen() -> for
    31:31:boolean isFixedTime() -> do
    35:35:void read(java.io.DataInput) -> do
    39:48:void write(java.io.DataOutput) -> do
    58:61:void setDefaults() -> do
    65:73:void load() -> if
    76:76:java.io.File getWorldDirectory() -> do
    81:87:void save() -> for
    91:91:long getSeed() -> do
    96:96:java.util.UUID getUUID() -> do
    101:101:long getTime() -> if
    106:106:int getId() -> do
    110:111:void setId(int) -> do
    119:119:java.lang.String getName() -> do
    127:131:void saveFile() -> int
    135:136:void setTime(long) -> do
    140:141:void setFixedTime(boolean) -> do
    145:146:void setDayLen(long) -> if
nidefawl.qubes.world.WorldSettingsClient -> iJIjiJIjiJJiiJiJ:
    java.util.UUID uuid -> do
    long seed -> do
    long time -> if
    int id -> do
    java.lang.String worldName -> do
    long dayLen -> for
    boolean isFixedTime -> do
    21:28:void read(java.io.DataInput) -> do
    32:32:void write(java.io.DataOutput) -> do
    41:41:long getSeed() -> do
    46:46:java.util.UUID getUUID() -> do
    51:51:long getTime() -> if
    56:56:int getId() -> do
    61:61:java.lang.String getName() -> do
    66:66:long getDayLen() -> for
    71:71:boolean isFixedTime() -> do
    76:77:void setTime(long) -> do
    81:82:void setFixedTime(boolean) -> do
    86:87:void setDayLen(long) -> if
nidefawl.qubes.worldgen.biome.EmptyBiomeManager -> L1lliJL1iJiJ1LjI:
    27:27:int getWorldType() -> do
    32:32:int getBiomeFaceColor(nidefawl.qubes.world.World,int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    37:37:nidefawl.qubes.network.packet.PacketSWorldBiomes getPacket() -> do
    41:41:void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    45:45:void sendChanges() -> do
    49:49:void saveChanges() -> if
    52:52:nidefawl.qubes.worldgen.biome.HexBiome blockToHex(int,int) -> do
nidefawl.qubes.worldgen.biome.HexBiome -> ll1LjIL1IjL1llll:
    boolean needsSave -> do
    nidefawl.qubes.biome.Biome biome -> do
    java.util.Set treeList -> do
    nidefawl.qubes.util.RegionMap trees -> do
    78:111:void save(java.io.File) -> do
    114:117:void registerTree(nidefawl.qubes.worldgen.trees.Tree) -> do
    120:130:nidefawl.qubes.worldgen.trees.Tree getTree(int,int,int) -> do
    134:140:nidefawl.qubes.worldgen.biome.HexBiome[] getClosest3(double,double) -> do
    144:145:java.util.Collection getNearbyTrees(int,int,int,int) -> do
nidefawl.qubes.worldgen.biome.HexBiomeEnd -> L11LJillJiIjIj1L:
    17:17:void save(java.io.File) -> do
    20:20:void registerTree(nidefawl.qubes.worldgen.trees.Tree) -> do
nidefawl.qubes.worldgen.biome.HexBiomes -> IjlljIllL1iJlljI:
    nidefawl.qubes.world.World world -> do
    27:28:nidefawl.qubes.biome.Biome getBiome(int,int) -> do
    33:33:int getWorldType() -> do
    40:96:int getBiomeFaceColor(nidefawl.qubes.world.World,int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    18:18:nidefawl.qubes.worldgen.biome.HexBiome blockToHex(int,int) -> do
nidefawl.qubes.worldgen.biome.HexBiomesClient -> lllliJlljI1LjIiJ:
    22:22:nidefawl.qubes.worldgen.biome.HexBiome loadCell(int,int) -> if
    26:26:nidefawl.qubes.worldgen.biome.HexBiome oobCell(int,int) -> for
    31:31:nidefawl.qubes.network.packet.PacketSWorldBiomes getPacket() -> do
    35:42:void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    46:46:void sendChanges() -> do
    49:49:void saveChanges() -> if
    15:15:java.lang.Object oobCell(int,int) -> for
    15:15:java.lang.Object loadCell(int,int) -> if
nidefawl.qubes.worldgen.biome.HexBiomesServer -> JiL1jIllJiiJiJiJ:
    java.util.regex.Pattern FILE_PATTERN -> do
    boolean SAVE_LOAD -> do
    java.io.File dir -> do
    java.util.Set flaggedInstances -> do
    java.util.Set flaggedInstances2 -> if
    45:46:java.io.File getFile(int,int) -> do
    92:106:nidefawl.qubes.worldgen.biome.HexBiome loadCell(int,int) -> if
    110:111:void flagBiome(int,int) -> if
    116:121:nidefawl.qubes.network.packet.PacketSWorldBiomes getPacket() -> do
    128:141:nidefawl.qubes.network.packet.PacketSWorldBiomes makePacket(java.util.ArrayList) -> do
    146:146:void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    152:162:void sendChanges() -> do
    165:165:nidefawl.qubes.worldgen.biome.HexBiome oobCell(int,int) -> for
    169:183:void saveChanges() -> if
    186:187:void flag(int,int) -> do
    28:28:java.lang.Object oobCell(int,int) -> for
    28:28:java.lang.Object loadCell(int,int) -> if
nidefawl.qubes.worldgen.biome.IBiomeManager -> IjjIL1IjjI1Lll:
    int getWorldType() -> do
    int getBiomeFaceColor(nidefawl.qubes.world.World,int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    nidefawl.qubes.network.packet.PacketSWorldBiomes getPacket() -> do
    void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    void sendChanges() -> do
    void saveChanges() -> if
    nidefawl.qubes.worldgen.biome.HexBiome blockToHex(int,int) -> do
nidefawl.qubes.worldgen.populator.ChunkPopulator -> JiiJJilllljIjIll:
    nidefawl.qubes.world.WorldServer world -> do
    37:197:void populate(nidefawl.qubes.chunk.Chunk) -> do
    203:203:boolean isSoil(int) -> do
nidefawl.qubes.worldgen.populator.EmptyChunkPopulator -> L1iJL1iJ1LIjlljI:
    24:24:void populate(nidefawl.qubes.chunk.Chunk) -> do
nidefawl.qubes.worldgen.populator.IChunkPopulator -> L1Ij1LL1IjjIIjJi:
    void populate(nidefawl.qubes.chunk.Chunk) -> do
nidefawl.qubes.worldgen.populator.TreeGeneratorLSystem -> lllliJJilliJjIL1:
    float MAX_ANGLE_OFFSET -> do
    int maxDepth -> do
    float angle -> if
    int leaves -> if
    int log -> for
    java.lang.String initialAxiom -> do
    java.util.Map ruleSet -> for
    java.util.Map blocks -> do
    java.util.Map trunk -> if
    int variation -> int
    nidefawl.qubes.block.Block vines -> do
    nidefawl.qubes.vec.Matrix4f tempRotation -> do
    nidefawl.qubes.vec.Vector3f dir -> do
    nidefawl.qubes.vec.Vector3f dir2 -> if
    36:37:void setVines(nidefawl.qubes.block.Block) -> do
    61:62:nidefawl.qubes.worldgen.populator.TreeGeneratorLSystem setLeafType(int) -> do
    70:71:nidefawl.qubes.worldgen.populator.TreeGeneratorLSystem setBarkType(int) -> if
    78:89:boolean generate(nidefawl.qubes.world.IBlockWorld,int,int,int,java.util.Random) -> do
    92:144:void postGenerate(nidefawl.qubes.world.IBlockWorld,int,int,int,java.util.Random) -> do
    152:367:void recurse(nidefawl.qubes.world.IBlockWorld,java.util.Random,int,int,int,float,nidefawl.qubes.util.CharSequenceIterator,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Matrix4f,int,int) -> do
    370:371:void safelySetBlock(nidefawl.qubes.world.IBlockWorld,int,int,int,int) -> do
    373:382:void safelySetBlock(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    385:440:nidefawl.qubes.worldgen.trees.Tree getTree() -> do
nidefawl.qubes.worldgen.populator.TreeGenerators -> llJiJiL1L1jIiJ1L:
    20:84:nidefawl.qubes.worldgen.populator.TreeGeneratorLSystem get(int,java.util.Random) -> do
nidefawl.qubes.worldgen.populator.TreeRule -> llL11LIjlllliJJi:
    java.lang.String string -> do
    float weight -> do
    27:27:java.lang.String getRule() -> do
    34:34:float getWeight() -> do
nidefawl.qubes.worldgen.terrain.ITerrainGen -> L1Ij1LL1L1L1jIjI:
    nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    java.lang.Class getPopulator() -> do
    java.lang.Class getBiomeManager() -> if
    void init() -> do
nidefawl.qubes.worldgen.terrain.TerrainGenBlockTest -> jIjI1L1LL1Ji1LIj:
    nidefawl.qubes.world.WorldServer world -> do
    26:34:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    38:59:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    63:63:java.lang.Class getPopulator() -> do
    68:68:java.lang.Class getBiomeManager() -> if
    73:73:void init() -> do
nidefawl.qubes.worldgen.terrain.TerrainGenFlatSand128 -> L1ll1LiJIj1LiJjI:
    nidefawl.qubes.world.WorldServer world -> do
    23:28:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    32:39:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    43:43:java.lang.Class getPopulator() -> do
    48:48:java.lang.Class getBiomeManager() -> if
    53:53:void init() -> do
nidefawl.qubes.worldgen.terrain.TerrainGenQTest -> L1iJ1LlljIL1Ijll:
    nidefawl.qubes.world.WorldServer world -> do
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    47:60:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    64:263:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    266:298:double[] generateNoise(int,int) -> do
    363:363:double clamp10(double) -> do
    385:385:java.lang.Class getPopulator() -> do
    390:390:java.lang.Class getBiomeManager() -> if
    396:396:void init() -> do
nidefawl.qubes.worldgen.terrain.TerrainGeneratorOther -> JiJillllIjJiiJiJ:
    nidefawl.qubes.world.WorldServer world -> do
    nidefawl.qubes.noise.TerrainNoise noise3 -> do
    nidefawl.qubes.noise.TerrainNoise noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseCustom1 noise2 -> do
    nidefawl.qubes.noise.TerrainNoise noise4 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.RiverNoise2D r2D -> do
    nidefawl.qubes.noise.RiverNoise2D r2D2 -> if
    nidefawl.qubes.noise.TerrainNoiseCustom1 noise5 -> if
    64:72:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    156:264:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    266:279:double func2(double,double,double) -> do
    292:292:double clamp10(double) -> do
    314:314:java.lang.Class getPopulator() -> do
    319:319:java.lang.Class getBiomeManager() -> if
    324:324:void init() -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen -> IjJillL1jIiJ1Lll:
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int) -> do
    int generate(int,int,int,int,int,int,nidefawl.qubes.worldgen.biome.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData -> llIjjIIjiJL1jIiJ:
nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain -> iJL11LllIjjIiJL1:
    nidefawl.qubes.world.WorldServer world -> do
    nidefawl.qubes.worldgen.biome.HexBiomesServer biomes -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j4 -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j5 -> if
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j -> for
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j2 -> int
    java.util.Map map -> do
    56:57:void init() -> do
    61:82:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    86:285:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[],byte[],nidefawl.qubes.worldgen.biome.HexBiome[],java.util.ArrayList) -> do
    289:311:int getStone(nidefawl.qubes.world.WorldServer,int,int,int,nidefawl.qubes.worldgen.biome.HexBiome,java.util.Random) -> do
    332:337:double mix(double,double,double) -> do
    341:341:double clamp10(double) -> do
    363:363:java.lang.Class getPopulator() -> do
    368:368:java.lang.Class getBiomeManager() -> if
nidefawl.qubes.worldgen.trees.Tree -> JilliJiJjIJiJiIj:
    java.util.Set keys -> do
    nidefawl.qubes.vec.AABBInt bb -> do
    nidefawl.qubes.vec.AABBInt trunkBB -> if
    int[] blocks -> do
    34:36:void addKey(int) -> do
    46:46:int getMinX() -> do
    51:51:int getMinZ() -> if
    56:56:int getMaxX() -> for
    61:61:int getMaxZ() -> int
    65:73:nidefawl.qubes.nbt.Tag$Compound save() -> do
    88:97:void setBlocks(long[]) -> do
    101:108:byte[] intToByteArray(int[],byte[]) -> do
    127:129:boolean has(int,int,int) -> do
    133:133:java.util.Iterator iterator() -> do
    137:137:java.util.Iterator trunkIterator() -> if
    141:199:void onMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.block.Block,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
nidefawl.qubes.worldgen.trees.TreeBlockIterator -> IjiJL1iJJillL1ll:
    nidefawl.qubes.worldgen.trees.Tree tree -> do
    int pos -> do
    int[] blocks -> do
    nidefawl.qubes.vec.BlockPos bPos -> do
    nidefawl.qubes.vec.AABBInt bb -> do
    43:43:boolean hasNext() -> hasNext
    48:52:nidefawl.qubes.vec.BlockPos next() -> do
    57:57:void remove() -> remove
    10:10:java.lang.Object next() -> next
nidefawl.swing.TextDialog -> JillJiJi1LL1iJIj:
    javax.swing.JPanel topPanel -> do
    nidefawl.swing.TextDialog$JTextAreaWithScroll errorText -> do
    javax.swing.JLabel errorOccured -> do
    boolean reqRestart -> do
    java.lang.Throwable throwable -> do
    javax.swing.AbstractButton shaderBtn -> do
    nidefawl.qubes.shader.ShaderSource shader -> do
    java.lang.String flip -> do
    108:122:void setVisible(int,int) -> do
    129:132:void appendLine(java.lang.String) -> do
    134:137:void prepend(java.lang.String) -> if
    141:168:void actionPerformed(java.awt.event.ActionEvent) -> actionPerformed
    172:172:void lostOwnership(java.awt.datatransfer.Clipboard,java.awt.datatransfer.Transferable) -> lostOwnership
nidefawl.swing.TextDialog$JTextAreaWithScroll -> IjlljIllllJilljI:
    javax.swing.JScrollPane scrollPane -> do
    nidefawl.swing.TextDialog this$0 -> do
    33:33:javax.swing.JScrollPane getScrollPane() -> do
