nidefawl.qubes.BootClient -> nidefawl.qubes.BootClient:
    13:29:java.lang.String getValue(java.lang.String[],int,java.lang.String) -> getValue
    32:77:void main(java.lang.String[]) -> main
nidefawl.qubes.Game -> Ij1LIjL1jIL1iJIj:
    nidefawl.qubes.Game instance -> do
    java.lang.String buildIdentifier -> for
    nidefawl.qubes.PlayerProfile profile -> do
    nidefawl.qubes.config.ClientSettings settings -> do
    nidefawl.qubes.gui.GuiOverlayStats statsOverlay -> do
    nidefawl.qubes.gui.GuiCached statsCached -> do
    nidefawl.qubes.gui.GuiOverlayChat chatOverlay -> do
    nidefawl.qubes.network.client.ThreadConnect connect -> do
    nidefawl.qubes.network.client.NetworkClient client -> do
    nidefawl.qubes.world.WorldClient world -> do
    nidefawl.qubes.entity.PlayerSelf player -> do
    nidefawl.qubes.input.DigController dig -> do
    nidefawl.qubes.input.Selection selection -> do
    boolean follow -> new
    nidefawl.qubes.item.BlockStack selBlock -> do
    long lastShaderLoadTime -> do
    nidefawl.qubes.vec.Vector3f vCam -> if
    nidefawl.qubes.vec.Vector3f vPlayer -> do
    nidefawl.qubes.vec.Vector3f vLastCam -> for
    nidefawl.qubes.vec.Vector3f vLastPlayer -> int
    boolean updateRenderers -> do
    boolean showGrid -> if
    boolean thirdPerson -> for
    java.lang.String serverAddr -> do
    nidefawl.qubes.input.GameMode mode -> do
    float[] loadProgress -> do
    int throttleClick -> byte
    133:159:void initGame() -> do
    162:162:java.lang.String getAppTitle() -> do
    166:166:boolean loadRender(int,float) -> do
    169:240:boolean loadRender(int,float,java.lang.String) -> do
    245:291:void lateInitGame() -> if
    331:338:void setWorld(nidefawl.qubes.world.WorldClient) -> do
    345:348:void shutdown() -> for
    355:369:void onTextInput$25666f4(int) -> do
    373:412:void onKeyPress(long,int,int,int,int) -> do
    416:455:void onWheelScroll$487491ef(double,double) -> do
    458:500:void onMouseClick$399925ac(int,int) -> do
    503:510:void setGrabbed(boolean) -> do
    516:940:void render(float) -> do
    944:962:void onStatsUpdated() -> int
    966:967:void postRenderUpdate$133aeb() -> new
    970:1065:void preRenderUpdate(float) -> if
    1070:1088:void onResize(int,int) -> if
    1091:1113:void tick() -> try
    1130:1133:void addDebugOnScreen(java.lang.String) -> do
    1140:1147:void setConnection(nidefawl.qubes.network.client.NetworkClient) -> do
    1158:1161:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    1172:1177:void saveSettings() -> byte
    1212:1229:void blockClicked(nidefawl.qubes.util.RayTrace$RayTraceIntersection,boolean) -> do
nidefawl.qubes.Game$1 -> jI1LJi1LllJi:
    nidefawl.qubes.texture.array.TextureArray val$arr -> do
    263:264:void pre() -> do
    267:268:void post() -> if
    260:260:java.lang.Object call() -> call
nidefawl.qubes.GameBase -> Ij1LL1JiIjIjjI:
    java.lang.String appName -> if
    int displayWidth -> do
    int displayHeight -> if
    boolean GL_ERROR_CHECKS -> int
    long windowId -> if
    int initWidth -> byte
    int initHeight -> case
    int TICKS_PER_SEC -> char
    org.lwjgl.glfw.GLFWErrorCallback errorCallback -> do
    org.lwjgl.glfw.GLFWWindowSizeCallback cbWindowSize -> do
    org.lwjgl.glfw.GLFWKeyCallback cbKeyboard -> do
    org.lwjgl.glfw.GLFWMouseButtonCallback cbMouseButton -> do
    org.lwjgl.glfw.GLFWScrollCallback cbScrollCallback -> do
    org.lwjgl.glfw.GLFWWindowFocusCallback cbWindowFocus -> do
    org.lwjgl.glfw.GLFWCursorPosCallback cbCursorPos -> do
    org.lwjgl.glfw.GLFWCharCallback cbText -> do
    boolean hasTextHook -> do
    boolean DO_TIMING -> if
    float renderTime -> if
    float absTime -> do
    int ticksran -> for
    int lastFPS -> int
    long timeLastFPS -> do
    nidefawl.qubes.util.Timer timer -> do
    int tick -> new
    nidefawl.qubes.util.GameError showError -> do
    nidefawl.qubes.logging.LogBufferStream outStream -> do
    nidefawl.qubes.logging.LogBufferStream errStream -> if
    long frameTime -> for
    boolean vsync -> for
    boolean running -> new
    boolean wasrunning -> try
    boolean sysExit -> byte
    boolean minimized -> case
    java.lang.Thread thread -> do
    int newWidth -> else
    int newHeight -> goto
    int vendor$109b11a9 -> try
    nidefawl.qubes.GameBase baseInstance -> do
    nidefawl.qubes.input.InputController movement -> do
    nidefawl.qubes.gui.Gui gui -> do
    boolean wasGrabbed -> char
    java.util.ArrayList glProfileResults -> do
    int throttleClick -> long
    106:106:boolean isRunning() -> do
    116:168:void run() -> run
    324:324:java.lang.String getAppTitle() -> do
    347:350:void shutdown() -> for
    353:381:void checkResize() -> case
    void onStatsUpdated() -> int
    386:388:void setVSync(boolean) -> if
    391:391:boolean getVSync() -> if
    408:428:java.lang.String getGlErrorString(int) -> do
    437:437:boolean isCloseRequested() -> for
    456:466:void updateInput() -> char
    602:602:boolean loadRender(int,float) -> do
    606:660:void mainLoop() -> byte
    663:718:void initGLContext() -> goto
    723:731:void updateTime() -> else
    735:851:void showErrorScreen(java.lang.String,java.util.List,java.lang.Throwable,boolean) -> do
    854:855:void setException(nidefawl.qubes.util.GameError) -> do
    void onTextInput$25666f4(int) -> do
    void onKeyPress(long,int,int,int,int) -> do
    void onWheelScroll$487491ef(double,double) -> do
    void render(float) -> do
    void preRenderUpdate(float) -> if
    void postRenderUpdate$133aeb() -> new
    void onResize(int,int) -> if
    void tick() -> try
    void initGame() -> do
    void lateInitGame() -> if
    897:922:void showGUI(nidefawl.qubes.gui.Gui) -> do
    927:969:void onMouseClick$399925ac(int,int) -> do
    971:976:void setGrabbed(boolean) -> do
    979:979:boolean isGrabbed() -> int
    35:35:int access$002(nidefawl.qubes.GameBase,int) -> do
    35:35:int access$102(nidefawl.qubes.GameBase,int) -> if
nidefawl.qubes.GameBase$1 -> ll1LL1JiiJL1iJL1:
    nidefawl.qubes.GameBase this$0 -> do
    176:178:void invoke(long,int,int) -> invoke
nidefawl.qubes.GameBase$2 -> jI1LJi1L1LJiiJll:
    nidefawl.qubes.GameBase this$0 -> do
    184:188:void invoke(long,int,int,int,int) -> invoke
nidefawl.qubes.GameBase$3 -> IjllL1JiJiiJJiJi:
    nidefawl.qubes.GameBase this$0 -> do
    195:199:void invoke(long,int,int,int) -> invoke
nidefawl.qubes.GameBase$4 -> JiL1lljI1Lll1LL1:
    nidefawl.qubes.GameBase this$0 -> do
    205:211:void invoke(long,double,double) -> invoke
nidefawl.qubes.GameBase$5 -> Ij1LIjiJllL11LJi:
    nidefawl.qubes.GameBase this$0 -> do
    218:222:void invoke(long,int) -> invoke
nidefawl.qubes.GameBase$6 -> iJlljI1LiJiJiJJi:
    nidefawl.qubes.GameBase this$0 -> do
    228:232:void invoke(long,double,double) -> invoke
nidefawl.qubes.GameBase$7 -> iJll1LjIL1IjJiIj:
    nidefawl.qubes.GameBase this$0 -> do
    238:242:void invoke(long,int) -> invoke
nidefawl.qubes.NativeClassLoader -> nidefawl.qubes.NativeClassLoader:
    nidefawl.qubes.NativeClassLoader instance -> instance
    byte[] cppLoadClass(java.lang.String) -> cppLoadClass
    byte[] cppLoadResource(java.lang.String) -> cppLoadResource
    19:19:java.lang.Class loadClassRedirect(java.lang.String) -> loadClassRedirect
    24:31:java.lang.Class findClass(java.lang.String) -> findClass
    34:36:byte[] loadGameResource(java.lang.String) -> loadGameResource
    40:46:void setLoader() -> setLoader
    52:52:nidefawl.qubes.NativeClassLoader getInstance() -> getInstance
nidefawl.qubes.NativeInterface -> nidefawl.qubes.NativeInterface:
    nidefawl.qubes.NativeInterface instance -> instance
    boolean isPresent -> isPresent
    15:15:nidefawl.qubes.NativeInterface getInstance() -> getInstance
    19:28:void start() -> start
    30:30:boolean isPresent() -> isPresent
    void gameCrashed(nidefawl.qubes.util.CrashInfo) -> gameCrashed
    void gameAlive() -> gameAlive
nidefawl.qubes.PlayerProfile -> IjJillL1ll1LJiL1:
    java.util.UUID uuid -> do
    java.lang.String name -> do
    22:25:void setDefaults() -> do
    48:50:void load() -> if
    54:56:void save() -> for
nidefawl.qubes.assets.Asset -> L1JiJiiJ1L1LJiJi:
    nidefawl.qubes.assets.AssetPack pack -> do
nidefawl.qubes.assets.AssetBinary -> JiL1JiiJIjiJiJ1L:
    byte[] data -> do
    java.lang.String name -> do
nidefawl.qubes.assets.AssetInputStream -> ll1LIjjIIjL1IjIj:
    nidefawl.qubes.assets.AssetPack source -> do
    java.io.InputStream inputStream -> do
    boolean directStateAccess -> do
    double dy -> do
    double dx -> if
    double x -> for
    double y -> int
    double scrollDX -> new
    double scrollDY -> try
    double lastX -> byte
    double lastY -> case
    java.nio.DoubleBuffer bx -> do
    java.nio.DoubleBuffer by -> if
    boolean isGrabbed -> if
    nidefawl.qubes.logging.IErrorHandler handler -> do
    java.lang.Thread mainThread -> do
    int side$7ae1e0f -> do
    nidefawl.qubes.util.GameError initError -> do
    long startBoot -> do
    30:32:void close() -> do
    24:36:void bindTexture(int,int,int) -> do
    82:105:void glTexStorage3D(int,int,int,int,int,int) -> do
    108:114:void glTexStorage2D(int,int,int,int,int) -> do
    120:129:int genStorage(int,int,int,int,int) -> do
    133:136:void deleteTexture(int) -> do
    34:36:double getDX() -> do
    40:42:double getDY() -> if
    46:46:boolean getState(int) -> do
    50:50:double getX() -> for
    54:54:double getY() -> int
    58:59:void setCursorPosition(int,int) -> do
    67:72:void setGrabbed(boolean) -> do
    75:82:void setLastPos() -> if
    84:84:boolean isButtonDown(int) -> if
    90:96:void update(double,double) -> do
    20:28:byte[] genNoise2(int) -> do
    173:191:int getAverageColor(byte[],int,int) -> do
    199:199:int clampRGB(int) -> do
    208:249:byte[] makeMipMap(byte[],int,int,int) -> do
    258:268:void clampAlpha(byte[],int,int) -> do
    271:283:byte[] toBytesRGBA(int[]) -> do
    327:327:float getR(int) -> do
    330:330:float getG(int) -> if
    333:333:float getB(int) -> for
    337:350:int mixRGB(int,int,float) -> do
    40:42:int readShort(byte[],int) -> do
    46:47:int readUnsignedByte(byte[],int) -> if
    72:75:void byteToShortArray(byte[],short[]) -> do
    14:15:java.lang.String getClipboardString() -> do
    41:61:int fromFloat(float) -> do
    138:138:int packNormal(nidefawl.qubes.vec.Vector3f) -> do
    148:148:int packTexCoord(float,float) -> do
    40:42:int parseInt(java.lang.String,int) -> do
    6:8:int toHash(int,int,int) -> do
    12:12:int getDirX(int) -> if
    16:16:int getDirZ(int) -> for
    20:20:int getDirY(int) -> int
    28:28:boolean isTopBottom(int) -> for
    53:67:java.lang.String asString(int) -> do
nidefawl.qubes.assets.AssetManager -> jIL1Ij1LIjiJIj:
    nidefawl.qubes.assets.AssetManager instance -> do
    java.util.ArrayList assetPacks -> do
    java.io.File folder -> do
    void _init() -> do
    void toggleExternalResources() -> if
    boolean isExternalResources() -> do
    nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String) -> do
    nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    47:66:nidefawl.qubes.assets.AssetBinary loadBin(java.lang.String) -> do
    78:100:nidefawl.qubes.assets.AssetInputStream findResource(java.lang.String,boolean) -> do
    133:155:nidefawl.qubes.assets.AssetTexture loadPNGAsset(java.lang.String,boolean) -> do
nidefawl.qubes.assets.AssetManagerClient -> jI1LiJlliJ1LiJjI:
    boolean externalResources -> do
    18:20:void toggleExternalResources() -> if
    23:23:boolean isExternalResources() -> do
    51:51:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String) -> do
    54:82:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    92:124:void _init() -> do
nidefawl.qubes.assets.AssetManagerServer -> JiIjjIiJL1jIiJiJ:
    16:16:void toggleExternalResources() -> if
    20:20:boolean isExternalResources() -> do
    30:30:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String) -> do
    35:35:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    45:51:void _init() -> do
nidefawl.qubes.assets.AssetPack -> IjIjJiJiiJjIjIJi:
    nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
nidefawl.qubes.assets.AssetPackClassPath -> IjIjjIJiL1iJ1LJi:
    22:25:nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
    33:33:java.lang.String toString() -> toString
nidefawl.qubes.assets.AssetPackFolder -> iJiJ1LllL1L1jI1L:
    java.io.File directory -> do
    27:33:nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
    38:38:java.lang.String toString() -> toString
nidefawl.qubes.assets.AssetTexture -> lliJiJJiJill1L1L:
    int width -> do
    int height -> if
    byte[] data -> do
    int slot -> for
    java.lang.String name -> do
    int bits -> int
    short[] shortData -> do
    135:146:void cutH() -> do
nidefawl.qubes.async.AsyncTask -> iJIjiJiJlliJ:
    java.util.concurrent.Future future -> do
    16:16:void pre() -> do
    19:19:void post() -> if
nidefawl.qubes.async.AsyncTaskThread -> L1llJi1LJiL1jIiJ:
    java.util.zip.Inflater inflate -> do
    byte[] tmpBuffer -> do
    18:28:byte[] inflate(byte[]) -> do
nidefawl.qubes.async.AsyncTasks -> L1Ij1LIjJijIjI1L:
    java.util.ArrayList tasks -> do
    java.util.concurrent.ExecutorService service -> do
    16:34:void init() -> do
    37:50:void submit(nidefawl.qubes.async.AsyncTask) -> do
    53:73:boolean completeTasks() -> do
    76:80:void shutdown() -> if
nidefawl.qubes.async.AsyncTasks$1 -> iJIjiJllll1LlliJ:
    30:30:java.lang.Thread newThread(java.lang.Runnable) -> newThread
nidefawl.qubes.async.AsyncTasks$2 -> Ij1L1LL1JillIjJi:
    25:26:void uncaughtException(java.lang.Thread,java.lang.Throwable) -> uncaughtException
nidefawl.qubes.biome.Biome -> JiJillL1llIjL1jI:
    nidefawl.qubes.biome.Biome[] biomes -> do
    int maxBiome -> new
    nidefawl.qubes.biome.Biome MEADOW_GREEN -> do
    nidefawl.qubes.biome.Biome MEADOW_BLUE -> if
    nidefawl.qubes.biome.Biome MEADOW_RED -> for
    int colorFoliage -> do
    int colorFoliage2 -> if
    int colorLeaves -> for
    int colorGrass -> int
    77:89:nidefawl.qubes.biome.Biome setColor$2a9ded35(int,int) -> do
    110:112:nidefawl.qubes.biome.Biome get(int) -> do
    120:136:int getFaceColor$78228967(int) -> do
nidefawl.qubes.biome.Biome$1 -> iJ1LiJlljIllIj:
    int[] $SwitchMap$nidefawl$qubes$biome$BiomeColor -> do
nidefawl.qubes.biome.BiomeColor -> JiIjL1IjiJJi1L1L:
    int GRASS$58342f1 -> do
    int LEAVES$58342f1 -> if
    int FOLIAGE$58342f1 -> for
    int FOLIAGE2$58342f1 -> int
    int[] $VALUES$4b388bec -> do
    10:10:int[] values$575ef8d5() -> do
nidefawl.qubes.biome.BiomeDesert -> JiJiJiJiL11LJi1L:
nidefawl.qubes.biome.BiomeDesertRed -> L1IjjIL1jI1LL1L1:
nidefawl.qubes.biome.BiomeIce -> lllljIJiL1iJIjIj:
nidefawl.qubes.biome.BiomeMeadow -> IjjIL1jIJijIJijI:
nidefawl.qubes.biomes.EmptyBiomeManager -> Ji1LjIL1JiiJjI1L:
    32:32:int getBiomeFaceColor$518b81b2$660568f8(int,int,int) -> do
    41:41:void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    52:52:nidefawl.qubes.biomes.HexBiome blockToHex(int,int) -> do
nidefawl.qubes.biomes.HexBiome -> Ijll1L1LjIL1Jill:
    nidefawl.qubes.biome.Biome biome -> do
nidefawl.qubes.biomes.HexBiomeEnd -> jIllIjjIJiiJJiIj:
nidefawl.qubes.biomes.HexBiomes -> iJL1llIj1LJi1LIj:
    40:96:int getBiomeFaceColor$518b81b2$660568f8(int,int,int) -> do
    18:18:nidefawl.qubes.biomes.HexBiome blockToHex(int,int) -> do
nidefawl.qubes.biomes.HexBiomesClient -> L1ll1L1LJillIjL1:
    35:42:void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    15:15:java.lang.Object oobCell(int,int) -> do
    15:15:java.lang.Object loadCell(int,int) -> if
nidefawl.qubes.biomes.IBiomeManager -> lliJlliJL1JijIjI:
    int getBiomeFaceColor$518b81b2$660568f8(int,int,int) -> do
    void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    nidefawl.qubes.biomes.HexBiome blockToHex(int,int) -> do
nidefawl.qubes.block.Block -> IjIjllIjJiIjJiL1:
    nidefawl.qubes.block.Block[] registeredblocks -> if
    short[] registeredblockIds -> do
    nidefawl.qubes.block.Block[] block -> do
    java.lang.String[] NO_TEXTURES -> do
    nidefawl.qubes.block.Block air -> do
    nidefawl.qubes.block.Block grass -> if
    nidefawl.qubes.block.Block dirt -> for
    nidefawl.qubes.block.BlockGroupStones stones -> do
    nidefawl.qubes.block.Block water -> int
    nidefawl.qubes.block.Block ice -> new
    nidefawl.qubes.block.BlockGroupLogs logs -> do
    nidefawl.qubes.block.BlockGroup wood -> do
    nidefawl.qubes.block.Block quarter -> try
    nidefawl.qubes.block.BlockGroup bricks -> if
    nidefawl.qubes.block.BlockGroup stonebricks -> for
    nidefawl.qubes.block.BlockGroup smoothstones -> int
    nidefawl.qubes.block.BlockGroup stonepath -> else
    nidefawl.qubes.block.BlockGroup cobblestones -> new
    nidefawl.qubes.block.BlockGroup slabs -> try
    nidefawl.qubes.block.BlockGroup stairs -> byte
    nidefawl.qubes.block.BlockGroup walls -> case
    nidefawl.qubes.block.BlockGroup fences -> char
    nidefawl.qubes.block.Block pad -> byte
    int id -> do
    java.lang.String name -> do
    boolean transparent -> do
    java.lang.String[] textures -> if
    java.lang.String[] normalMaps -> int
    nidefawl.qubes.vec.AABBFloat blockBounds -> do
    int textureMode$539cac4e -> if
    nidefawl.qubes.models.qmodel.ModelBlock[] loadedModels -> do
    java.lang.String[] models -> for
    141:141:void preInit() -> do
    143:166:void postInit() -> if
    218:218:java.lang.String[] getTextures() -> do
    221:221:java.lang.String[] getNormalMaps() -> if
    225:229:nidefawl.qubes.block.Block setTextures(java.lang.String[]) -> do
    232:236:nidefawl.qubes.block.Block setNormalMaps(java.lang.String[]) -> if
    253:253:java.lang.String getName() -> do
    257:257:boolean isTransparent() -> do
    260:260:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    263:264:nidefawl.qubes.block.Block setTextureMode$37fab573(int) -> do
    267:267:int getTexturePasses() -> do
    285:296:int getTexture(int,int,int) -> do
    299:299:int getLODPass() -> if
    302:302:int getRenderPass() -> for
    305:305:int getRenderType() -> int
    308:308:boolean isValid(int) -> do
    311:311:nidefawl.qubes.block.Block get(int) -> if
    314:314:boolean applyAO() -> if
    317:317:boolean isOccluding() -> for
    321:324:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    327:327:float getAlpha() -> do
    330:330:int getLightValue() -> new
    337:338:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    341:365:boolean isVisibleBounds$7dfec731(int,int,nidefawl.qubes.vec.AABBFloat) -> do
    369:372:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    382:382:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    388:388:boolean isSlab() -> int
    394:394:boolean isStairs() -> new
    448:448:boolean isReplaceable() -> try
    468:473:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    476:476:boolean isFullBB() -> byte
    479:479:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    485:485:short[] getRegisteredIDs() -> do
    492:492:nidefawl.qubes.block.Block[] getRegisteredBlocks() -> do
    496:499:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    506:506:int getRenderShadow() -> try
    511:513:java.lang.String toString() -> toString
    517:521:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    525:525:boolean canBlockConnect$3e59abd6$2421c69d(int) -> if
    529:537:int getItems(java.util.List) -> do
    541:541:int getMeshedColor(nidefawl.qubes.meshing.BlockSurface) -> do
    579:579:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    587:587:int getInvRenderData(nidefawl.qubes.item.BlockStack) -> do
    593:593:float getInvRenderRotation() -> if
    604:607:int getNormalMap(int) -> do
    610:610:float getRoughness$13461e() -> for
    613:613:nidefawl.qubes.block.Block getBaseBlock() -> do
nidefawl.qubes.block.Block$1 -> llllL1IjJiIjjIll:
    int[] $SwitchMap$nidefawl$qubes$block$BlockTextureMode -> do
nidefawl.qubes.block.BlockAir -> llJill1LjIiJjIIj:
    33:33:nidefawl.qubes.block.Block setTextures(java.lang.String[]) -> do
    41:41:int getTexture(int,int,int) -> do
    45:45:int getRenderPass() -> for
    48:48:int getRenderType() -> int
    52:52:boolean applyAO() -> if
    55:55:boolean isOccluding() -> for
    59:59:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    62:62:float getAlpha() -> do
    65:65:int getLightValue() -> new
    70:70:boolean isVisibleBounds$7dfec731(int,int,nidefawl.qubes.vec.AABBFloat) -> do
    74:74:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    78:78:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    82:82:boolean isReplaceable() -> try
    87:87:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    90:90:boolean isFullBB() -> byte
    95:95:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    99:99:int getItems(java.util.List) -> do
    104:104:boolean canBlockConnect$3e59abd6$2421c69d(int) -> if
nidefawl.qubes.block.BlockDoubleCatTail -> iJjIllJiL1L1Ji:
    13:13:int getTexturePasses() -> do
    17:20:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockDoublePlant -> lliJJiIjL1llL1L1:
    29:29:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    39:39:int getRenderType() -> int
    44:44:boolean applyAO() -> if
    49:49:boolean isOccluding() -> for
    57:57:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    61:61:boolean isReplaceable() -> try
    65:65:boolean isFullBB() -> byte
    72:75:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    80:85:int getTexture(int,int,int) -> do
    90:90:int getRenderShadow() -> try
nidefawl.qubes.block.BlockFence -> L1jIL11LjIL1llIj:
    nidefawl.qubes.block.Block baseBlock -> case
    19:19:nidefawl.qubes.block.Block getBaseBlock() -> do
    23:32:int setFenceConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> do
    36:42:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    46:46:boolean canBlockConnect$3e59abd6$2421c69d(int) -> if
    59:59:int getLightValue() -> new
    64:64:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    69:69:float getAlpha() -> do
    73:79:int getTexture(int,int,int) -> do
    83:83:int getRenderType() -> int
    88:88:boolean isOccluding() -> for
    93:93:boolean isFullBB() -> byte
    98:98:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    103:103:int getRenderShadow() -> try
    108:124:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    129:181:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
nidefawl.qubes.block.BlockFlowerFMN -> jIllL1JiJilliJll:
    29:32:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    35:35:int getTexturePasses() -> do
    39:42:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockGrass -> L1JiL1jIjIlljIJi:
    19:21:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    25:34:int getTexture(int,int,int) -> do
    37:37:int getMeshedColor(nidefawl.qubes.meshing.BlockSurface) -> do
    41:41:int getTexturePasses() -> do
    45:45:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    49:54:int getNormalMap(int) -> do
nidefawl.qubes.block.BlockGrassBush -> iJL1jIIjjIjIiJ1L:
    27:27:boolean applyRandomOffset() -> case
    31:31:int getLODPass() -> if
    35:35:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
nidefawl.qubes.block.BlockGroup -> Ji1LL11Lll1LJiiJ:
    int NEXT_GROUP_ID -> do
    java.util.List blocks -> do
    24:26:void addBlock(nidefawl.qubes.block.Block) -> do
    java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupBricks -> llL1IjiJJiJiiJ:
    java.util.List stoneNames -> if
    27:27:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupCobbleStones -> iJL1JilllliJJiiJ:
    java.util.List stoneNames -> if
    29:29:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupFences -> iJ1LiJiJllL1Ji1L:
    java.util.List stoneNames -> if
    44:44:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupLeaves -> jIiJL1JiJiiJL1iJ:
    java.util.List leaveNames -> if
    23:23:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupLogs -> ll1L1LIj1LL1jI1L:
    java.util.List logNames -> if
    nidefawl.qubes.block.Block oak -> do
    35:35:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupModelledStones -> iJ1LllL1iJJillL1:
    java.util.List stoneNames -> if
    53:53:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupOres -> lliJL1JiL1L11LIj:
    java.util.List stoneNames -> if
    18:18:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupSlabs -> jI1LIjjIiJlljIll:
    java.util.List stoneNames -> if
    42:42:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupSmoothStones -> L1L1jIJiiJIjiJjI:
    java.util.List stoneNames -> if
    30:30:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStairs -> llL1IjjIJiiJlljI:
    java.util.List stoneNames -> if
    44:44:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStoneBricks -> jIjIJi1LIjlliJL1:
    java.util.List stoneNames -> if
    34:34:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStonePath -> jIiJJiL11LiJL1:
    java.util.List stoneNames -> if
    29:29:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStones -> IjiJ1LIj1L1LIjIj:
    java.util.List stoneNames -> if
    nidefawl.qubes.block.Block granite -> do
    nidefawl.qubes.block.Block basalt -> if
    nidefawl.qubes.block.Block marble -> for
    42:42:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupWalls -> Ji1LJilliJjI1LJi:
    java.util.List stoneNames -> if
    43:43:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupWood -> L11LjIllL11LIjJi:
    26:26:java.util.List getNames() -> do
nidefawl.qubes.block.BlockIce -> jIJi1LiJL11Lll1L:
    20:20:int getRenderPass() -> for
    25:25:boolean applyAO() -> if
    30:30:float getAlpha() -> do
    35:35:boolean isOccluding() -> for
    40:40:int getRenderShadow() -> try
    48:52:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    56:56:int getLODPass() -> if
    59:67:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    71:76:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    81:81:boolean isFullBB() -> byte
    85:85:int getRenderType() -> int
nidefawl.qubes.block.BlockLeaves -> lljIIjL1JiL1llIj:
    32:32:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    37:37:boolean applyAO() -> if
    42:42:boolean isOccluding() -> for
nidefawl.qubes.block.BlockLog -> IjlljIIjllJillL1:
    int index -> for
    40:66:int getTexture(int,int,int) -> do
    71:71:int getTexturePasses() -> do
    85:89:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    94:94:int getRenderType() -> int
nidefawl.qubes.block.BlockModelled -> Ijll1LjIJiJiJiL1:
    18:18:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    23:23:boolean isFullBB() -> byte
    27:27:boolean isTransparent() -> do
    31:31:int getLODPass() -> if
    35:35:int getRenderPass() -> for
    39:39:int getRenderShadow() -> try
    43:43:boolean isOccluding() -> for
    48:48:int getRenderType() -> int
nidefawl.qubes.block.BlockOre -> jIlliJjIlliJ1Lll:
    nidefawl.qubes.block.Block baseBlock -> case
    33:33:int getLightValue() -> new
    38:38:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    43:47:int getTexture(int,int,int) -> do
    52:52:int getTexturePasses() -> do
    68:72:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    76:76:int getNormalMap(int) -> do
    80:80:int getRenderType() -> int
nidefawl.qubes.block.BlockPane -> JillIjlljIIjjIjI:
    18:27:int setPaneConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    31:31:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    35:41:int getConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> if
    45:45:boolean canBlockConnect$3e59abd6$2421c69d(int) -> if
    53:53:int getRenderType() -> int
    59:59:int getRenderShadow() -> try
    64:64:boolean isOccluding() -> for
    69:69:boolean isFullBB() -> byte
    74:74:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    80:109:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    114:166:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
nidefawl.qubes.block.BlockPlantCrossedSquares -> iJJiJilliJ1LjI:
    boolean multipass -> do
    37:40:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    44:44:int getRenderType() -> int
    49:49:boolean isOccluding() -> for
    57:57:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    61:61:boolean isReplaceable() -> try
    65:65:boolean isFullBB() -> byte
    68:68:boolean applyRandomOffset() -> case
    72:75:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    80:80:int getRenderShadow() -> try
    83:83:int getTexturePasses() -> do
    87:90:int getTexture(int,int,int) -> do
    96:96:int getLODPass() -> if
nidefawl.qubes.block.BlockPlantFlat -> IjL1jI1LL1jIIj:
    32:32:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    36:36:int getRenderType() -> int
    41:41:boolean isOccluding() -> for
    46:46:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    50:50:boolean isReplaceable() -> try
    54:54:boolean isFullBB() -> byte
    61:68:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    73:73:int getRenderShadow() -> try
    79:79:int getLODPass() -> if
nidefawl.qubes.block.BlockQuarterBlock -> lllliJL1IjiJL1L1:
    short[] readOnly -> do
    36:40:short[] getSafeRead(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    45:49:nidefawl.qubes.chunk.blockdata.BlockDataQuarterBlock getSafeCast(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    54:60:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    63:69:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    73:98:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    102:106:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    111:128:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    132:138:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    144:197:int getItems(java.util.List) -> do
nidefawl.qubes.block.BlockSand -> L1lliJIjjI1LiJJi:
nidefawl.qubes.block.BlockSlab -> iJiJ1LL1IjIjiJll:
    nidefawl.qubes.block.Block baseBlock -> case
    int overrideTextureIdx -> for
    27:27:nidefawl.qubes.block.Block getBaseBlock() -> do
    42:42:boolean isOccluding() -> for
    48:48:int getLightValue() -> new
    53:53:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    58:58:float getAlpha() -> do
    63:63:boolean applyAO() -> if
    68:68:boolean isTransparent() -> do
    73:82:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    87:87:java.lang.String getName() -> do
    92:99:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    136:171:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    175:176:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    183:183:boolean isSlab() -> int
    188:194:int getTexture(int,int,int) -> do
    197:197:boolean isFullBB() -> byte
    200:200:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    205:215:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    219:220:int getItems(java.util.List) -> do
nidefawl.qubes.block.BlockSliced -> jIL1IjjIL1llIj:
    13:13:int getRenderType() -> int
nidefawl.qubes.block.BlockStairs -> iJ1LL1L1llL1lliJ:
    nidefawl.qubes.block.Block baseBlock -> case
    int overrideTextureIdx -> for
    int[] offsetXZ -> do
    27:27:nidefawl.qubes.block.Block getBaseBlock() -> do
    31:31:boolean isUpsideDown(int) -> for
    45:45:boolean isOccluding() -> for
    51:51:int getLightValue() -> new
    56:56:boolean applyAO() -> if
    61:61:boolean isTransparent() -> do
    66:85:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    89:108:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    113:113:java.lang.String getName() -> do
    118:118:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    123:123:float getAlpha() -> do
    128:135:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    165:186:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    192:192:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    198:198:boolean isStairs() -> new
    203:209:int getTexture(int,int,int) -> do
    212:212:boolean isFullBB() -> byte
    228:261:int stairTypeAt(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    265:322:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    330:389:void setStairBB(nidefawl.qubes.vec.AABBFloat,int,int,int,int) -> do
    391:391:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
nidefawl.qubes.block.BlockStone -> Ij1LL1IjIjL1IjjI:
    15:15:float getRoughness$13461e() -> for
nidefawl.qubes.block.BlockStoneModelled -> lllljIL1L1iJ1LJi:
    nidefawl.qubes.block.Block baseBlock -> case
    int overrideTextureIdx -> for
    22:28:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockTextureMode -> jIJiL1jIjIiJiJJi:
    int DEFAULT$539cac4e -> do
    int TOP$539cac4e -> if
    int TOP_BOTTOM$539cac4e -> for
    int SUBTYPED_TEX_PER_TYPE$539cac4e -> int
    int[] $VALUES$4b414b93 -> do
    10:10:int[] values$747846c() -> do
nidefawl.qubes.block.BlockVine -> jIiJL1Ij1LL1L1Ji:
    33:33:int getRenderType() -> int
    38:38:int getLODPass() -> if
    93:93:boolean isOccluding() -> for
    98:98:boolean isFullBB() -> byte
    103:103:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    108:108:int getRenderShadow() -> try
    113:113:boolean isReplaceable() -> try
    118:124:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    129:129:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    134:134:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    138:170:int setSelectionBB(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    175:175:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    179:179:int getInvRenderData(nidefawl.qubes.item.BlockStack) -> do
    185:185:float getInvRenderRotation() -> if
nidefawl.qubes.block.BlockWall -> L1IjIjlliJiJIjL1:
    nidefawl.qubes.block.Block baseBlock -> case
    int overrideTextureIdx -> for
    23:23:nidefawl.qubes.block.Block getBaseBlock() -> do
    27:40:int setWallConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> do
    44:50:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    55:55:boolean canBlockConnect$3e59abd6$2421c69d(int) -> if
    73:73:int getLightValue() -> new
    78:78:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    83:83:float getAlpha() -> do
    87:93:int getTexture(int,int,int) -> do
    97:97:int getRenderType() -> int
    103:103:boolean isOccluding() -> for
    108:108:boolean isFullBB() -> byte
    113:113:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    118:118:int getRenderShadow() -> try
    123:135:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    140:192:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    197:198:int getItems(java.util.List) -> do
nidefawl.qubes.block.BlockWater -> iJlliJJiL1iJJi:
    13:13:int getRenderPass() -> for
    18:18:boolean applyAO() -> if
    23:23:float getAlpha() -> do
    28:28:boolean isOccluding() -> for
    33:33:boolean isReplaceable() -> try
    38:38:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    43:43:int getRenderShadow() -> try
    50:50:float getRoughness$13461e() -> for
nidefawl.qubes.block.BlockWaterLily -> JiL1lliJ1LL1jIll:
    21:21:int getRenderType() -> int
nidefawl.qubes.block.BlockWood -> jIiJJiL11L1LlliJ:
    int index -> for
nidefawl.qubes.block.IDMappingBlocks -> iJiJIjllIjll1LL1:
    boolean CHANGED -> do
    boolean LOADED -> if
    int HIGHEST_BLOCK_ID -> do
    com.google.common.collect.ImmutableBiMap map -> do
    java.lang.Object sync -> do
    30:65:void load() -> do
    67:108:void save() -> if
    110:139:int get(java.lang.String) -> do
nidefawl.qubes.chat.client.ChatLine -> IjjIiJ1LllIjiJ:
    java.lang.String rawMessage -> do
    long receiveTime -> do
nidefawl.qubes.chat.client.ChatManager -> llJijI1LIjiJIjiJ:
    java.util.ArrayList line -> do
    java.util.ArrayList hist -> if
    boolean saveHistory -> do
    nidefawl.qubes.chat.client.ChatManager instance -> do
    37:37:nidefawl.qubes.chat.client.ChatManager getInstance() -> do
    69:69:void syncChannels$6ba92955() -> do
    93:106:void saveInputHistory() -> if
    109:111:void addHistory(java.lang.String) -> do
    115:115:int getHistorySize() -> do
    120:120:java.lang.String getHistory(int) -> do
    125:125:int indexOfHistory(java.lang.String) -> do
    130:132:void removeHistory(int) -> do
    137:139:void addHistory(int,java.lang.String) -> do
nidefawl.qubes.chunk.Chunk -> iJllL1L1JiIjjIjI:
    nidefawl.qubes.world.World world -> do
    int x -> do
    int z -> if
    int worldHeightBits -> for
    int height -> int
    short[] blocks -> do
    nidefawl.qubes.chunk.ChunkDataSliced2 blockMetadata -> do
    nidefawl.qubes.chunk.blockdata.BlockDataSliced blockData -> do
    byte[] blockLight -> do
    int[] heightMap -> do
    byte[] biomes -> if
    byte[] waterMask -> for
    boolean isValid -> do
    76:76:int getWater(int,int,int) -> do
    80:80:int getTypeId(int,int,int) -> if
    93:93:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    96:96:int getData(int,int,int) -> for
    172:185:boolean setType(int,int,int,int) -> do
    244:252:int getLight(int,int,int) -> int
    405:425:boolean setLights(byte[],nidefawl.qubes.vec.BlockBoundingBox) -> do
    433:433:java.lang.String toString() -> toString
nidefawl.qubes.chunk.ChunkData -> ll1LL1jIllIjIjJi:
    boolean setByte(int,int,int,boolean,int) -> do
nidefawl.qubes.chunk.ChunkDataSliced2 -> L1jIllJiL1iJ1LiJ:
    short[][] array -> do
    45:58:boolean setByte(int,int,int,boolean,int) -> do
    62:69:short[] getArray(int,boolean) -> do
nidefawl.qubes.chunk.ChunkManager -> jIjIIjJiiJjIL11L:
    nidefawl.qubes.world.World world -> do
    nidefawl.qubes.chunk.ChunkTable table -> do
    nidefawl.qubes.chunk.ChunkTable makeChunkTable() -> do
    27:27:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    31:31:int getChunksLoaded() -> do
nidefawl.qubes.chunk.ChunkTable -> JiL1jIJillll1LjI:
    nidefawl.qubes.chunk.Chunk[][] values -> do
    int size -> do
    int halfSize -> if
    int mswLow -> for
    int mswHigh -> int
    int lswLow -> new
    int lswHigh -> try
    66:71:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    234:234:java.util.Iterator iterator() -> iterator
nidefawl.qubes.chunk.ChunkTable$ChunkRegionTableIterator -> JiiJL1iJjIllJill:
    nidefawl.qubes.chunk.Chunk value -> do
    int msw -> do
    int lsw -> if
    nidefawl.qubes.chunk.ChunkTable table -> do
    nidefawl.qubes.chunk.ChunkTable this$0 -> if
    190:204:boolean hasNext() -> hasNext
    216:216:void remove() -> remove
    177:177:java.lang.Object next() -> next
nidefawl.qubes.chunk.blockdata.BlockData -> L1iJIjIjIjJiJiJi:
    20:26:boolean isEqual(nidefawl.qubes.chunk.blockdata.BlockData,nidefawl.qubes.chunk.blockdata.BlockData) -> do
    boolean compareData(nidefawl.qubes.chunk.blockdata.BlockData) -> do
    int getLength() -> do
    42:46:nidefawl.qubes.chunk.blockdata.BlockData fromType(int) -> do
    int writeData(byte[],int) -> do
    int readData(byte[],int) -> if
    63:66:int writeDataToStream(java.io.DataOutput) -> do
    nidefawl.qubes.chunk.blockdata.BlockData copy() -> do
nidefawl.qubes.chunk.blockdata.BlockDataQuarterBlock -> L1IjIjll1LJiIjJi:
    short[] blockIDs -> do
    byte[] blockMeta -> do
    21:28:boolean compareData(nidefawl.qubes.chunk.blockdata.BlockData) -> do
    38:38:int getLength() -> do
    43:48:int writeData(byte[],int) -> do
    53:57:int readData(byte[],int) -> if
    67:72:void setTypeAndData(int,int,int,int,int) -> do
    86:87:int getType(int,int,int) -> do
    97:100:int idx(int,int,int) -> if
    105:110:nidefawl.qubes.chunk.blockdata.BlockData copy() -> do
nidefawl.qubes.chunk.blockdata.BlockDataSliced -> iJJiJi1L1LjIiJjI:
    nidefawl.qubes.chunk.blockdata.BlockData[][] array -> do
    48:55:nidefawl.qubes.chunk.blockdata.BlockData[] getArray(int,boolean) -> do
nidefawl.qubes.chunk.client.ChunkManagerClient -> JiL1Ij1LjIllJi1L:
    15:15:nidefawl.qubes.chunk.ChunkTable makeChunkTable() -> do
nidefawl.qubes.config.AbstractYMLConfig -> L1JiL1jI1LiJL1Ji:
    java.util.Map map -> do
    25:39:void write(java.io.File) -> do
    74:86:void load(java.io.File) -> if
    99:102:java.lang.String getString(java.lang.String,java.lang.String) -> do
    113:116:int getInt(java.lang.String,int) -> do
    127:130:float getFloat(java.lang.String,float) -> do
    141:142:void setString(java.lang.String,java.lang.String) -> do
    152:153:void setInt(java.lang.String,int) -> do
    157:158:void setFloat(java.lang.String,float) -> do
    void setDefaults() -> do
    void load() -> if
    void save() -> for
nidefawl.qubes.config.ClientSettings -> L1L1lliJiJL1llIj:
    int chunkLoadDistance -> do
    int shadowDrawMode -> if
    int ssr -> for
    int aa -> int
    int smaaQuality -> new
    float thirdpersonDistance -> do
    int ao -> try
    27:34:void setDefaults() -> do
    38:45:void load() -> if
    49:56:void save() -> for
nidefawl.qubes.config.InvalidConfigException -> jIJiL1llllIjjIIj:
nidefawl.qubes.config.WorkingEnv -> JiJillllJiL1jIiJ:
    java.io.File workingDir -> do
    java.io.File assetDir -> if
    java.io.File config -> for
    java.io.File playerdata -> int
    19:34:void init(java.lang.String) -> do
    37:37:java.io.File getAssetFolder() -> do
    43:43:java.io.File getConfigFolder() -> if
nidefawl.qubes.crafting.CraftingCategory -> iJ1LJiIjIjiJjIIj:
    nidefawl.qubes.crafting.CraftingCategory[] categories -> do
    nidefawl.qubes.crafting.CraftingCategory tools -> do
    nidefawl.qubes.crafting.CraftingCategory wood -> if
    nidefawl.qubes.crafting.CraftingCategory stone -> for
    nidefawl.qubes.crafting.CraftingCategory blocks -> int
    int id -> do
    java.util.ArrayList recipes -> do
    java.util.HashMap map -> do
    38:46:void addRecipe(java.lang.String,nidefawl.qubes.crafting.recipes.CraftingRecipe) -> do
nidefawl.qubes.crafting.CraftingManagerBase -> IjlljIJiIj1Lllll:
    int id -> do
    int amount -> if
    long startTime -> do
    long endTime -> if
    boolean finished -> do
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    41:54:int calcMaxAmount(nidefawl.qubes.crafting.recipes.CraftingRecipe,nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    57:57:int getAmount() -> do
    60:60:int getId() -> if
    63:63:long getStartTime() -> do
    66:66:long getEndTime() -> if
    69:69:nidefawl.qubes.crafting.recipes.CraftingRecipe getRecipe() -> do
    72:72:boolean isRunning() -> do
    75:75:boolean isFinished() -> if
nidefawl.qubes.crafting.CraftingManagerClient -> iJ1LJiL1lliJjIL1:
    nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry guiElement -> do
    32:46:void handleRequest(int,nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
nidefawl.qubes.crafting.recipes.CraftingRecipe -> L1llJijI1LL1lljI:
    int NEXT_ID -> if
    nidefawl.qubes.item.BaseStack[] in -> do
    nidefawl.qubes.item.BaseStack[] out -> if
    int id -> do
    nidefawl.qubes.item.BaseStack preview -> do
    nidefawl.qubes.crafting.CraftingCategory category -> do
    64:70:void setInput(nidefawl.qubes.item.BaseStack[]) -> do
    72:81:void setOutput(nidefawl.qubes.item.BaseStack[]) -> if
nidefawl.qubes.crafting.recipes.CraftingRecipes -> iJIjllIj1LiJIjiJ:
    java.util.ArrayList all -> do
    nidefawl.qubes.crafting.recipes.CraftingRecipe[] recipesArray -> do
    22:23:void add(nidefawl.qubes.crafting.recipes.CraftingRecipe) -> do
    27:117:void init() -> do
    120:120:nidefawl.qubes.crafting.recipes.CraftingRecipe getRecipeId(int) -> do
nidefawl.qubes.entity.Entity -> L1L1jI1LlliJiJjI:
    int NEXT_ENT_ID -> int
    int id -> do
    nidefawl.qubes.world.World world -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    nidefawl.qubes.vec.Vec3D lastPos -> if
    nidefawl.qubes.vec.Vec3D mot -> for
    nidefawl.qubes.vec.Vec3D lastMot -> int
    float yaw -> do
    float lastYaw -> if
    float yawBodyOffset -> for
    float lastYawBodyOffset -> int
    float pitch -> new
    float lastPitch -> try
    boolean noclip -> do
    boolean hitGround -> if
    nidefawl.qubes.vec.AABB aabb -> do
    nidefawl.qubes.vec.AABB aabb2 -> if
    nidefawl.qubes.vec.AABB aabb3 -> for
    nidefawl.qubes.vec.AABB aabb4 -> int
    nidefawl.qubes.util.CollisionQuery coll -> do
    nidefawl.qubes.vec.Vector3f renderPos -> do
    nidefawl.qubes.vec.Vector3f renderRot -> if
    nidefawl.qubes.vec.Vec3D remotePos -> new
    nidefawl.qubes.vec.Vector3f remoteRotation -> for
    int rotticks -> if
    int posticks -> for
    double width -> do
    double height -> if
    double length -> for
    float timeJump -> byte
    float timePunch -> case
    boolean flagRemove -> for
    java.util.Random random -> do
    60:60:int hashCode() -> hashCode
    65:65:boolean equals(java.lang.Object) -> equals
    69:72:void tickUpdate() -> do
    77:77:boolean doesFly() -> do
    80:91:void postStep() -> if
    93:101:void preStep() -> for
    103:213:void step() -> int
    216:216:float getGravity() -> do
    220:221:void move(nidefawl.qubes.vec.Vec3D) -> do
    251:251:void readClientData(nidefawl.qubes.nbt.Tag) -> do
    nidefawl.qubes.entity.EntityType getEntityType() -> do
    349:349:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityAI -> JijI1LJiL1Ij1LIj:
    nidefawl.qubes.entity.ai.TaskManager taskManager -> do
    nidefawl.qubes.entity.ai.AINav nav -> do
    nidefawl.qubes.entity.ai.AIMove move -> do
    float moveForward -> char
    float landMovementFactor -> else
    float airMovementFactor -> goto
    22:57:void tickUpdate() -> do
    61:70:void preStep() -> for
nidefawl.qubes.entity.EntityAnimal -> JiIjJiiJ1LiJiJIj:
nidefawl.qubes.entity.EntityCat -> iJ1LIj1LL11Lll:
    14:14:nidefawl.qubes.entity.EntityType getEntityType() -> do
    19:19:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityChicken -> JiIjjIIjjI1LJi1L:
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityDog -> jIiJjIJiL1jIJi:
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityDuck -> JiIjllL1JiL1JiiJ:
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityGoat -> JijIllL1JilliJll:
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityPig -> IjL1L1JiiJiJL11L:
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityPony -> ll1LjIL1JiiJll1L:
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityPuppy -> llJilljIiJllJiIj:
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntitySheep -> L1IjL1IjlliJIj1L:
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityType -> lliJll1LjIL1jIiJ:
    nidefawl.qubes.entity.EntityType[] mapping -> do
    nidefawl.qubes.entity.EntityType PLAYER -> do
    nidefawl.qubes.entity.EntityType CAT -> if
    nidefawl.qubes.entity.EntityType CHICKEN -> for
    nidefawl.qubes.entity.EntityType DOG -> int
    nidefawl.qubes.entity.EntityType DUCK -> new
    nidefawl.qubes.entity.EntityType GOAT -> try
    nidefawl.qubes.entity.EntityType PIG -> byte
    nidefawl.qubes.entity.EntityType PONY -> case
    nidefawl.qubes.entity.EntityType PUPPY -> char
    nidefawl.qubes.entity.EntityType SHEEP -> else
    java.lang.Class clazz -> do
    double width -> do
    double length -> if
    double height -> for
    27:41:void load() -> do
    62:66:nidefawl.qubes.entity.Entity newById(int) -> do
    71:73:nidefawl.qubes.entity.Entity newInstance() -> do
nidefawl.qubes.entity.Player -> L1iJL11LJiiJlljI:
    int punchTicks -> int
    nidefawl.qubes.inventory.PlayerInventory inventory -> do
    nidefawl.qubes.inventory.slots.SlotsInventory slotsInventory -> do
    nidefawl.qubes.inventory.slots.SlotsCrafting[] slotsCrafting -> do
    nidefawl.qubes.inventory.PlayerInventoryCrafting[] inventoryCraft -> do
    35:35:nidefawl.qubes.entity.EntityType getEntityType() -> do
    39:41:void tickUpdate() -> do
    52:52:nidefawl.qubes.item.BaseStack getEquippedItem() -> do
    61:73:nidefawl.qubes.inventory.BaseInventory getInv(int) -> do
    77:89:nidefawl.qubes.inventory.slots.Slots getSlots(int) -> do
    93:93:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.PlayerRemote -> jIjIL1llL1jIll1L:
    26:29:void readClientData(nidefawl.qubes.nbt.Tag) -> do
    32:58:void preStep() -> for
    61:61:void step() -> int
    64:64:void postStep() -> if
    68:69:void tickUpdate() -> do
nidefawl.qubes.entity.PlayerSelf -> llllllJill1L1LjI:
    float forward -> char
    float strafe -> else
    float maxSpeed -> this
    boolean fly -> int
    boolean jumped -> new
    float sneak -> goto
    float jump -> long
    nidefawl.qubes.PlayerProfile profile -> do
    nidefawl.qubes.network.client.ClientHandler clientHandler -> do
    nidefawl.qubes.crafting.CraftingManagerClient[] crafting -> do
    47:47:nidefawl.qubes.crafting.CraftingManagerClient getCrafting(int) -> do
    91:187:void tickUpdate() -> do
    189:189:boolean doesFly() -> do
    194:194:float getGravity() -> do
    207:207:nidefawl.qubes.entity.EntityType getEntityType() -> do
nidefawl.qubes.entity.ai.AIMove -> iJjIJilljIjIJi1L:
    nidefawl.qubes.entity.EntityAI entity -> do
    double x -> do
    double y -> if
    double z -> for
    float speed -> do
    boolean needsUpdate -> do
nidefawl.qubes.entity.ai.AINav -> JiiJiJiJL1IjL1ll:
    nidefawl.qubes.path.PathFinder finder -> do
    nidefawl.qubes.vec.Vec3D goalPos -> do
    nidefawl.qubes.vec.Vec3D tmp -> if
    nidefawl.qubes.path.Path path -> do
    int ticks -> do
    float speed -> do
    nidefawl.qubes.entity.EntityAI entity -> do
    35:52:nidefawl.qubes.path.Path setPath(nidefawl.qubes.path.Path) -> do
    84:84:boolean hasPath() -> do
nidefawl.qubes.entity.ai.AITask -> L1lljIjIiJIjjIIj:
    nidefawl.qubes.entity.EntityAI entity -> do
    14:14:boolean shouldExecute() -> do
    18:18:boolean keepExecuting() -> if
    22:22:void stop() -> do
    25:25:void start() -> if
    28:28:void update() -> for
nidefawl.qubes.entity.ai.AITaskWander -> iJIjiJll1LjIllL1:
    int ticks -> do
    nidefawl.qubes.path.RandomPosGen gen -> do
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.path.Path p -> do
    19:25:boolean keepExecuting() -> if
    29:34:boolean shouldExecute() -> do
    38:39:void update() -> for
    42:44:void start() -> if
    47:49:void stop() -> do
nidefawl.qubes.entity.ai.TaskEntry -> iJjIJillJill1LjI:
    nidefawl.qubes.entity.ai.AITask task -> do
    int priority -> do
    boolean running -> do
    boolean enabled -> if
nidefawl.qubes.entity.ai.TaskManager -> jIiJ1LjIJijIjI:
    java.util.List tasks -> do
    46:58:boolean canSchedule(nidefawl.qubes.entity.ai.TaskEntry,java.util.List) -> do
nidefawl.qubes.font.FontRenderer -> JiJiIj1LL1IjJi:
    java.util.HashMap fonts -> do
    nidefawl.qubes.font.TrueTypeFont trueTypeFont -> do
    float size -> do
    int style -> if
    int maxWidth -> do
    float shadowOffset -> if
    java.lang.String[] fontNames -> do
    18:22:void destroy() -> do
    38:44:nidefawl.qubes.font.FontRenderer get(int,float,int) -> do
    59:59:void init() -> if
    93:93:float drawString(java.lang.String,float,float,int,boolean,float) -> do
    97:115:float drawString(java.lang.String,float,float,int,boolean,float,int) -> do
    123:123:float getStringWidth(java.lang.String) -> do
    140:140:float getLineHeight() -> do
    147:147:int centerY(int) -> do
nidefawl.qubes.font.IStringHistory -> iJ1LIjjIjIIjjIIj:
    void addHistory(java.lang.String) -> do
    int getHistorySize() -> do
    java.lang.String getHistory(int) -> do
    int indexOfHistory(java.lang.String) -> do
    void removeHistory(int) -> do
    void addHistory(int,java.lang.String) -> do
nidefawl.qubes.font.ITextEdit -> jIL1iJjI1LL1jI1L:
    void submit(nidefawl.qubes.font.TextInput) -> do
    void onEscape$2dc3d817() -> do
nidefawl.qubes.font.TextInput -> jI1L1L1LiJjIIjJi:
    nidefawl.qubes.font.TrueTypeFont trueType -> do
    java.lang.String editText -> do
    java.lang.String searchPattern -> if
    boolean mouseDown -> do
    boolean rightMouseDown -> if
    boolean did -> for
    int selStart -> do
    int selEnd -> if
    float shiftPX -> do
    int mpos -> for
    int tick -> int
    java.lang.String prevText -> for
    nidefawl.qubes.font.IStringHistory history -> do
    int commandScroll -> new
    boolean focused -> int
    boolean multiline -> new
    nidefawl.qubes.font.FontRenderer font -> do
    int xPos -> try
    int yPos -> byte
    int width -> case
    int height -> char
    nidefawl.qubes.font.ITextEdit itextedit -> do
    71:95:void calculatePreview() -> do
    319:329:void makeCursorVisible() -> if
    332:332:boolean hasSelection() -> do
    347:361:java.lang.String replaceSelection(java.lang.String) -> do
    365:383:void insertTextAtCursor(java.lang.String) -> do
    615:615:int getRight() -> do
    618:618:int getBottom() -> if
nidefawl.qubes.font.TrueTypeFont -> iJllL11LL1L1lliJ:
    int[] colorMap -> do
    int texW -> int
    org.lwjgl.stb.STBTTPackedchar$Buffer chardata -> do
    int font_tex -> do
    org.lwjgl.stb.STBTTAlignedQuad q -> do
    org.lwjgl.stb.STBTTAlignedQuad q2 -> if
    java.nio.FloatBuffer xb -> do
    java.nio.FloatBuffer yb -> if
    java.nio.FloatBuffer xb2 -> for
    java.nio.FloatBuffer yb2 -> int
    int rangeStart -> if
    int numChars -> for
    org.lwjgl.stb.STBTTFontinfo info -> do
    float ascent -> for
    float descent -> int
    float lineGap -> new
    float drawedHeight -> do
    float spaceWidth -> try
    float lineOffset -> if
    float size -> byte
    52:55:int getControlChar(int) -> do
    148:153:float getCharWidth(int) -> do
    158:187:float getWidthAtLine(java.lang.String) -> do
    190:214:float getWidth(java.lang.String) -> if
    217:219:void start(float,float) -> do
    221:221:float getXPos() -> do
    227:229:void readQuad(int) -> do
    231:235:void renderQuad(nidefawl.qubes.gl.Tess,float,float) -> do
    238:263:int getCharPositionFromXCoord(java.lang.String,double,float) -> do
    272:272:boolean isValid() -> do
    277:286:void release() -> do
    300:300:float getCharHeight() -> if
    306:425:float drawString(nidefawl.qubes.gl.Tess,float,float,java.lang.String,int,boolean,float,int,int,float) -> do
    429:432:int getIndex(int) -> if
nidefawl.qubes.gl.AbstractTesselatorState -> JiIjJiJiIjjIL11L:
    int vertexcount -> do
    boolean useColorPtr -> do
    boolean useTexturePtr -> if
    boolean useNormalPtr -> for
    boolean useUINTPtr -> int
    nidefawl.qubes.gl.GLVBO getVBO() -> do
    33:42:int getVSize() -> do
    86:87:void drawQuads() -> do
    90:94:void bindAndDraw(int) -> do
nidefawl.qubes.gl.BufferedMatrix -> lljIL1llIjJiIjiJ:
    nidefawl.qubes.vec.Matrix4f inv -> do
    boolean needInv -> do
    java.nio.FloatBuffer cur -> do
    java.nio.FloatBuffer curInv -> if
    26:34:void update() -> do
    37:38:java.nio.FloatBuffer get() -> do
    42:46:java.nio.FloatBuffer getInv() -> if
    56:61:void createInv() -> if
    67:71:void free() -> for
nidefawl.qubes.gl.Camera -> iJJill1L1LjI1Lll:
    float pitchAngle -> do
    float bearingAngle -> if
    nidefawl.qubes.vec.Vector3f position -> do
    nidefawl.qubes.vec.Vector3f prevposition -> if
    nidefawl.qubes.vec.Matrix4f viewMatrix -> do
    nidefawl.qubes.vec.Matrix4f thirdPersonMat -> if
    nidefawl.qubes.vec.Vector3f thirdPersonOffset -> for
    37:41:void setPosition(float,float,float) -> do
    51:67:void setOrientation(float,float,boolean,float) -> do
    73:73:nidefawl.qubes.vec.Vector3f getPosition() -> do
    89:89:nidefawl.qubes.vec.Matrix4f getViewMatrix() -> do
    96:96:nidefawl.qubes.vec.Vector3f getCameraOffset() -> if
nidefawl.qubes.gl.Engine -> iJJilljIiJIjlliJ:
    nidefawl.qubes.vec.BlockPos GLOBAL_OFFSET -> do
    nidefawl.qubes.vec.BlockPos LAST_REPOS -> if
    java.util.Map bufferBindingPoints -> do
    int NEXT_BUFFER_BINDING_POINT -> do
    boolean initRenderers -> do
    java.nio.IntBuffer viewportBuf -> do
    java.nio.FloatBuffer position -> do
    java.nio.IntBuffer allocBuffer -> if
    nidefawl.qubes.gl.BufferedMatrix projection -> do
    nidefawl.qubes.gl.BufferedMatrix view -> if
    nidefawl.qubes.gl.BufferedMatrix viewInvYZ -> for
    nidefawl.qubes.gl.BufferedMatrix viewprojection -> int
    nidefawl.qubes.gl.BufferedMatrix modelviewprojection -> new
    nidefawl.qubes.vec.Matrix4f modelviewprojectionInv -> do
    nidefawl.qubes.gl.BufferedMatrix modelview -> try
    nidefawl.qubes.gl.BufferedMatrix normalMatrix -> byte
    nidefawl.qubes.gl.BufferedMatrix orthoP -> case
    nidefawl.qubes.gl.BufferedMatrix orthoMV -> char
    nidefawl.qubes.gl.BufferedMatrix orthoMVP -> else
    nidefawl.qubes.gl.BufferedMatrix ortho3DP -> goto
    nidefawl.qubes.gl.BufferedMatrix ortho3DMV -> long
    nidefawl.qubes.gl.BufferedMatrix tempMatrix -> this
    nidefawl.qubes.gl.BufferedMatrix identity -> void
    nidefawl.qubes.vec.Vector3f pxOffset -> do
    nidefawl.qubes.vec.TransformStack pxStack -> do
    nidefawl.qubes.vec.Matrix4f invertYZ -> if
    nidefawl.qubes.gl.FrameBuffer fbScene -> do
    nidefawl.qubes.gl.FrameBuffer fbDbg -> if
    float znear -> do
    float zfar -> if
    nidefawl.qubes.gl.TesselatorState fullscreenquad -> do
    nidefawl.qubes.gl.TesselatorState quad -> if
    nidefawl.qubes.vec.Frustum camFrustum -> do
    nidefawl.qubes.vec.Vector3f up -> try
    nidefawl.qubes.vec.Vector3f lightPosition -> if
    nidefawl.qubes.vec.Vector3f lightDirection -> for
    nidefawl.qubes.gl.Camera camera -> do
    nidefawl.qubes.gl.ShadowProjector shadowProj -> do
    nidefawl.qubes.render.WorldRenderer worldRenderer -> do
    nidefawl.qubes.render.ShadowRenderer shadowRenderer -> do
    nidefawl.qubes.render.BlurRenderer blurRenderer -> do
    nidefawl.qubes.render.FinalRenderer outRenderer -> do
    nidefawl.qubes.render.region.RegionRenderer regionRenderer -> do
    nidefawl.qubes.render.LightCompute lightCompute -> do
    nidefawl.qubes.meshing.MeshThread regionRenderThread -> do
    float aspectRatio -> for
    int fieldOfView -> if
    boolean renderWireFrame -> if
    boolean isDepthMask -> int
    boolean isScissors -> new
    boolean updateRenderOffset -> for
    nidefawl.qubes.render.gui.SingleBlockRenderer blockRender -> do
    nidefawl.qubes.render.gui.SingleBlockDraw blockDraw -> do
    nidefawl.qubes.item.ItemRenderer itemRender -> do
    nidefawl.qubes.gl.GLVAO active -> do
    int[] viewport -> do
    nidefawl.qubes.shader.ShaderBuffer debugOutput -> do
    nidefawl.qubes.shader.ShaderBuffer ssbo_lights -> if
    nidefawl.qubes.shader.ShaderBuffer ssbo_model_modelmat -> for
    nidefawl.qubes.shader.ShaderBuffer ssbo_model_normalmat -> int
    nidefawl.qubes.shader.ShaderBuffer ssbo_model_bonemat -> new
    nidefawl.qubes.world.SunLightModel sunlightmodel -> do
    nidefawl.qubes.gl.ReallocIntBuffer[] buffers -> do
    nidefawl.qubes.vec.Vector3f vOrigin -> int
    nidefawl.qubes.vec.Vector3f vDir -> new
    nidefawl.qubes.vec.Vector3f vDirTmp -> byte
    nidefawl.qubes.vec.Vector3f vTarget -> case
    nidefawl.qubes.vec.Vector3f t -> char
    123:128:void bindVAO(nidefawl.qubes.gl.GLVAO) -> do
    131:132:void bindIndexBuffer(int) -> do
    135:136:void bindBuffer(int) -> if
    144:149:boolean checkGLError(java.lang.String) -> do
    197:223:void init() -> do
    226:298:void resize(int,int) -> do
    300:314:void updateOrthoMatrix(float,float) -> do
    317:318:void drawFullscreenQuad() -> if
    321:322:void drawQuad() -> for
    326:326:nidefawl.qubes.gl.BufferedMatrix getMatSceneP() -> do
    329:329:nidefawl.qubes.gl.BufferedMatrix getMatSceneV() -> if
    332:332:nidefawl.qubes.gl.BufferedMatrix getMatSceneV_YZ_Inv() -> for
    335:335:nidefawl.qubes.gl.BufferedMatrix getMatSceneVP() -> int
    339:339:nidefawl.qubes.gl.BufferedMatrix getMatSceneMV() -> new
    342:342:nidefawl.qubes.gl.BufferedMatrix getMatSceneMVP() -> try
    346:346:nidefawl.qubes.gl.BufferedMatrix getMatSceneNormal() -> byte
    356:356:nidefawl.qubes.gl.BufferedMatrix getMatOrthoMVP() -> case
    359:359:nidefawl.qubes.gl.BufferedMatrix getMatOrtho3DMV() -> char
    363:363:nidefawl.qubes.gl.BufferedMatrix getMatOrtho3DP() -> else
    367:367:nidefawl.qubes.gl.BufferedMatrix getTempMatrix() -> goto
    374:374:nidefawl.qubes.gl.BufferedMatrix getIdentityMatrix() -> long
    379:408:void updateCamera() -> int
    438:438:nidefawl.qubes.gl.FrameBuffer getSceneFB() -> do
    444:455:void flushRenderTasks() -> new
    475:478:void setLightPosition(nidefawl.qubes.vec.Vector3f) -> do
    481:484:void updateShadowProjections$133aeb() -> try
    487:492:void stop() -> byte
    503:536:void updateMouseOverView(float,float,boolean) -> do
    563:564:void setSceneFB(nidefawl.qubes.gl.FrameBuffer) -> do
    567:576:java.nio.IntBuffer glGenBuffers(int) -> do
    580:584:void deleteBuffers(int[]) -> do
    588:590:void toggleWireFrame() -> case
    621:626:int getBindingPoint(java.lang.String) -> do
    630:632:void enableDepthMask(boolean) -> do
    635:637:void enableScissors() -> char
    639:641:void disableScissors() -> else
    643:646:void setOverrideScissorTest(boolean) -> if
    650:655:void restoreScissorTest() -> goto
    657:658:void restoreDepthMask() -> long
    661:662:void setOverrideDepthMask(boolean) -> for
    665:672:void setViewport(int,int,int,int) -> do
    675:676:void setDefaultViewport() -> this
    679:679:nidefawl.qubes.world.SunLightModel getSunLightModel() -> do
    683:694:nidefawl.qubes.gl.ReallocIntBuffer getIntBuffer() -> do
nidefawl.qubes.gl.FrameBuffer -> IjJiIjiJll1LiJll:
    int FRAMEBUFFERS -> do
    int renderWidth -> if
    int renderHeight -> for
    int fb -> int
    java.nio.IntBuffer drawBufAtt -> do
    boolean hasDepth -> do
    boolean isShadowDepthBuffer -> if
    int numColorTextures -> new
    int depthTexture -> try
    int[] colorAttTextures -> do
    int[] colorAttFormats -> if
    int[] colorAttMinFilters -> for
    int[] colorAttMagFilters -> int
    boolean[] clearBuffer -> do
    float[][] clearColor -> do
    int colorTexExtFmt -> byte
    int colorTexExtType -> case
    59:69:nidefawl.qubes.gl.FrameBuffer make(nidefawl.qubes.util.IResourceManager,int,int,int,boolean) -> do
    72:72:nidefawl.qubes.gl.FrameBuffer make(nidefawl.qubes.util.IResourceManager,int,int,int) -> do
    76:83:void setColorAtt(int,int) -> do
    87:93:void setFilter(int,int,int) -> do
    95:104:void setClearColor(int,float,float,float,float) -> do
    116:171:void setup(nidefawl.qubes.util.IResourceManager) -> do
    174:175:void unbindFramebuffer() -> do
    178:179:void unbindReadFramebuffer() -> if
    183:184:void bind() -> for
    187:188:void bindRead() -> int
    243:246:int getTexture(int) -> do
    250:253:int getDepthTex() -> do
    258:261:void clearDepth() -> new
    265:268:void clearColor() -> try
    272:277:void clearColorBlack() -> byte
    286:302:void clearFrameBuffer() -> case
    305:324:void release() -> char
    341:341:int getType$37b71a40() -> if
nidefawl.qubes.gl.GLDebugTextures -> llL1iJjIlliJllL1:
    int format -> do
    java.lang.String name -> do
    java.lang.String pass -> if
    int h -> if
    int w -> for
    int tex -> int
    int d -> new
    int flags -> try
    boolean valid -> if
    boolean show -> do
    java.util.HashMap textures -> do
    java.util.HashMap alltextures -> if
    nidefawl.qubes.gl.GLDebugTextures selTex -> do
    boolean triggered -> for
    45:46:void readTexture(java.lang.String,java.lang.String,int) -> do
    48:79:int readTexture(java.lang.String,java.lang.String,int,int) -> do
    83:85:void release() -> for
    87:93:void onResize() -> do
    96:201:void drawAll(int,int) -> do
    204:221:void bindShader() -> int
    229:229:nidefawl.qubes.gl.GLDebugTextures getSelected() -> do
    237:244:void drawFullScreen(nidefawl.qubes.gl.GLDebugTextures) -> do
    246:246:boolean isShow() -> do
    249:250:void setShow(boolean) -> do
    253:272:void toggleDebugTex() -> if
nidefawl.qubes.gl.GLTriBuffer -> jIiJjIll1LlljIiJ:
    nidefawl.qubes.gl.GLVBO vbo -> do
    nidefawl.qubes.gl.GLVBO vboIndices -> if
    int triCount -> do
    int vertexCount -> if
    int idxCount -> for
    30:43:int upload(nidefawl.qubes.gl.VertexBuffer) -> do
    56:63:void draw() -> do
    69:75:void release() -> if
nidefawl.qubes.gl.GLVAO -> IjJijIJiiJjIIjjI:
    int NEXT_VAO_ID -> for
    nidefawl.qubes.gl.GLVAO[] vaoList -> if
    int stride -> do
    int vaoId -> if
    nidefawl.qubes.gl.GLVAO vaoBlocksShadow -> do
    nidefawl.qubes.gl.GLVAO vaoBlocksShadowTextured -> if
    nidefawl.qubes.gl.GLVAO vaoModel -> for
    nidefawl.qubes.gl.GLVAO vaoModelGPUSkinned -> int
    nidefawl.qubes.gl.GLVAO vaoBlocks -> new
    nidefawl.qubes.gl.GLVAO[] vaoTesselator -> do
    18:21:void initVAOs() -> do
    23:23:void init() -> if
nidefawl.qubes.gl.GLVAO$1 -> IjiJIj1LiJL1IjjI:
    26:38:void init() -> if
nidefawl.qubes.gl.GLVAO$2 -> iJjI1LjIiJJijIiJ:
    42:60:void init() -> if
nidefawl.qubes.gl.GLVAO$3 -> L1IjIjIjIjjIL11L:
    65:86:void init() -> if
nidefawl.qubes.gl.GLVAO$4 -> iJL1iJ1L1LJi1LjI:
    90:120:void init() -> if
nidefawl.qubes.gl.GLVAO$5 -> iJL1L11LIjlljIll:
    124:151:void init() -> if
nidefawl.qubes.gl.GLVAO$6 -> iJ1Lllll1LiJIjll:
    int val$tessSetting -> for
    159:197:void init() -> if
nidefawl.qubes.gl.GLVBO -> JiIjIjL1jIL1JijI:
    int ALLOC_VBOS -> do
    int ALLOC_VBOS_TERRAIN -> if
    int vboId -> for
    long vboSize -> do
    int usage -> int
    boolean isTerrain -> do
    28:35:int getVboId() -> do
    44:63:void upload(int,java.nio.ByteBuffer,long) -> do
    67:75:void release() -> do
nidefawl.qubes.gl.GPUVendor -> jIiJiJiJllllJiL1:
    int NVIDIA$109b11a9 -> for
    int AMD$109b11a9 -> int
    int INTEL$109b11a9 -> do
    int OTHER$109b11a9 -> if
    int[] $VALUES$2cc5efdc -> do
    18:36:int parse$7272f880(java.lang.String) -> do
nidefawl.qubes.gl.Memory -> jIIjL1JijIJiL1Ij:
    int mallocd -> do
    java.util.HashSet ptrs -> do
    25:30:java.nio.FloatBuffer createFloatBuffer(int) -> do
    34:39:java.nio.IntBuffer createIntBuffer(int) -> do
    52:57:java.nio.DoubleBuffer createDoubleBuffer(int) -> do
    61:61:java.nio.FloatBuffer createFloatBufferAligned(int,int) -> do
    70:80:java.nio.ByteBuffer createByteBufferAligned(int,int) -> do
    90:94:java.nio.ByteBuffer reallocByteBufferAligned(java.nio.ByteBuffer,int,int) -> do
    109:111:java.nio.IntBuffer createIntBufferGC(int) -> if
    118:126:void free(java.nio.FloatBuffer) -> do
    132:140:void free(java.nio.ByteBuffer) -> do
    143:144:java.nio.IntBuffer createIntBufferHeap(int) -> for
    152:153:java.nio.FloatBuffer createFloatBufferHeap(int) -> if
nidefawl.qubes.gl.ReallocIntBuffer -> Ij1LIjjIJiiJ1L:
    java.nio.ByteBuffer buffers -> do
    java.nio.IntBuffer intbuffers -> do
    boolean inUse -> do
    41:53:void reallocBuffer(int) -> do
    75:79:void put(int[],int,int) -> do
nidefawl.qubes.gl.ShadowProjector -> iJlliJiJIjllIjll:
    nidefawl.qubes.vec.Matrix4f[] shadowSplitProj -> do
    nidefawl.qubes.gl.BufferedMatrix[] shadowSplitMVP -> do
    float[] shadowSplitDepth -> do
    nidefawl.qubes.vec.Frustum[] shadowCamFrustum -> do
    nidefawl.qubes.vec.Matrix4f newMat -> do
    nidefawl.qubes.vec.Matrix4f newMatInv -> if
    nidefawl.qubes.vec.Matrix4f matLookAt -> for
    nidefawl.qubes.vec.Matrix4f matLookAtInv -> int
    nidefawl.qubes.vec.Matrix4f matOrtho -> new
    nidefawl.qubes.vec.Vector3f frustumCenter -> do
    nidefawl.qubes.vec.Vector3f tmp -> if
    nidefawl.qubes.vec.Vector3f eye -> for
    nidefawl.qubes.vec.Vector3f[] furstumCornersIn -> do
    nidefawl.qubes.vec.Vector3f[] furstumCornersOut -> if
    178:178:java.nio.FloatBuffer getSMVP(int) -> do
nidefawl.qubes.gl.Tess -> jIlliJ1LJiL11LIj:
    java.lang.String[] attributes -> do
    boolean littleEndian -> new
    nidefawl.qubes.gl.Tess instance -> do
    nidefawl.qubes.gl.Tess tessFont -> if
    int[] rawBuffer -> do
    int rgba -> if
    int uintLSB -> for
    float u -> do
    float v -> if
    int normal -> int
    float offsetX -> for
    float offsetY -> int
    float offsetZ -> new
    boolean isSoftTesselator -> try
    nidefawl.qubes.gl.ReallocIntBuffer bufInt -> do
    int vboIdx -> new
    nidefawl.qubes.gl.GLVBO[] vbo -> do
    61:68:void add(float,float,float,float,float) -> do
    80:81:void add(float,float) -> do
    84:92:void setNormals(float,float,float) -> do
    95:125:void add(float,float,float) -> if
    137:152:void setColorRGBAF(float,float,float,float) -> do
    155:160:void setUIntLSB(int) -> if
    169:178:void setColor(int,int) -> do
    181:182:void setColorF(int,float) -> do
    185:206:void draw(int,nidefawl.qubes.gl.AbstractTesselatorState) -> do
    209:209:nidefawl.qubes.gl.GLVBO getVBO() -> do
    213:214:void draw(int) -> for
    218:219:void drawQuads() -> do
    224:231:void resetState() -> if
    234:238:void destroy() -> int
    241:244:void setOffset(float,float,float) -> for
    247:249:void destroyAll() -> for
nidefawl.qubes.gl.TesselatorState -> iJjIL11L1Lll:
    nidefawl.qubes.gl.GLVBO vbo -> do
    13:13:nidefawl.qubes.gl.GLVBO getVBO() -> do
nidefawl.qubes.gl.VertexBuffer -> IjllJijIjI1LJiIj:
    int[] buffer -> do
    int[] triIdxBuffer -> if
    int triIdxPos -> do
    int pos -> int
    int left -> new
    int left2 -> try
    int vertexCount -> if
    int faceCount -> for
    40:46:void reset() -> do
    53:59:int realloc(int) -> do
    66:72:int reallocTriIdxBuffer(int) -> if
    78:85:void put(int) -> do
    87:95:void putIdx(int) -> if
    100:101:void increaseVert() -> if
    106:107:void increaseFace() -> for
    150:151:int storeVertexData(nidefawl.qubes.gl.ReallocIntBuffer) -> do
    158:159:int storeIndexData(nidefawl.qubes.gl.ReallocIntBuffer) -> if
    174:175:void incVertCount(int) -> for
    178:184:void putTriIndex(int[]) -> do
nidefawl.qubes.gui.AbstractUI -> Ji1LjIIjL1JiIjjI:
    nidefawl.qubes.gui.AbstractUI parent -> do
    int id -> do
    int width -> if
    int height -> for
    int posX -> int
    int posY -> new
    int[] overridebounds -> do
    boolean hovered -> do
    boolean enabled -> if
    boolean draw -> for
    boolean focused -> int
    int zIndex -> try
    nidefawl.qubes.gui.AbstractUI selectedButton -> if
    int color -> byte
    float alpha -> do
    int color2 -> case
    float alpha2 -> if
    int color3 -> char
    int color4 -> else
    int color5 -> goto
    int color6 -> long
    float boxSigma -> new
    float shadowSigma -> for
    float round -> int
    int extendx -> this
    int extendy -> void
    31:35:void saveBounds() -> if
    37:41:void restoreBounds() -> for
    43:45:void setSize(int,int) -> do
    47:49:void setPos(int,int) -> if
    56:56:int bottom() -> do
    59:59:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> do
    62:62:void add(nidefawl.qubes.gui.AbstractUI) -> do
    65:65:void update() -> int
    68:68:boolean mouseOver(double,double) -> do
    72:72:boolean handleMouseUp$ec53e7c(nidefawl.qubes.gui.Gui) -> do
    75:75:boolean handleMouseDown$ec53e7c() -> do
    78:78:boolean onKeyPress(int,int,int,int) -> do
    81:81:boolean onTextInput(int) -> do
    85:86:void setFocus() -> new
    105:110:void resetShape() -> try
    113:140:void renderRoundedBoxShadow(float,float,float,float,float,int,float,boolean) -> do
    142:167:void renderRoundedBoxShadowInverse(float,float,float,float,float,int,float,boolean) -> if
    169:184:void renderOutlinedBox() -> byte
    186:193:void renderBox() -> case
    198:218:void renderBox(boolean,boolean,int,int) -> do
    220:240:void renderBox2(boolean,boolean,int,int) -> if
    242:242:int getWindowPosX() -> if
    245:245:int getWindowPosY() -> for
    249:262:void renderSlotBackground(float,float,float,float,float,int,float,boolean,float) -> do
    266:316:void renderSlots$4c71f93e(nidefawl.qubes.inventory.slots.Slots,double,double,float,float) -> do
    318:324:void renderSlotOverlay(nidefawl.qubes.inventory.slots.Slot,float,float) -> do
    327:329:void setDisableDraw(boolean) -> do
nidefawl.qubes.gui.Gui -> JillIjjIIjllIj1L:
    java.util.ArrayList buttons -> do
    java.util.ArrayList prebackground -> if
    boolean firstOpen -> new
    nidefawl.qubes.gui.AbstractUI popup -> for
    int FONT_SIZE_WINDOW_TITLE -> break
    int FONT_SIZE_BUTTON -> catch
    35:35:nidefawl.qubes.gui.AbstractUI getPopup() -> do
    38:38:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> do
    41:44:void add(nidefawl.qubes.gui.AbstractUI) -> do
    55:57:void clearElements() -> char
    59:70:void sortElements() -> else
    73:77:void remove(nidefawl.qubes.gui.AbstractUI) -> if
    80:88:void setPopup(nidefawl.qubes.gui.AbstractUI) -> for
    100:131:void renderButtons(float,double,double) -> a_
    134:138:void update() -> int
    141:141:void onClose() -> goto
    144:183:boolean onMouseClick(int,int) -> do
    187:187:double mouseOffsetY() -> do
    191:191:double mouseOffsetX() -> if
    195:195:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    199:216:boolean onKeyPress(int,int,int,int) -> do
    220:221:void close() -> long
    224:232:boolean onTextInput(int) -> do
    239:251:void renderBackground$2a14f497() -> this
    257:257:boolean canResize() -> if
    261:261:boolean onWheelScroll(double,double) -> if
nidefawl.qubes.gui.Gui$1 -> JijIiJIjlljIL1ll:
    59:59:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.gui.GuiAction -> L1L1iJjI1L1LIjll:
    int mouseAction -> do
    17:17:boolean isAct(int) -> do
nidefawl.qubes.gui.GuiBG -> jIjIiJIjL1jIJiJi:
    9:13:void render(float,double,double) -> do
    17:17:void initGui(boolean) -> if
nidefawl.qubes.gui.GuiCached -> jIjIiJ1LJiL11L1L:
    nidefawl.qubes.gui.Gui gui -> do
    nidefawl.qubes.gl.FrameBuffer fbDbg -> do
    boolean refresh -> try
    24:25:void setPos(int,int) -> if
    29:37:void setSize(int,int) -> do
    40:55:void render(float,double,double) -> do
    57:59:void refresh() -> do
    62:62:void initGui(boolean) -> if
nidefawl.qubes.gui.GuiChatInput -> jI1LL1jIjIjI1Lll:
    nidefawl.qubes.gui.controls.TextField field -> do
    nidefawl.qubes.gui.GuiOverlayChat overlay -> do
    int mouseResize -> class
    40:43:void setSize(int,int) -> do
    47:64:void initGui(boolean) -> if
    68:68:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    73:75:boolean onKeyPress(int,int,int,int) -> do
    80:88:boolean onMouseClick(int,int) -> do
    92:97:boolean over(double,double) -> for
    103:128:void render(float,double,double) -> do
    132:139:void submit(nidefawl.qubes.font.TextInput) -> do
    143:144:void onEscape$2dc3d817() -> do
nidefawl.qubes.gui.GuiConnecting -> iJIjjIjIiJiJ1L:
    nidefawl.qubes.font.FontRenderer font -> do
    java.lang.String stateStr -> do
    nidefawl.qubes.network.client.ThreadConnect thread -> do
    24:32:void initGui(boolean) -> if
    35:40:void update() -> int
    43:49:void render(float,double,double) -> do
    52:56:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.GuiControls -> L1JiJijIllllL11L:
    nidefawl.qubes.gui.GuiControls$Control selected -> do
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.gui.controls.Button back -> do
    java.util.List list -> do
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
    nidefawl.qubes.input.Keybinding inUseKey -> do
    112:143:void initGui(boolean) -> if
    146:149:boolean onMouseClick(int,int) -> do
    153:155:void update() -> int
    159:189:void render(float,double,double) -> do
    192:216:boolean onKeyPress(int,int,int,int) -> do
    222:234:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    237:241:boolean onWheelScroll(double,double) -> if
nidefawl.qubes.gui.GuiControls$Control -> iJlljIIjIjJillIj:
    nidefawl.qubes.input.Keybinding b -> do
    41:92:void render(float,double,double) -> do
    96:96:void initGui(boolean) -> if
nidefawl.qubes.gui.GuiDisconnected -> L1IjjIJiJillJiiJ:
    nidefawl.qubes.font.FontRenderer font -> do
    java.lang.String reason -> do
    20:28:void initGui(boolean) -> if
    31:37:void render(float,double,double) -> do
    40:43:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.GuiGameMenu -> lljI1LIjIjllL1L1:
    nidefawl.qubes.gui.controls.Button resume -> do
    nidefawl.qubes.gui.controls.Button settings -> if
    nidefawl.qubes.gui.controls.Button controls -> for
    nidefawl.qubes.gui.controls.Button back -> int
    23:56:void initGui(boolean) -> if
    59:61:void render(float,double,double) -> do
    63:78:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.GuiMainMenu -> L1jIL1iJIjJi1L1L:
    nidefawl.qubes.gui.controls.TextField field -> do
    nidefawl.qubes.gui.controls.TextField fieldN -> if
    nidefawl.qubes.gui.controls.Button connect -> do
    nidefawl.qubes.gui.controls.Button settings -> if
    nidefawl.qubes.gui.controls.Button controls -> for
    nidefawl.qubes.gui.controls.Button quit -> int
    nidefawl.qubes.gui.controls.Button crash -> new
    31:81:void initGui(boolean) -> if
    83:83:boolean onMouseClick(int,int) -> do
    87:89:void render(float,double,double) -> do
    95:111:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    115:116:void submit(nidefawl.qubes.font.TextInput) -> do
    121:128:void connect() -> void
    131:139:void onEscape$2dc3d817() -> do
nidefawl.qubes.gui.GuiOverlayChat -> lliJiJL1L1lliJll:
    nidefawl.qubes.font.FontRenderer font -> do
    boolean mouseRes -> try
    27:33:void render(float,double,double) -> do
    37:37:void initGui(boolean) -> if
    46:98:void renderAt(int,boolean) -> do
nidefawl.qubes.gui.GuiOverlayStats -> llJiL1IjjIiJJi1L:
    nidefawl.qubes.font.FontRenderer font -> if
    nidefawl.qubes.font.FontRenderer fontSmall -> do
    java.util.ArrayList info1 -> for
    java.util.ArrayList info -> int
    java.lang.String stats -> do
    java.lang.String statsRight -> if
    long messageTime -> do
    java.lang.String message -> int
    java.lang.String stats5 -> for
    nidefawl.qubes.util.SysInfo sysInfo -> do
    138:209:void render(float,double,double) -> do
    212:214:void setMessage(java.lang.String) -> do
    218:218:void initGui(boolean) -> if
nidefawl.qubes.gui.GuiSelectBlock -> IjiJL1lliJlliJjI:
    nidefawl.qubes.font.FontRenderer font -> do
    java.util.List blocks -> do
    nidefawl.qubes.gui.controls.Button fakeButton -> do
    nidefawl.qubes.item.BlockStack sel -> do
    float rot -> new
    float lastRot -> try
    42:84:void initGui(boolean) -> if
    90:97:void update() -> int
    101:253:void render(float,double,double) -> do
    256:263:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    267:275:boolean onKeyPress(int,int,int,int) -> do
nidefawl.qubes.gui.GuiSelectWorld -> IjiJjIiJIjJiL1L1:
    nidefawl.qubes.font.FontRenderer font -> do
    24:32:void initGui(boolean) -> if
    35:57:void render(float,double,double) -> do
    60:63:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    67:75:boolean onKeyPress(int,int,int,int) -> do
nidefawl.qubes.gui.GuiSettings -> jIllJiIjIj1LL1Ij:
    int nextID -> class
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.gui.controls.Button back -> do
    java.util.List list -> do
    nidefawl.qubes.gui.GuiSettings$Setting distanceSetting -> do
    nidefawl.qubes.gui.GuiSettings$Setting smaaQSetting -> if
    60:145:void initGui(boolean) -> if
    148:159:void render(float,double,double) -> do
    162:183:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.GuiSettings$1 -> Ji1LiJllllIjL1:
    73:73:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$2 -> lljIiJjIL1jIjIll:
    java.lang.Integer[] val$values -> do
    82:85:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$3 -> L1Ji1LJillll1LIj:
    90:93:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$4 -> iJL1llIjJi1LiJIj:
    98:101:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$5 -> L11L1LJiJi1LL11L:
    106:110:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$6 -> lljIIjjIllL1iJll:
    115:118:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$7 -> jIL1Ji1LlliJIjll:
    124:127:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$8 -> IjIjIjIj1LjIJiIj:
    nidefawl.qubes.gui.GuiSettings$Setting val$s -> do
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    170:175:void call$133686ba(int) -> do
nidefawl.qubes.gui.GuiSettings$Setting -> L1iJJillJiIjjIIj:
    java.lang.Object[] vals -> do
    nidefawl.qubes.gui.controls.ComboBox box -> do
    39:39:void callback(int) -> do
nidefawl.qubes.gui.Tooltip -> iJ1L1LIjiJ:
    nidefawl.qubes.gui.Tooltip$ItemToolTip item -> do
nidefawl.qubes.gui.Tooltip$1 -> jIIjIjjI1LJiL1L1:
nidefawl.qubes.gui.Tooltip$ItemToolTip -> jIjIIjiJjI1LJiiJ:
    nidefawl.qubes.item.BaseStack stack -> do
    java.lang.String title -> do
    nidefawl.qubes.font.FontRenderer fr -> do
    22:38:nidefawl.qubes.gui.Tooltip$ItemToolTip set(nidefawl.qubes.item.BaseStack,nidefawl.qubes.inventory.slots.Slot,nidefawl.qubes.gui.windows.GuiWindow) -> do
    44:55:void render(float,double,double) -> do
    59:59:void initGui(boolean) -> if
nidefawl.qubes.gui.controls.Button -> IjJiIjjIiJIjiJ1L:
    java.lang.String text -> do
    nidefawl.qubes.font.FontRenderer font -> do
    26:54:void render(float,double,double) -> do
    59:59:void initGui(boolean) -> if
nidefawl.qubes.gui.controls.ColorPicker -> IjJi1LiJIjL1IjJi:
    nidefawl.qubes.gui.controls.Button[] colorPick -> do
    float valH -> new
    float valS -> try
    float valL -> byte
    int rgb -> break
    29:81:void render(float,double,double) -> do
    109:126:void initGui(boolean) -> if
    130:135:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> do
nidefawl.qubes.gui.controls.ComboBox -> lllllliJIjIjL1ll:
    nidefawl.qubes.font.FontRenderer font -> do
    int textColorHover -> break
    java.lang.Object value -> do
    boolean isOpen -> new
    int sel -> catch
    java.lang.String string -> do
    boolean drawTitle -> case
    boolean titleLeft -> try
    boolean canexpandHorizontally -> byte
    int titleWidth -> class
    nidefawl.qubes.gui.controls.ComboBox$ComboBoxList comboBoxList -> do
    nidefawl.qubes.gui.Gui gui -> do
    int scrollbarwidth -> const
    73:73:void initGui(boolean) -> if
    389:458:void render(float,double,double) -> do
    21:21:nidefawl.qubes.font.FontRenderer access$000(nidefawl.qubes.gui.controls.ComboBox) -> do
nidefawl.qubes.gui.controls.ComboBox$CallBack -> L1L11LiJIjjIL1Ji:
    void call$133686ba(int) -> do
nidefawl.qubes.gui.controls.ComboBox$ComboBoxList -> iJllIjJiJiIjllll:
    nidefawl.qubes.gui.controls.PopupHolder parentScreen -> do
    nidefawl.qubes.gui.controls.ComboBox$CallBack callBack -> do
    nidefawl.qubes.gui.controls.ComboBox box -> do
    java.lang.Object[] values -> do
    int size -> break
    int heightPerEntry -> catch
    boolean showScrollBar -> new
    int scrollOffset -> class
    int showMax -> const
    boolean isScrolling -> try
    int scrollBeginY -> final
    113:114:void initGui(boolean) -> if
    117:150:boolean onKeyPress(int,int,int,int) -> do
    158:174:boolean mouseOver(double,double) -> do
    181:186:boolean handleMouseDown$ec53e7c() -> do
    195:363:void render(float,double,double) -> do
nidefawl.qubes.gui.controls.PopupHolder -> llllIjllL1llJiIj:
    void setPopup(nidefawl.qubes.gui.AbstractUI) -> for
    nidefawl.qubes.gui.AbstractUI getPopup() -> do
nidefawl.qubes.gui.controls.ProgressBar -> JijIL1jIL1lllliJ:
    float progress -> new
    float lastProgress -> try
    nidefawl.qubes.font.FontRenderer fr -> do
    java.lang.String s -> do
    22:24:void update() -> int
    28:56:void render(float,double,double) -> do
    60:60:void initGui(boolean) -> if
    63:65:void setProgress(float) -> do
nidefawl.qubes.gui.controls.ScrollList -> JiL1jIIjllL1iJ:
    nidefawl.qubes.font.FontRenderer font -> do
    float scrollOffset -> try
    nidefawl.qubes.gui.controls.Button scrollbarbutton -> do
    float scrollY -> new
    52:60:float getContentHeight() -> do
    65:149:void render(float,double,double) -> do
    153:153:void initGui(boolean) -> if
    156:156:boolean onMouseClick(int,int) -> do
    165:168:boolean onWheelScroll(double,double) -> if
    172:177:double mouseOffsetY() -> do
    181:181:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.controls.TextField -> llL1L1jIll1LjIiJ:
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.font.TextInput inputRenderer -> do
    36:39:void setPos(int,int) -> if
    43:46:void setSize(int,int) -> do
    49:65:void render(float,double,double) -> do
    68:68:boolean mouseOver(double,double) -> do
    74:74:void initGui(boolean) -> if
    77:77:boolean handleMouseUp$ec53e7c(nidefawl.qubes.gui.Gui) -> do
    81:89:boolean handleMouseDown$ec53e7c() -> do
    93:97:boolean onKeyPress(int,int,int,int) -> do
    101:105:boolean onTextInput(int) -> do
nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry -> jIIjIjjIjIIjL1ll:
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    nidefawl.qubes.gui.crafting.GuiRecipeOutPreviewItemSlot slotPreview -> do
    nidefawl.qubes.gui.controls.ProgressBar progress -> do
    nidefawl.qubes.crafting.CraftingManagerClient mgr -> do
    37:81:void render(float,double,double) -> do
    85:106:void initGui(boolean) -> if
    109:109:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    118:120:void update() -> int
    123:134:void updateProgress() -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect -> jIjIL1IjL1:
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$RecipeSlot selected -> do
    nidefawl.qubes.gui.GuiBG bg -> do
    nidefawl.qubes.gui.controls.ScrollList scr2 -> do
    java.util.List catButtons -> do
    nidefawl.qubes.gui.controls.TextField txtAmount -> do
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat cat -> do
    nidefawl.qubes.gui.controls.Button btnCraft -> do
    nidefawl.qubes.gui.controls.Button btnIncr -> if
    nidefawl.qubes.gui.controls.Button btnDecr -> for
    nidefawl.qubes.gui.controls.Button btnMax -> int
    float entryw -> new
    int cols -> class
    352:352:java.lang.String getTitle() -> do
    360:428:void initGui(boolean) -> if
    431:458:void setCat(nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat) -> do
    499:499:boolean onMouseClick(int,int) -> do
    505:512:void update() -> int
    533:534:void renderFrame(float,double,double) -> if
    536:587:void render(float,double,double) -> do
    590:590:boolean onKeyPress(int,int,int,int) -> do
    599:674:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    686:700:void updateProgress() -> void
    747:764:void renderSlotOverlay(nidefawl.qubes.inventory.slots.Slot,float,float) -> do
    817:822:void showButtons(boolean) -> for
    824:827:boolean onWheelScroll(double,double) -> if
    831:831:void submit(nidefawl.qubes.font.TextInput) -> do
    834:834:void onEscape$2dc3d817() -> do
    42:42:nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat access$000(nidefawl.qubes.gui.crafting.GuiCraftingSelect) -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect$1 -> JiiJiJ1LjIiJ1LiJ:
    705:705:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat -> L1L1lliJjIIjiJIj:
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat category -> do
    int catid -> break
    94:94:nidefawl.qubes.gui.controls.Button getScrollbarButton() -> do
    99:164:void render(float,double,double) -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat -> jIllllllL1L1jI1L:
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
    java.util.List list -> do
    nidefawl.qubes.crafting.CraftingCategory craftingCategory -> do
    nidefawl.qubes.crafting.CraftingManagerClient craftingClient -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlSubCat -> Jill1LJijIIjiJll:
    java.lang.String string -> do
    java.util.List list -> if
    boolean expanded -> new
    int rows -> break
    java.util.List slots -> do
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat parentCat -> do
    275:311:void render(float,double,double) -> do
    315:331:void initGui(boolean) -> if
    334:346:int layout() -> int
nidefawl.qubes.gui.crafting.GuiCraftingSelect$PreviewSlots -> ll1L1LjI1LJiiJll:
    790:795:void update() -> do
    799:799:nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect$RecipeSlot -> JijIjIIjIjiJJi:
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    int maxAmount -> break
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlSubCat guiControlSubCat -> do
    183:183:void initGui(boolean) -> if
    186:196:void update() -> int
    200:253:void render(float,double,double) -> do
nidefawl.qubes.gui.crafting.GuiRecipeOutPreviewItemSlot -> IjiJiJ1LL1iJIjL1:
    nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry ctrl -> do
    26:26:void initGui(boolean) -> if
    30:94:void render(float,double,double) -> do
nidefawl.qubes.gui.windows.GuiColor -> IjJiIjll1LllJiJi:
    nidefawl.qubes.gui.controls.ColorPicker colorPick -> do
    15:15:java.lang.String getTitle() -> do
    19:37:void initGui(boolean) -> if
    39:39:boolean canResize() -> if
    43:49:void render(float,double,double) -> do
    55:58:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
nidefawl.qubes.gui.windows.GuiContext -> JiiJjIllIjiJ1L:
    nidefawl.qubes.gui.controls.TextField input -> do
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
nidefawl.qubes.gui.windows.GuiInventory -> L1IjlliJ1L1L1LiJ:
    13:13:java.lang.String getTitle() -> do
    17:36:void initGui(boolean) -> if
    39:42:void render(float,double,double) -> do
nidefawl.qubes.gui.windows.GuiInventoryResult -> JijIiJL11LiJ1L1L:
    nidefawl.qubes.inventory.slots.Slots slots -> do
    int getInventory() -> int
    66:94:void initGui(boolean) -> if
    97:105:void render(float,double,double) -> do
    109:113:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> if
    118:134:boolean onMouseClick(int,int) -> do
nidefawl.qubes.gui.windows.GuiInventoryResult$GuiInventoryResult1 -> iJJiiJ1L1LjIIjiJ:
    21:21:int getInventory() -> int
nidefawl.qubes.gui.windows.GuiInventoryResult$GuiInventoryResult2 -> jIjIjIIjL1L11L:
    27:27:int getInventory() -> int
nidefawl.qubes.gui.windows.GuiInventoryResult$GuiInventoryResult3 -> jIL1JiL1iJllJijI:
    33:33:int getInventory() -> int
nidefawl.qubes.gui.windows.GuiInventoryResult$GuiInventoryResult4 -> L1JiiJJijIJill:
    39:39:int getInventory() -> int
nidefawl.qubes.gui.windows.GuiWindow -> IjllIjIjllIj1LiJ:
    boolean visible -> try
    nidefawl.qubes.font.FontRenderer font -> do
    25:31:void initGui(boolean) -> if
    33:33:java.lang.String getTitle() -> do
    47:48:void setFocus() -> new
    51:51:boolean hasFocus() -> for
    54:58:void open() -> break
    61:64:void close() -> long
    67:69:void onClose() -> goto
    72:82:boolean mouseOver(double,double) -> do
    101:101:boolean canResize() -> if
    106:163:void renderFrame(float,double,double) -> if
    192:203:void onResize(double,double) -> do
    207:236:boolean onMouseClick(int,int) -> do
    239:239:int getWindowPosX() -> if
    242:242:int getWindowPosY() -> for
nidefawl.qubes.gui.windows.GuiWindowInventoryBase -> L11LL1llL11L1LJi:
    nidefawl.qubes.inventory.slots.Slots slots -> do
    21:24:void renderSlots(float,double,double) -> for
    26:38:boolean onMouseClick(int,int) -> do
    41:41:boolean canResize() -> if
nidefawl.qubes.gui.windows.GuiWindowManager -> llIjIjjIjIiJlljI:
    nidefawl.qubes.gui.windows.GuiWindowManager singleton -> do
    java.util.Map windowList -> do
    nidefawl.qubes.gui.windows.GuiWindow windowFocus -> for
    nidefawl.qubes.gui.windows.GuiWindow dragged -> do
    nidefawl.qubes.gui.windows.GuiWindow resized -> if
    nidefawl.qubes.gui.Tooltip tooltip -> do
    25:25:nidefawl.qubes.gui.windows.GuiWindowManager getInstance() -> do
    29:35:void setWindowFocus(nidefawl.qubes.gui.windows.GuiWindow) -> do
    91:96:int getHighestIndex() -> do
    122:141:nidefawl.qubes.gui.windows.GuiWindow openWindow(java.lang.Class,boolean) -> do
    145:145:nidefawl.qubes.gui.windows.GuiWindow openWindow(java.lang.Class) -> do
    149:154:java.lang.Object getWindow(java.lang.Class) -> do
    158:162:boolean anyWindowVisible() -> do
    244:245:void render(float,double,double) -> do
    314:319:void setTooltip(nidefawl.qubes.gui.Tooltip) -> do
    326:326:void initGui(boolean) -> if
    343:343:nidefawl.qubes.gui.windows.GuiWindow getWindowFocus() -> do
    346:357:boolean onMouseClick(int,int) -> do
    360:374:nidefawl.qubes.gui.windows.GuiWindow getMouseOver(double,double) -> do
    377:385:void mouseMove(double,double) -> do
    388:392:boolean onKeyPress(int,int,int,int) -> do
    396:400:boolean onWheelScroll(double,double) -> do
    403:425:void onWindowClosed(nidefawl.qubes.gui.windows.GuiWindow) -> if
    427:431:void onWindowOpened$1570f19f() -> do
    433:438:void update() -> if
nidefawl.qubes.hex.HexCell -> iJJiIjL1IjjI1LiJ:
    int x -> do
    int z -> if
    nidefawl.qubes.hex.HexagonGridStorage grid -> do
    29:33:double getDistanceCenter(double,double) -> do
    37:37:double getCenterX() -> do
    41:41:double getCenterY() -> if
    63:83:int getClosesCorner(double,double) -> do
nidefawl.qubes.hex.HexagonGrid -> jIjI1L1Lll1LL1ll:
    double radius -> do
    double height -> if
    double width -> for
    double hwidth -> int
    double ttheight -> new
    double[] sinCos -> do
    int[] offset -> do
    57:57:double getCenterX(int,int) -> do
    111:111:long offset(int,int,int) -> do
nidefawl.qubes.hex.HexagonGridStorage -> JiL1iJJiJiL1IjJi:
    int max -> do
    java.util.HashMap map -> do
    java.util.HashMap oobmap -> if
    43:55:java.lang.Object getPos(long) -> do
    65:66:java.lang.Object blockToHex(int,int) -> for
    java.lang.Object loadCell(int,int) -> if
    java.lang.Object oobCell(int,int) -> do
nidefawl.qubes.input.DigController -> IjL11LIjJillL1iJ:
    int stage -> do
    boolean digging -> do
    int speed -> if
    int tick -> for
    nidefawl.qubes.vec.BlockPos mouseOver -> do
    nidefawl.qubes.vec.BlockPos lastMouseOver -> if
    nidefawl.qubes.util.RayTrace$RayTraceIntersection intersect -> do
    int transaction -> int
    int[] stageTex -> do
    81:85:void endDigging() -> do
    125:135:void sendDigState(int) -> do
nidefawl.qubes.input.GameMode -> ll1LIjL11LJiiJIj:
    nidefawl.qubes.input.GameMode PLAY -> do
    nidefawl.qubes.input.GameMode BUILD -> if
    nidefawl.qubes.input.GameMode EDIT -> for
    nidefawl.qubes.input.GameMode SELECT -> int
    nidefawl.qubes.input.GameMode[] $VALUES -> do
    6:6:nidefawl.qubes.input.GameMode[] values() -> values
    6:6:nidefawl.qubes.input.GameMode valueOf(java.lang.String) -> valueOf
nidefawl.qubes.input.InputController -> lliJL11LJijIjI1L:
    nidefawl.qubes.config.AbstractYMLConfig settings -> do
    nidefawl.qubes.input.Keybinding kb_forward -> do
    nidefawl.qubes.input.Keybinding kb_backward -> if
    nidefawl.qubes.input.Keybinding kb_left -> for
    nidefawl.qubes.input.Keybinding kb_right -> int
    nidefawl.qubes.input.Keybinding kb_sneak -> new
    nidefawl.qubes.input.Keybinding kb_jump -> try
    float strafe -> do
    float forward -> if
    boolean grabbed -> do
    int mX -> do
    int mY -> if
    float jump -> for
    float sneak -> int
    java.util.Map keyToKeyBinding -> do
    java.util.ArrayList keybindings -> do
    99:100:void addKeyBinding(nidefawl.qubes.input.Keybinding) -> do
    102:107:void updateKeybindMap() -> do
    110:110:nidefawl.qubes.input.Keybinding getKeyBinding(int) -> do
    148:148:boolean isKeyDown(int) -> do
    152:161:void setGrabbed(boolean) -> do
    168:349:void initKeybinds() -> if
    353:361:void load() -> for
    363:370:void saveBindings() -> int
    372:372:java.util.Collection getBindings() -> do
nidefawl.qubes.input.InputController$1 -> jIjIiJIjIjJiJiL1:
    43:43:void setDefaults() -> do
    47:50:void save() -> for
    54:63:void load() -> if
nidefawl.qubes.input.InputController$10 -> IjIjL11LjI1L1LjI:
    232:233:void onDown() -> do
nidefawl.qubes.input.InputController$11 -> llJijIJijIllll:
    nidefawl.qubes.Game val$game -> do
    237:238:void onDown() -> do
nidefawl.qubes.input.InputController$12 -> L11LIjllIjIjL1jI:
    nidefawl.qubes.Game val$game -> do
    246:250:void onDown() -> do
nidefawl.qubes.input.InputController$13 -> jIjIllIjJi1L1LIj:
    nidefawl.qubes.Game val$game -> do
    254:261:void onDown() -> do
nidefawl.qubes.input.InputController$14 -> IjlllllljIiJL1L1:
    nidefawl.qubes.Game val$game -> do
    265:266:void onDown() -> do
nidefawl.qubes.input.InputController$15 -> llL11LjIIjIjIjIj:
    270:271:void onDown() -> do
nidefawl.qubes.input.InputController$16 -> IjiJjIiJjIiJJi1L:
    278:282:void onDown() -> do
nidefawl.qubes.input.InputController$17 -> L1jIjIL11L1LiJll:
    286:287:void onDown() -> do
nidefawl.qubes.input.InputController$18 -> JijI1LjIlljIJiIj:
    nidefawl.qubes.Game val$game -> do
    291:292:void onDown() -> do
nidefawl.qubes.input.InputController$19 -> L1jIiJIjjIiJllll:
    296:297:void onDown() -> do
nidefawl.qubes.input.InputController$2 -> jIIjIjllL11LiJiJ:
    nidefawl.qubes.Game val$game -> do
    172:174:void onDown() -> do
nidefawl.qubes.input.InputController$20 -> JiIjiJIjjIIjIj:
    303:305:void onDown() -> do
nidefawl.qubes.input.InputController$21 -> llL1llL1iJ1LllJi:
    310:311:void onDown() -> do
nidefawl.qubes.input.InputController$22 -> L11LL1iJIjJiIj1L:
    nidefawl.qubes.Game val$game -> do
    315:317:void onDown() -> do
nidefawl.qubes.input.InputController$23 -> jI1LIj1LL11LiJjI:
    323:324:void onDown() -> do
nidefawl.qubes.input.InputController$24 -> IjjIJiiJL1iJllJi:
    330:333:void onDown() -> do
nidefawl.qubes.input.InputController$25 -> jIjIIjL1JiJiJiIj:
    337:338:void onDown() -> do
nidefawl.qubes.input.InputController$26 -> jIjI1LL1iJIjL11L:
    nidefawl.qubes.Game val$game -> do
    342:347:void onDown() -> do
nidefawl.qubes.input.InputController$3 -> L1jIjIiJJiJi:
    nidefawl.qubes.Game val$game -> do
    186:194:void onDown() -> do
nidefawl.qubes.input.InputController$4 -> IjIjJiJiIjjIlljI:
    nidefawl.qubes.Game val$game -> do
    198:199:void onDown() -> do
nidefawl.qubes.input.InputController$5 -> jIiJL1jIJiiJiJL1:
    nidefawl.qubes.Game val$game -> do
    203:204:void onDown() -> do
nidefawl.qubes.input.InputController$6 -> L1L1L11LjIJi1L:
    nidefawl.qubes.Game val$game -> do
    208:213:void onDown() -> do
nidefawl.qubes.input.InputController$7 -> jIJiiJ1LjIiJ1LL1:
    nidefawl.qubes.Game val$game -> do
    217:218:void onDown() -> do
nidefawl.qubes.input.InputController$8 -> L1L1jIIj1LjIll:
    222:223:void onDown() -> do
nidefawl.qubes.input.InputController$9 -> IjL1IjiJ1LllL1ll:
    228:228:void onDown() -> do
nidefawl.qubes.input.Keybinding -> lljIL1llIjL1JiIj:
    boolean enabled -> do
    int key -> do
    boolean isPressed -> if
    java.lang.String name -> do
    boolean hasCallback -> for
    boolean staticBinding -> int
    90:90:void onDown() -> do
    97:103:void update(int) -> do
nidefawl.qubes.input.Keyboard -> IjjIL11LllL1jI1L:
    java.util.HashMap keyNames -> do
    139:139:boolean isKeyDown(int) -> do
    143:143:boolean getState(int) -> if
    147:148:java.lang.String getKeyName(int) -> do
nidefawl.qubes.input.Selection -> JiL11LJi1LL1JijI:
    nidefawl.qubes.gl.TesselatorState highlightSelection -> do
    nidefawl.qubes.gl.TesselatorState fullBlock -> if
    nidefawl.qubes.gl.TesselatorState customBB -> for
    nidefawl.qubes.vec.AABBFloat lastCustomBB -> if
    boolean quarterMode -> do
    boolean mouseDown -> if
    boolean mouseStateChanged -> for
    nidefawl.qubes.gl.TesselatorState renderBB -> int
    nidefawl.qubes.util.RayTrace rayTrace -> do
    nidefawl.qubes.vec.BlockPos[] pos -> do
    boolean updateBB -> int
    nidefawl.qubes.vec.BlockPos mouseOver -> do
    nidefawl.qubes.vec.AABBFloat selBB -> do
    30:30:nidefawl.qubes.input.GameMode getMode() -> do
    63:63:boolean hasSelection() -> do
    122:250:void renderBlockOver(nidefawl.qubes.gl.TesselatorState,nidefawl.qubes.vec.AABBFloat) -> do
    409:416:void set(int,nidefawl.qubes.vec.BlockPos) -> do
    419:457:void clicked(int,boolean) -> do
    464:464:nidefawl.qubes.vec.BlockPos getMin() -> do
    468:468:nidefawl.qubes.vec.BlockPos getMax() -> if
    472:474:int getNumBlocks() -> do
    480:525:void onRelease() -> do
    528:534:void reset() -> if
    539:542:nidefawl.qubes.util.RayTrace$RayTraceIntersection getHit() -> do
nidefawl.qubes.inventory.BaseInventory -> llL1jI1LL1Jillll:
    int inventorySize -> do
    nidefawl.qubes.item.BaseStack[] stacks -> do
    byte[] flagged -> do
    boolean needSorting -> do
    java.util.HashMap amounts -> do
    89:103:void _set(java.util.Collection,boolean) -> do
    123:138:java.util.HashMap getSortedStacks() -> do
nidefawl.qubes.inventory.PlayerInventory -> ll1LjIiJiJJijIL1:
    nidefawl.qubes.item.BaseStack carried -> do
nidefawl.qubes.inventory.PlayerInventoryCrafting -> Ij1LjIiJjIlliJ1L:
nidefawl.qubes.inventory.slots.Slot -> iJ1LIjIjL11LIjL1:
    int idx -> do
    float x -> do
    float y -> if
    float w -> for
    nidefawl.qubes.inventory.slots.Slots slots -> do
    nidefawl.qubes.item.BaseStack getItem() -> do
    30:30:boolean isAt(double,double) -> do
    nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    boolean canTake() -> do
    boolean canPut$4b9f9631() -> if
nidefawl.qubes.inventory.slots.SlotInventory -> L1L1JijIjIjIjIJi:
    nidefawl.qubes.inventory.BaseInventory inv -> do
    24:24:nidefawl.qubes.item.BaseStack getItem() -> do
    56:59:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    64:64:boolean canTake() -> do
    69:69:boolean canPut$4b9f9631() -> if
nidefawl.qubes.inventory.slots.SlotPreview -> jIllllL1jI1LjIjI:
    nidefawl.qubes.item.BaseStack stack -> do
    16:16:nidefawl.qubes.item.BaseStack getItem() -> do
    41:41:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    46:46:boolean canTake() -> do
    51:51:boolean canPut$4b9f9631() -> if
nidefawl.qubes.inventory.slots.SlotStack -> JilljIIjiJL11L1L:
    int slot -> do
    nidefawl.qubes.item.BaseStack stack -> do
    23:25:void read(java.io.DataInput) -> do
    28:30:void write(java.io.DataOutput) -> do
nidefawl.qubes.inventory.slots.SlotStock -> IjlliJjIJiL11LjI:
    nidefawl.qubes.item.BaseStack stack -> if
    nidefawl.qubes.inventory.PlayerInventory inv -> do
    nidefawl.qubes.item.BaseStack stackReq -> do
    23:23:nidefawl.qubes.item.BaseStack getItem() -> do
    48:48:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    53:53:boolean canTake() -> do
    58:58:boolean canPut$4b9f9631() -> if
    62:68:void update() -> do
nidefawl.qubes.inventory.slots.Slots -> iJiJIjiJIjjIJijI:
    java.util.List slots -> do
    int id -> do
    21:22:void addSlot(nidefawl.qubes.inventory.slots.Slot) -> do
    30:35:nidefawl.qubes.inventory.slots.Slot getSlotAt(double,double) -> do
    42:42:java.util.List getSlots() -> do
    nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
    54:54:nidefawl.qubes.inventory.slots.Slot getSlot(int) -> do
    58:58:boolean canModify() -> do
nidefawl.qubes.inventory.slots.SlotsCrafting -> iJIjIjJiiJL1jIll:
    boolean locked -> do
    38:38:boolean canModify() -> do
nidefawl.qubes.inventory.slots.SlotsInventory -> JiIjjIjIJiL1Ijll:
    28:28:boolean canModify() -> do
nidefawl.qubes.inventory.slots.SlotsInventoryBase -> Ij1LiJIjiJL1iJJi:
    nidefawl.qubes.inventory.BaseInventory baseInv -> do
    nidefawl.qubes.inventory.PlayerInventory playerInv -> do
    18:32:nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
    39:39:nidefawl.qubes.inventory.BaseInventory getInv() -> do
nidefawl.qubes.item.BaseStack -> iJjIJi1LJiJiiJll:
    int id -> do
    int data -> if
    int size -> for
    nidefawl.qubes.item.ItemStack tmpStackItem -> do
    nidefawl.qubes.item.BlockStack tmpStackBlock -> do
    boolean isItem() -> do
    23:23:boolean isBlock() -> if
    nidefawl.qubes.item.BaseStack copy() -> do
    nidefawl.qubes.item.Item getItem() -> do
    nidefawl.qubes.block.Block getBlock() -> do
    int getTypeHash() -> do
    69:77:nidefawl.qubes.item.BaseStack getTemp(java.lang.Object) -> do
nidefawl.qubes.item.BlockStack -> L1llJi1LiJlliJjI:
    nidefawl.qubes.item.StackData stackdata -> do
    99:102:nidefawl.qubes.item.BlockStack copy() -> do
    105:105:nidefawl.qubes.block.Block getBlock() -> do
    109:118:void read(java.io.DataInput) -> do
    121:130:void write(java.io.DataOutput) -> do
    147:147:boolean isItem() -> do
    151:151:nidefawl.qubes.item.Item getItem() -> do
    156:156:java.lang.String toString() -> toString
    162:162:int getTypeHash() -> do
    21:21:nidefawl.qubes.item.BaseStack copy() -> do
nidefawl.qubes.item.IDMappingItems -> L1L1jIjIjIL1IjJi:
    boolean CHANGED -> do
    boolean LOADED -> if
    int HIGHEST_ITEM_ID -> do
    com.google.common.collect.ImmutableBiMap map -> do
    java.lang.Object sync -> do
    30:65:void load() -> do
    67:108:void save() -> if
    110:139:int get(java.lang.String) -> do
nidefawl.qubes.item.Item -> llll1LJiL11LJiiJ:
    nidefawl.qubes.item.Item[] registereditems -> if
    short[] registereditemIds -> do
    nidefawl.qubes.item.Item[] item -> do
    nidefawl.qubes.item.Item pickaxe -> do
    nidefawl.qubes.item.Item axe -> if
    nidefawl.qubes.item.ItemGroupLog log -> do
    nidefawl.qubes.item.ItemGroupPlank plank -> do
    int id -> do
    java.lang.String name -> do
    java.lang.String[] textures -> do
    nidefawl.qubes.models.ItemModel itemModel -> do
    84:84:java.lang.String[] getTextures() -> do
    88:92:nidefawl.qubes.item.Item setTextures(java.lang.String[]) -> do
    108:130:void preInit() -> do
    133:133:void postInit() -> if
    145:145:nidefawl.qubes.item.Item get(int) -> do
nidefawl.qubes.item.ItemGroup -> L1iJL1IjjIllL1Ij:
    int NEXT_GROUP_ID -> do
    java.util.List items -> do
    19:21:void addItem(nidefawl.qubes.item.Item) -> do
    29:29:nidefawl.qubes.item.Item getItem(int) -> do
nidefawl.qubes.item.ItemGroupLog -> IjJiJiIjIjL1jIIj:
nidefawl.qubes.item.ItemGroupPlank -> JiJijI1LL1jIIj1L:
nidefawl.qubes.item.ItemGroupStones -> L1Ji1Lllll1LL1iJ:
    java.util.List names -> if
nidefawl.qubes.item.ItemLog -> L1IjjIIjL1JijIjI:
nidefawl.qubes.item.ItemRenderer -> IjJiIjiJIjllJijI:
    nidefawl.qubes.font.FontRenderer font -> do
    37:59:void drawItem(nidefawl.qubes.item.BaseStack,float,float,float,float) -> do
    69:79:void drawItemOverlay(nidefawl.qubes.item.BaseStack,float,float,float,float) -> if
nidefawl.qubes.item.ItemStack -> lliJIjll1LIjJiJi:
    40:43:void read(java.io.DataInput) -> do
    47:50:void write(java.io.DataOutput) -> do
    54:54:boolean isItem() -> do
    68:68:nidefawl.qubes.item.Item getItem() -> do
    73:77:nidefawl.qubes.item.BaseStack copy() -> do
    105:105:nidefawl.qubes.block.Block getBlock() -> do
    109:109:java.lang.String toString() -> toString
    114:114:int getTypeHash() -> do
nidefawl.qubes.item.ItemStone -> iJllL1IjIjllllll:
nidefawl.qubes.item.StackData -> L1L1jIjIllL1Ijll:
    nidefawl.qubes.chunk.blockdata.BlockData data -> do
    35:48:void read(java.io.DataInput) -> do
    52:63:void write(java.io.DataOutput) -> do
nidefawl.qubes.lighting.DynamicLight -> JiiJjIlliJL1Ij1L:
    nidefawl.qubes.vec.Vector3f pos -> do
    nidefawl.qubes.vec.Vector3f lastPos -> if
    nidefawl.qubes.vec.Vector3f mot -> for
    nidefawl.qubes.vec.Vector3f lastMot -> int
    nidefawl.qubes.vec.Vector3f renderPos -> new
    nidefawl.qubes.vec.Vector3f color -> try
    float intensity -> do
    float quadratic -> if
    float radius -> for
    int ticks -> do
nidefawl.qubes.logging.IErrorHandler -> llL1JijIJiL1iJjI:
    void setException(nidefawl.qubes.util.GameError) -> do
nidefawl.qubes.logging.LogBufferStream -> lljIIjjIL1iJjIL1:
    java.io.ByteArrayOutputStream baos -> do
    17:21:void write(byte[],int,int) -> write
    25:26:void write(byte[]) -> write
    30:36:void flush() -> flush
    40:46:void close() -> close
    50:52:void write(int) -> write
    56:60:java.lang.String getLogString() -> do
nidefawl.qubes.meshing.BlockFace -> jIJiIj1L1LiJllll:
    nidefawl.qubes.meshing.BlockSurface bs -> do
    float[] v0 -> do
    float[] v1 -> if
    float[] v2 -> for
    float[] v3 -> int
    int[] du -> do
    int[] dv -> if
    byte[] normal -> do
    int faceDir -> do
    int[] pos -> for
    int[][] faceVDirections -> do
    int[][] faceVDirectionsNeg -> if
    27:30:int encNormal(int,int,int) -> do
    34:41:int encNegNormal(int,int,int) -> if
    241:247:int drawBasic(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> do
    259:275:int drawShadowTextured(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> if
    279:351:int draw(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> for
    355:390:void setUV(nidefawl.qubes.meshing.BlockFaceVert,int) -> do
nidefawl.qubes.meshing.BlockFaceAttr -> iJjIjI1LL1iJIjJi:
    java.lang.String[] attributes -> do
    nidefawl.qubes.meshing.BlockFaceVert v0 -> do
    nidefawl.qubes.meshing.BlockFaceVert v1 -> if
    nidefawl.qubes.meshing.BlockFaceVert v2 -> for
    nidefawl.qubes.meshing.BlockFaceVert v3 -> int
    nidefawl.qubes.meshing.BlockFaceVert[] v -> do
    boolean useGlobalRenderOffset -> do
    int tex -> do
    float xOff -> do
    float yOff -> if
    float zOff -> for
    int aoMask -> if
    int lightMaskSky -> try
    int lightMaskBlock -> byte
    int type -> for
    boolean reverse -> if
    int faceDir -> int
    int normalMap -> new
    int roughness -> case
    66:73:void setOffset(float,float,float) -> do
    76:83:void setNormal(int,int,int) -> do
    86:88:void setLight(int,int) -> do
    93:130:void rotateUV(int) -> do
    133:147:void putSingleVert(int,nidefawl.qubes.gl.VertexBuffer) -> do
    204:231:void put(nidefawl.qubes.gl.VertexBuffer) -> do
    234:251:void putBasic(nidefawl.qubes.gl.VertexBuffer) -> if
    255:274:void putShadowTextured(nidefawl.qubes.gl.VertexBuffer) -> for
    280:281:void setRoughness(float) -> do
    284:288:void setType(int) -> if
    290:293:void setPass(int) -> for
    324:339:void calcNormal(nidefawl.qubes.vec.Vector3f) -> do
    376:379:int packNormal(nidefawl.qubes.vec.Vector3f) -> do
    388:405:void maskLight(int,int,int,int,int) -> do
    408:408:int maskAO(int,int,int,int) -> do
    413:417:int mix_light(int,int,int,int) -> if
nidefawl.qubes.meshing.BlockFaceVert -> IjllIjllllIjIjIj:
    int rgba -> do
    float u -> do
    float v -> if
    float x -> for
    float y -> int
    float z -> new
    int normal -> if
    int direction -> for
    int pass -> int
    29:31:void setColorRGBA(int,float) -> do
    34:35:void setColorRGB(int) -> do
    38:40:void setUV(float,float) -> do
    43:46:void setPos(float,float,float) -> do
    52:56:void setDirection(int,int,boolean) -> do
    63:75:void setNormal(float,float,float) -> if
nidefawl.qubes.meshing.BlockRenderer -> iJjIJiL1iJllIjIj:
    int[][] offsets -> do
    nidefawl.qubes.meshing.BlockSurface bs -> do
    nidefawl.qubes.vec.AABBFloat bb -> do
    int shadowDrawMode -> do
    nidefawl.qubes.world.IBlockWorld w -> do
    nidefawl.qubes.meshing.BlockFaceAttr attr -> do
    nidefawl.qubes.gl.VertexBuffer[] vbuffer -> do
    boolean[] wallDir -> do
    boolean[] fenceDir -> if
    int[] paneDir -> do
    int[] quarters -> if
    int[] quarters2 -> for
    nidefawl.qubes.vec.AABBFloat[] boxes -> do
    nidefawl.qubes.meshing.BlockSurface[] qSurfacesS -> do
    nidefawl.qubes.meshing.BlockSurface[] qSurfaces -> if
    nidefawl.qubes.vec.Vector3f plantNormal -> do
    81:82:void setDefaultBounds() -> do
    89:91:void preRender$3640125f(nidefawl.qubes.world.World,nidefawl.qubes.meshing.BlockFaceAttr) -> do
    98:100:void setBuffers(nidefawl.qubes.gl.VertexBuffer[],int) -> do
    108:179:int render(int,int,int) -> do
    213:339:int renderPane(nidefawl.qubes.block.Block,int,int,int,int) -> do
    343:455:int renderTorch(nidefawl.qubes.block.Block,int,int,int) -> do
    462:538:int renderWall(nidefawl.qubes.block.Block,int,int,int,int) -> if
    552:606:int renderFence(nidefawl.qubes.block.Block,int,int,int,int) -> for
    618:680:int renderVines(nidefawl.qubes.block.Block,int,int,int,int) -> int
    729:740:void renderYPos$13f338df(float,float,float) -> do
    744:753:void renderYNeg$13f338df(float,float,float) -> if
    756:777:int renderFace(nidefawl.qubes.block.Block,int,float,float,float,int) -> do
    787:795:void putSingleVert(nidefawl.qubes.block.Block,int,int) -> do
    798:802:void incVertCount(nidefawl.qubes.block.Block,int,int) -> if
    805:809:void putTriIndex(nidefawl.qubes.block.Block,int,int[]) -> do
    811:819:void putBuffer(nidefawl.qubes.block.Block,int) -> do
    822:904:int renderSlicedFaces(nidefawl.qubes.block.BlockSliced,int,int,int) -> do
    908:949:int renderPlantFlat(nidefawl.qubes.block.Block,int,int,int,int) -> new
    953:957:int renderBlock(nidefawl.qubes.block.Block,int,int,int,int,int) -> do
    960:1037:int renderBlockModel(nidefawl.qubes.block.Block,int,int,int,int,int) -> if
    1059:1070:void flipFace() -> if
    1074:1098:void setFaceColorTexture(nidefawl.qubes.block.Block,int,int,int,int,nidefawl.qubes.meshing.BlockSurface,int,int) -> do
    1100:1102:void setFaceColor(nidefawl.qubes.block.Block,int,int,int,int,nidefawl.qubes.meshing.BlockSurface,int) -> do
    1111:1115:void setBlockBounds(nidefawl.qubes.block.Block,int,int,int) -> do
    1129:1158:nidefawl.qubes.meshing.BlockSurface getSingleBlockSurface(nidefawl.qubes.block.Block,int,int,int,int,int,boolean,nidefawl.qubes.meshing.BlockSurface,int) -> do
    1175:1394:int renderPlant(nidefawl.qubes.block.Block,int,int,int,int) -> try
nidefawl.qubes.meshing.BlockSurface -> Ji1LllIjjIiJjI:
    boolean transparent -> do
    int type -> do
    int face -> if
    int axis -> for
    int x -> int
    int y -> new
    int z -> try
    int pass -> byte
    boolean extraFace -> if
    boolean resolved -> for
    boolean calcLight -> int
    int maskedLightSky -> case
    int maskedLightBlock -> char
    int maskedAO -> else
    boolean isAirAbove -> new
    int texture -> goto
    boolean renderTypeTransition -> try
    int faceColor -> long
    31:31:int maskAO(int,int,int,int) -> do
    35:39:int mix_light(int,int,int,int) -> if
    42:61:void maskLight(int,int,int,int,nidefawl.qubes.block.Block) -> do
    87:108:void calcAO(nidefawl.qubes.world.IBlockWorld) -> do
    111:118:int vertexAO(boolean,boolean,boolean) -> do
    130:137:boolean isOccludingAt(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    458:489:boolean mergeWith(nidefawl.qubes.meshing.ChunkRenderCache,nidefawl.qubes.meshing.BlockSurface) -> do
    493:517:void resolve(nidefawl.qubes.meshing.ChunkRenderCache) -> do
    520:537:void reset() -> do
    539:558:nidefawl.qubes.meshing.BlockSurface copy() -> do
nidefawl.qubes.meshing.BlockSurfaceAir -> llL1iJiJlljIL1:
    11:11:nidefawl.qubes.meshing.BlockSurface copy() -> do
nidefawl.qubes.meshing.BlockSurfaceHidden -> L1JiJi1LIjllL1Ji:
    17:17:nidefawl.qubes.meshing.BlockSurface copy() -> do
nidefawl.qubes.meshing.ChunkRenderCache -> llIjllIj1LiJiJll:
    nidefawl.qubes.chunk.Chunk[] chunks -> do
    nidefawl.qubes.world.WorldClient world -> do
    int baseX -> do
    int baseZ -> if
    36:36:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    40:41:void flush() -> do
    44:48:int getData(int,int,int) -> do
    53:57:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    63:67:int getType(int,int,int) -> if
    72:76:int getWater(int,int,int) -> for
    81:85:int getLight(int,int,int) -> int
    166:169:boolean isNormalBlock(int,int,int,int) -> do
    183:183:int getBiomeFaceColor$e764ff2(int,int,int,int,int,int) -> do
nidefawl.qubes.meshing.MeshThread -> L1jIllJiiJiJllll:
    java.util.concurrent.LinkedBlockingQueue queue -> do
    java.util.LinkedList results -> do
    java.util.LinkedList finish -> if
    boolean hasResults -> do
    boolean isRunning -> if
    boolean finished -> for
    nidefawl.qubes.meshing.MeshUpdateTask[] tasks -> do
    java.lang.Thread[] threads -> do
    int tasksRunning -> do
    int id -> if
    38:49:void init() -> do
    54:85:void run() -> run
    92:109:nidefawl.qubes.render.region.MeshedRegion finishTask() -> do
    127:127:boolean busy() -> do
nidefawl.qubes.meshing.MeshUpdateTask -> iJllL1JiiJIjJill:
    nidefawl.qubes.meshing.Mesher mesher -> do
    nidefawl.qubes.meshing.BlockRenderer blockRenderer -> do
    nidefawl.qubes.meshing.ChunkRenderCache ccache -> do
    nidefawl.qubes.meshing.BlockFaceAttr attr -> do
    int worldInstance -> do
    boolean meshed -> do
    nidefawl.qubes.render.region.MeshedRegion mr -> do
    nidefawl.qubes.gl.VertexBuffer[] vbuffer -> do
    int shadowDrawMode -> if
    104:104:boolean isValid(int) -> do
    108:171:boolean updateFromThread() -> do
nidefawl.qubes.meshing.Mesher -> llIjL1iJjIjIJill:
    int[] dims -> do
    nidefawl.qubes.meshing.BlockSurface[] mask2 -> do
    nidefawl.qubes.meshing.BlockSurfaceAir air -> do
    nidefawl.qubes.meshing.BlockSurfaceHidden hidden -> do
    short[] renderTypeBlocks -> do
    int nextBlockIDX -> do
    nidefawl.qubes.meshing.BlockSurface[] scratchPad -> if
    int scratchpadidx -> if
    java.util.List[] meshes -> do
    nidefawl.qubes.meshing.BlockSurface bs1 -> do
    nidefawl.qubes.meshing.BlockSurface bs2 -> if
    nidefawl.qubes.vec.AABBFloat fullBB -> do
    nidefawl.qubes.meshing.BlockSurface[] extraWaterFaces -> for
    int extraIdx -> for
    nidefawl.qubes.meshing.ChunkRenderCache cache -> do
    int strategy -> int
    int yPos -> new
    int ySlice -> try
    int avgUsage -> byte
    45:55:int computeHeight$51b3c4e1(int,int,int,int,int,nidefawl.qubes.meshing.BlockSurface) -> do
    205:309:void meshRound(nidefawl.qubes.meshing.ChunkRenderCache) -> do
    314:386:nidefawl.qubes.meshing.BlockSurface getBlockSurface(int,int,int,int,int) -> do
nidefawl.qubes.models.BlockModelManager -> JiL1L11LL11LIj1L:
    nidefawl.qubes.models.BlockModelManager instance -> do
    java.util.HashMap models -> do
    java.util.HashMap textures -> if
    20:20:nidefawl.qubes.models.BlockModelManager getInstance() -> do
    28:28:void init() -> do
    33:87:void reload() -> if
nidefawl.qubes.models.EntityModel -> JiIjjI1LJijIjIjI:
    int HIGHEST_MODEL_ID -> do
    nidefawl.qubes.models.EntityModel[] registeredmodels -> if
    short[] registeredmodelIds -> do
    nidefawl.qubes.models.EntityModel[] models -> do
    nidefawl.qubes.models.EntityModel modelCat -> do
    nidefawl.qubes.models.EntityModel modelChicken -> if
    nidefawl.qubes.models.EntityModel modelDog -> for
    nidefawl.qubes.models.EntityModel modelDuck -> int
    nidefawl.qubes.models.EntityModel modelGoat -> new
    nidefawl.qubes.models.EntityModel modelPig -> try
    nidefawl.qubes.models.EntityModel modelPony -> byte
    nidefawl.qubes.models.EntityModel modelPuppy -> case
    nidefawl.qubes.models.EntityModel modelSheep -> char
    int id -> if
    java.lang.String modelPath -> if
    java.lang.String name -> do
    nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel loader -> do
    nidefawl.qubes.models.qmodel.ModelQModel model -> do
    java.util.List modelOptions -> do
    java.util.ArrayList actions -> do
    56:69:void preInit() -> do
    72:72:void postInit() -> if
    102:102:java.lang.String getModelFile() -> do
    void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    124:124:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    132:137:nidefawl.qubes.models.qmodel.QModelObject getObject(java.util.List,java.lang.String) -> do
nidefawl.qubes.models.EntityModelAnimal -> IjllJiL1JijI1LL1:
    nidefawl.qubes.models.qmodel.QModelObject main -> do
    nidefawl.qubes.models.ModelOption texSkin -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> do
    nidefawl.qubes.vec.Matrix4f rotation -> if
    30:73:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    76:111:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
nidefawl.qubes.models.EntityModelArcher -> jIL1Ijll1LiJJiIj:
    nidefawl.qubes.models.ModelOption texSkin -> do
    nidefawl.qubes.models.ModelOption modelHelmet -> if
    nidefawl.qubes.models.ModelOption texHelmet -> for
    nidefawl.qubes.models.ModelOption modelShoulders -> int
    nidefawl.qubes.models.ModelOption texShoulders -> new
    nidefawl.qubes.models.ModelOption modelBracers -> try
    nidefawl.qubes.models.ModelOption texBracers -> byte
    nidefawl.qubes.models.ModelOption modelShield -> case
    nidefawl.qubes.models.ModelOption texShield -> char
    nidefawl.qubes.models.ModelOption modelWeapon -> else
    java.util.List listBracers -> if
    java.util.List listShoulders -> for
    java.util.List listShields -> int
    java.util.List listHelmets -> new
    java.util.List listWeapon -> try
    nidefawl.qubes.models.qmodel.QModelObject main_0 -> do
    54:107:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    110:140:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    142:149:void attach(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,java.util.List,nidefawl.qubes.models.ModelOption,nidefawl.qubes.models.ModelOption) -> do
    151:160:void attach2(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,java.util.List,nidefawl.qubes.models.ModelOption,nidefawl.qubes.models.ModelOption) -> if
nidefawl.qubes.models.EntityModelDemon -> iJIjjIjI1LL1IjL1:
    nidefawl.qubes.models.ModelOption modelArmor -> do
    nidefawl.qubes.models.ModelOption texSkin -> if
    java.util.ArrayList armors -> if
    nidefawl.qubes.models.qmodel.QModelObject main -> do
    29:73:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    76:100:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
nidefawl.qubes.models.EntityModelManager -> llJiiJiJ1LllJi1L:
    nidefawl.qubes.models.EntityModelManager instance -> do
    java.util.HashMap models -> do
    19:19:nidefawl.qubes.models.EntityModelManager getInstance() -> do
    29:69:void reload() -> do
nidefawl.qubes.models.EntityModelPlayer -> jIllL1llIjJiiJL1:
    boolean isMale -> do
    java.util.ArrayList hats -> if
    java.util.ArrayList beards -> for
    java.util.ArrayList hairs -> int
    java.util.ArrayList tools -> new
    java.util.ArrayList bags -> try
    nidefawl.qubes.models.ModelOption modelSize -> do
    nidefawl.qubes.models.ModelOption texSkin -> if
    nidefawl.qubes.models.ModelOption texFace -> for
    nidefawl.qubes.models.ModelOption modelHair -> int
    nidefawl.qubes.models.ModelOption texHair -> new
    nidefawl.qubes.models.ModelOption modelBeard -> try
    nidefawl.qubes.models.ModelOption texBeard -> byte
    nidefawl.qubes.models.ModelOption modelHat -> case
    nidefawl.qubes.models.ModelOption texHat -> char
    nidefawl.qubes.models.ModelOption modelTools -> else
    nidefawl.qubes.models.ModelOption texTools -> goto
    nidefawl.qubes.models.ModelOption modelBag -> long
    nidefawl.qubes.models.ModelOption texBag -> this
    nidefawl.qubes.models.qmodel.QModelObject main_0 -> do
    nidefawl.qubes.models.qmodel.QModelObject main_1 -> if
    nidefawl.qubes.models.qmodel.QModelObject main_2 -> for
    nidefawl.qubes.models.qmodel.QModelObject[] body -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction run -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction jump -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction hit1 -> for
    nidefawl.qubes.models.qmodel.animation.QModelAction idle -> int
    70:75:nidefawl.qubes.models.qmodel.QModelObject getObject(java.util.List,java.lang.String) -> do
    79:184:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    189:259:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    262:269:void attach(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,java.util.ArrayList,nidefawl.qubes.models.ModelOption,nidefawl.qubes.models.ModelOption) -> do
nidefawl.qubes.models.EntityModelSkeleton -> llIjL11LiJIj1LjI:
    nidefawl.qubes.models.ModelOption modelSel -> do
    java.util.List modelList -> if
    25:68:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    71:90:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
nidefawl.qubes.models.EntityModelTest -> IjJiJijIL1IjiJL1:
    java.util.ArrayList headThings -> if
    nidefawl.qubes.models.ModelOption modelHeadThing -> do
    nidefawl.qubes.models.qmodel.QModelObject main_0 -> do
    nidefawl.qubes.models.qmodel.QModelObject test1 -> if
    34:39:nidefawl.qubes.models.qmodel.QModelObject getObject(java.util.List,java.lang.String) -> do
    43:59:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    63:86:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
nidefawl.qubes.models.EntityModelZombie -> iJjI1LjIL11LjIIj:
    nidefawl.qubes.models.ModelOption modelSel -> do
    java.util.List modelList -> if
    29:61:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    65:83:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
nidefawl.qubes.models.ItemModel -> IjIjllll1LL11L1L:
    int HIGHEST_MODEL_ID -> do
    nidefawl.qubes.models.ItemModel[] registeredmodels -> if
    short[] registeredmodelIds -> do
    nidefawl.qubes.models.ItemModel[] model -> do
    nidefawl.qubes.models.ItemModel modelPickaxe -> do
    nidefawl.qubes.models.ItemModel modelAxe -> if
    int id -> if
    java.lang.String[] models -> do
    nidefawl.qubes.models.qmodel.ModelQModel[] loadedModels -> do
    java.lang.String name -> do
    33:54:void preInit() -> do
    57:57:void postInit() -> if
    80:80:java.lang.String[] getModels() -> do
nidefawl.qubes.models.ItemModelManager -> Ji1L1LJi1LL1Jill:
    nidefawl.qubes.models.ItemModelManager instance -> do
    java.util.HashMap models -> do
    22:22:nidefawl.qubes.models.ItemModelManager getInstance() -> do
    29:29:void init() -> do
    34:75:void reload() -> if
nidefawl.qubes.models.ModelOption -> IjllJilliJL1jIIj:
    nidefawl.qubes.models.EntityModel eModel -> do
    int id -> do
    22:34:nidefawl.qubes.models.ModelOption setOptionCount(java.lang.String,int) -> do
nidefawl.qubes.models.qmodel.ModelBlock -> llL1iJL1L11LL1Ji:
    nidefawl.qubes.models.qmodel.QModelGroup[] faceGroups -> do
    nidefawl.qubes.gl.VertexBuffer vBuf -> do
    boolean needsDraw -> do
    long reRender -> do
    64:64:int getType$65456864() -> do
    70:121:void render$4868c7cb(int,int) -> do
nidefawl.qubes.models.qmodel.ModelQModel -> iJ1LllL1L1lljIL1:
    nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel loader -> do
    nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderObject[] objects -> do
    64:74:void release() -> do
    int getType$65456864() -> do
    85:85:void animate$2b524977(nidefawl.qubes.models.qmodel.QModelProperties,float) -> do
    91:91:void animateNodes$2b524977(nidefawl.qubes.models.qmodel.QModelProperties,float) -> if
    99:99:void setHeadOrientation(float,float) -> do
    void render$4868c7cb(int,int) -> do
    128:132:nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderObject getGroup(int) -> do
nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderGroup -> JiL1L1JiiJjIIj:
    nidefawl.qubes.gl.GLTriBuffer gpuBufRest -> do
    nidefawl.qubes.gl.GLTriBuffer gpuBuf -> if
    long reRender -> do
nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderObject -> L1IjiJIjJiJill1L:
    java.util.List list -> do
    49:52:nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderGroup getGroup(int) -> do
nidefawl.qubes.models.qmodel.ModelRigged -> llllJiJiL1iJllL1:
    java.util.ArrayList poseBones -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone head -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone neck -> if
    boolean needsDraw -> do
    nidefawl.qubes.vec.Matrix4f tmpMat1 -> do
    nidefawl.qubes.vec.Matrix4f tmpMat2 -> if
    nidefawl.qubes.vec.Vector3f tmpVec -> do
    nidefawl.qubes.vec.Vector3f tmpVec2 -> if
    nidefawl.qubes.gl.VertexBuffer vbuf -> do
    83:94:void animate$2b524977(nidefawl.qubes.models.qmodel.QModelProperties,float) -> do
    100:117:void animateNodes$2b524977(nidefawl.qubes.models.qmodel.QModelProperties,float) -> if
    178:245:void renderRestModel(nidefawl.qubes.models.qmodel.QModelObject,nidefawl.qubes.models.qmodel.QModelGroup,int) -> do
    248:340:void render$4868c7cb(int,int) -> do
    346:450:void setHeadOrientation(float,float) -> do
    455:455:int getType$65456864() -> do
nidefawl.qubes.models.qmodel.ModelStatic -> iJiJIjL1llllIjll:
    boolean needsDraw -> do
    nidefawl.qubes.gl.VertexBuffer vBuf -> do
    34:84:void render$4868c7cb(int,int) -> do
    88:88:int getType$65456864() -> do
nidefawl.qubes.models.qmodel.QModelAbstractNode -> iJiJiJIjIjJiIjll:
    12:20:int readParentType(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    nidefawl.qubes.vec.Matrix4f getMatDeform() -> do
    nidefawl.qubes.vec.Matrix4f getMatDeformNormal() -> if
nidefawl.qubes.models.qmodel.QModelBone -> llllIjllllIjllJi:
    int idx -> if
    int flags -> do
    java.lang.String name -> do
    java.lang.String parentName -> if
    nidefawl.qubes.vec.Matrix4f matRest -> do
    nidefawl.qubes.vec.Matrix4f matRestInv -> if
    java.util.List children -> do
    nidefawl.qubes.vec.Vector3f tailLocal -> do
    nidefawl.qubes.models.qmodel.QModelBone parent -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone posebone -> do
    float boneLength -> do
    79:79:java.lang.String stringInfo() -> do
    83:83:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelGroup -> IjjIL1Ji1LJijI1L:
    int idx -> do
    java.lang.String name -> do
    int[] triIdx -> do
    int materialIdx -> if
    nidefawl.qubes.models.qmodel.QModelMaterial material -> do
    java.util.List listTri -> do
    boolean isSkinned -> do
    46:46:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelMaterial -> jIIjiJjI1LIjIjiJ:
    java.lang.String name -> do
    int[] textureIdxs -> do
    nidefawl.qubes.models.qmodel.QModelTexture[] qTextures -> do
    nidefawl.qubes.models.qmodel.QModelTexture bound -> do
    54:61:void resolveTextures(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    69:75:nidefawl.qubes.models.qmodel.QModelTexture getBoundTexture() -> do
nidefawl.qubes.models.qmodel.QModelNode -> IjllJiL1iJjIJill:
    int idx -> if
    java.lang.String name -> do
    java.lang.String parent_name -> if
    int parent_type -> do
    nidefawl.qubes.models.qmodel.QModelBone attachmentBone -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> do
    nidefawl.qubes.vec.Matrix4f matDeformNormal -> for
    nidefawl.qubes.vec.Matrix4f localMat -> if
    42:42:java.lang.String toString() -> toString
    47:53:void resolveParent(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    58:66:void updateNormalMat() -> do
    83:83:nidefawl.qubes.vec.Matrix4f getMatDeform() -> do
    89:89:nidefawl.qubes.vec.Matrix4f getMatDeformNormal() -> if
nidefawl.qubes.models.qmodel.QModelObject -> L1IjL1jIjIllL1Ij:
    int idx -> do
    int type -> for
    java.lang.String name -> do
    java.lang.String parent_name -> if
    int parent_type -> if
    nidefawl.qubes.models.qmodel.QModelBone attachmentBone -> do
    nidefawl.qubes.models.qmodel.QModelAbstractNode attachmentEmpty -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> do
    nidefawl.qubes.vec.Matrix4f matDeformNormal -> if
    java.util.List listVertex -> do
    java.util.List listTri -> if
    java.util.List listGroups -> for
    boolean isSkinned -> do
    74:74:java.lang.String toString() -> toString
    78:101:void flattenBoneList(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    104:122:void normalizeWeights(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> if
    125:136:int getMinBone(nidefawl.qubes.models.qmodel.QModelTriangle) -> do
    141:152:int getMaxBone(nidefawl.qubes.models.qmodel.QModelTriangle) -> if
    189:195:void resolveParent(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> for
    199:205:void resolveGroupMaterials(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> int
    209:212:void bindTextureIdx(int,int) -> do
    238:238:nidefawl.qubes.vec.Matrix4f getMatDeform() -> do
    244:244:nidefawl.qubes.vec.Matrix4f getMatDeformNormal() -> if
nidefawl.qubes.models.qmodel.QModelObject$1 -> L11LL1IjjIL1jIll:
    nidefawl.qubes.models.qmodel.QModelObject this$0 -> do
    157:157:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.models.qmodel.QModelPoseBone -> IjIjIjjIllL1jIjI:
    java.util.List children -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> do
    nidefawl.qubes.vec.Matrix4f matDeformNormal -> if
    nidefawl.qubes.models.qmodel.QModelBone restbone -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone parent -> do
    35:43:void updateNormalMat() -> do
    89:89:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelProperties -> JilllliJiJJiJiL1:
    java.util.HashMap options -> do
    nidefawl.qubes.vec.Vector3f pos -> do
    nidefawl.qubes.vec.Vector3f rot -> if
    nidefawl.qubes.entity.Entity entity -> do
    java.util.ArrayList actions -> do
    java.util.ArrayList actionOffsets -> if
    23:24:int getOption(int) -> do
    53:54:void setActionOffset(int,float) -> do
    56:62:void setAction(int,nidefawl.qubes.models.qmodel.animation.QModelAction) -> do
    64:77:int getChannelIdx(java.lang.String) -> do
    80:80:nidefawl.qubes.models.qmodel.animation.QAnimationChannel getActionChannel(int,java.lang.String) -> do
    83:83:float getActionOffset(int) -> do
nidefawl.qubes.models.qmodel.QModelTexture -> iJjIL1IjIjJilljI:
    java.lang.String path -> do
    int glid -> do
    27:33:int get() -> do
nidefawl.qubes.models.qmodel.QModelTriangle -> iJL1IjJiJiL1jIJi:
    int idx -> do
    int[] vertIdx -> do
    nidefawl.qubes.vec.Vector3f[] normal -> do
    float[][] texCoord -> do
    54:54:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelType -> jIiJL1JiJijIiJjI:
    int STATIC$66b43883 -> do
    int RIGGED$66b43883 -> if
    int BLOCK$66b43883 -> for
    int[] $VALUES$3a45a982 -> do
    10:10:int[] values$66b0dd43() -> do
    18:26:int get$62e5aaab(int) -> do
nidefawl.qubes.models.qmodel.QModelVertex -> IjIjJiIjL1jIIjL1:
    int[] bones -> do
    float[] weights -> do
    int numBones -> do
nidefawl.qubes.models.qmodel.animation.KeyFrame -> IjL11LL1iJ1LiJll:
    float time -> do
    int idx -> do
    nidefawl.qubes.models.qmodel.animation.KeyFrame next -> do
    35:35:nidefawl.qubes.models.qmodel.animation.KeyFrame copy() -> do
nidefawl.qubes.models.qmodel.animation.QAnimationChannel -> jIjIllllL1IjL1L1:
    nidefawl.qubes.models.qmodel.animation.KeyFrame[] frames -> do
    float animLength -> do
    float frameLength -> if
    float startOffset -> for
    int priority -> do
    74:84:nidefawl.qubes.models.qmodel.animation.QAnimationChannel split(int,int) -> do
    87:118:boolean setDeform(int,float,nidefawl.qubes.vec.Matrix4f) -> do
nidefawl.qubes.models.qmodel.animation.QModelAction -> jIjIllJijIIj1LIj:
    int flags -> do
    float fps -> if
    int startFrame -> if
    int endFrame -> for
    java.util.Map map -> do
    nidefawl.qubes.models.qmodel.animation.QAnimationChannel armatureAnim -> do
    float lenTime -> do
    71:87:nidefawl.qubes.models.qmodel.animation.QModelAction split(java.lang.String,int,int) -> do
nidefawl.qubes.models.qmodel.animation.QModelKeyFrameMatrix -> L1jIlllliJJiJiJi:
    nidefawl.qubes.vec.Matrix4f mat -> do
    32:33:nidefawl.qubes.models.qmodel.animation.KeyFrame copy() -> do
nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel -> iJL1lliJjIllIj1L:
    java.util.List listObjects -> do
    java.util.List listMaterials -> if
    java.util.List listTextures -> for
    java.util.List listBones -> int
    java.util.List listActions -> new
    java.util.List listEmpties -> try
    java.lang.String path -> do
    int modelType$66b43883 -> if
    54:145:void loadModel(nidefawl.qubes.assets.AssetBinary) -> do
    181:187:nidefawl.qubes.models.qmodel.QModelBone findJoint(java.lang.String) -> do
    190:196:nidefawl.qubes.models.qmodel.QModelNode findEmpty(java.lang.String) -> do
    215:220:nidefawl.qubes.models.qmodel.ModelQModel buildModel() -> do
    225:231:java.lang.String getModelName() -> do
nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel$1 -> iJiJIjiJiJll1L1L:
    int[] $SwitchMap$nidefawl$qubes$models$qmodel$QModelType -> do
nidefawl.qubes.models.render.QModelBatchedRender -> iJ1LjIIjjIL1JiiJ:
    nidefawl.qubes.shader.Shader shaderModelBatched -> do
    nidefawl.qubes.shader.Shader shaderModelBatchedSkinned -> if
    nidefawl.qubes.shader.Shader shaderModelBatchedShadow -> for
    nidefawl.qubes.shader.Shader shaderModelBatchedSkinnedShadow -> int
    java.nio.FloatBuffer bufBoneMat -> do
    java.nio.FloatBuffer bufNormalMat -> if
    java.nio.FloatBuffer bufModelMat -> for
    nidefawl.qubes.models.render.QModelBatchedRender$QModelRenderSubList[] tmpLists -> do
    java.util.List subLists -> do
    int nxtIdx -> do
    boolean isModelViewer -> if
    int pass -> if
    int shadowVP -> for
    nidefawl.qubes.vec.Matrix4f tmpMatrix1 -> do
    nidefawl.qubes.vec.Matrix4f tmpMatrix2 -> if
    155:161:void begin() -> do
    164:170:void end() -> if
    316:320:void addObject(nidefawl.qubes.models.qmodel.QModelObject) -> do
nidefawl.qubes.models.render.QModelBatchedRender$1 -> iJ1LJiL1iJjIIj1L:
    boolean val$isModelViewer -> do
    98:100:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.models.render.QModelBatchedRender$2 -> Ij1L1LJijIlljIJi:
    boolean val$isModelViewer -> do
    106:108:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.models.render.QModelBatchedRender$3 -> lllliJJijIllJijI:
    boolean val$isModelViewer -> do
    114:118:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.models.render.QModelBatchedRender$4 -> JiIj1LL1Ij1LJiiJ:
    boolean val$isModelViewer -> do
    124:128:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.models.render.QModelBatchedRender$QModelRenderSubList -> IjL1llL1L1L11Lll:
    boolean isSkinned -> do
    nidefawl.qubes.models.qmodel.ModelQModel model -> do
    nidefawl.qubes.models.qmodel.QModelObject object -> do
    nidefawl.qubes.models.qmodel.QModelGroup group -> do
    nidefawl.qubes.models.qmodel.QModelMaterial material -> do
    nidefawl.qubes.models.qmodel.QModelTexture tex -> do
    nidefawl.qubes.models.render.QModelBatchedRender$ReallocFloatBuf buf1 -> do
    nidefawl.qubes.models.render.QModelBatchedRender$ReallocFloatBuf buf2 -> if
    nidefawl.qubes.models.render.QModelBatchedRender$ReallocFloatBuf buf3 -> for
    int instances -> do
nidefawl.qubes.models.render.QModelBatchedRender$ReallocFloatBuf -> IjiJllL1iJiJiJll:
    int pos -> do
    float[] matBuf -> do
    206:211:void store(nidefawl.qubes.vec.Matrix4f) -> do
nidefawl.qubes.models.render.QModelRender -> JiIjL1llL1jIJiL1:
    nidefawl.qubes.models.qmodel.ModelQModel model -> do
    nidefawl.qubes.gl.BufferedMatrix normalMat -> do
    nidefawl.qubes.gl.BufferedMatrix modelMat -> if
    void addObject(nidefawl.qubes.models.qmodel.QModelObject) -> do
nidefawl.qubes.nbt.Tag -> llll1LjIll1L1LiJ:
    java.lang.String name -> do
    nidefawl.qubes.nbt.Tag$TagType getType() -> do
    void writeData(java.io.DataOutput) -> do
    void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    725:728:void write(nidefawl.qubes.nbt.Tag,java.io.DataOutput) -> do
    731:739:nidefawl.qubes.nbt.Tag read(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    743:773:nidefawl.qubes.nbt.Tag newFromType(nidefawl.qubes.nbt.Tag$TagType) -> do
    778:784:java.lang.String readString(java.io.DataInput) -> do
    788:795:void writeString(java.lang.String,java.io.DataOutput) -> do
nidefawl.qubes.nbt.Tag$1 -> L1jIL1L1jIiJll1L:
    int[] $SwitchMap$nidefawl$qubes$nbt$Tag$TagType -> do
nidefawl.qubes.nbt.Tag$Byte -> JiIj1LjIJiJi:
    byte byteVal -> do
    70:71:void writeData(java.io.DataOutput) -> do
    75:75:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    85:87:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$ByteArray -> llllllL11LL1L1ll:
    byte[] data -> do
    111:113:void writeData(java.io.DataOutput) -> do
    117:117:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    127:135:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Compound -> jIJilliJIjIjiJJi:
    java.util.Map data -> do
    322:322:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    332:341:void writeData(java.io.DataOutput) -> do
    345:364:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Double -> L1lliJL11LJiiJll:
    double doubleVal -> do
    159:160:void writeData(java.io.DataOutput) -> do
    164:164:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    174:176:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$End -> jIjIIj1LiJ1LiJ:
    44:44:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    49:49:void writeData(java.io.DataOutput) -> do
    53:53:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Float -> JiIjIjJi1LiJll1L:
    float floatVal -> do
    487:488:void writeData(java.io.DataOutput) -> do
    492:492:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    502:504:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Int -> IjIjIjiJL1L11L:
    int data -> do
    528:529:void writeData(java.io.DataOutput) -> do
    533:533:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    543:545:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Long -> IjIjL1JiJiL1L1ll:
    long data -> do
    609:610:void writeData(java.io.DataOutput) -> do
    614:614:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    624:626:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Short -> L11LL1L1jIiJJiL1:
    short data -> do
    684:685:void writeData(java.io.DataOutput) -> do
    689:689:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    699:701:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$StringTag -> iJjI1LiJ1LjIL1Ji:
    java.lang.String data -> if
    569:569:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    579:581:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    585:586:void writeData(java.io.DataOutput) -> do
nidefawl.qubes.nbt.Tag$TagList -> jIJill1LiJjIlliJ:
    java.util.List data -> do
    nidefawl.qubes.nbt.Tag$TagType tagType -> do
    244:257:void writeData(java.io.DataOutput) -> do
    261:261:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    274:295:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$TagType -> IjIjJiIjjIL1jIL1:
    nidefawl.qubes.nbt.Tag$TagType END -> do
    nidefawl.qubes.nbt.Tag$TagType BYTE -> if
    nidefawl.qubes.nbt.Tag$TagType SHORT -> for
    nidefawl.qubes.nbt.Tag$TagType INT -> int
    nidefawl.qubes.nbt.Tag$TagType LONG -> new
    nidefawl.qubes.nbt.Tag$TagType FLOAT -> try
    nidefawl.qubes.nbt.Tag$TagType DOUBLE -> byte
    nidefawl.qubes.nbt.Tag$TagType BYTEARRAY -> case
    nidefawl.qubes.nbt.Tag$TagType STRING -> char
    nidefawl.qubes.nbt.Tag$TagType LIST -> else
    nidefawl.qubes.nbt.Tag$TagType COMPOUND -> goto
    nidefawl.qubes.nbt.Tag$TagType VEC3 -> long
    nidefawl.qubes.nbt.Tag$TagType UUID -> this
    nidefawl.qubes.nbt.Tag$TagType[] $VALUES -> do
    17:17:nidefawl.qubes.nbt.Tag$TagType[] values() -> values
    17:17:nidefawl.qubes.nbt.Tag$TagType valueOf(java.lang.String) -> valueOf
    24:24:nidefawl.qubes.nbt.Tag$TagType fromID(int) -> do
nidefawl.qubes.nbt.Tag$UUIDTag -> jIL1IjIjlliJlljI:
    java.util.UUID data -> do
    650:652:void writeData(java.io.DataOutput) -> do
    656:656:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    666:668:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Vec3Tag -> IjIjllL1llL1Ij:
    nidefawl.qubes.vec.Vector3f vec3 -> do
    202:205:void writeData(java.io.DataOutput) -> do
    209:209:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    219:221:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.TagReadLimiter -> Ji1LL1lljIL11LJi:
    nidefawl.qubes.nbt.TagReadLimiter UNLIMITED -> do
    int totalReadBytes -> do
    int limit -> if
    int maxStackDepth -> for
    int stackDepth -> int
    25:29:void add(int) -> do
    31:35:void push() -> do
    37:38:void pop() -> if
nidefawl.qubes.nbt.TagReadLimiter$1 -> JiiJJi1LllJiiJjI:
    7:7:void add(int) -> do
    8:8:void push() -> do
    9:9:void pop() -> if
nidefawl.qubes.network.Connection -> JillllJiJiIj1L:
    java.net.Socket socket -> do
    java.io.DataInputStream inStream -> do
    java.io.DataOutputStream outStream -> do
    nidefawl.qubes.network.ReaderThread readThread -> do
    nidefawl.qubes.network.WriterThread writeThread -> do
    boolean isConnected -> do
    boolean cleanUp -> if
    java.util.concurrent.LinkedBlockingQueue incoming -> do
    java.util.concurrent.LinkedBlockingQueue outgoing -> if
    java.io.InputStream sIn -> do
    java.lang.Throwable readWriteException -> do
    int disconnectFrom -> do
    java.lang.String disconnectReason -> do
    78:81:void onError(java.lang.Exception) -> do
    90:110:void validateConnection() -> do
    113:131:void onDisconnect() -> if
    134:136:void interruptThreads() -> for
    139:162:void disconnect(int,java.lang.String) -> do
    173:173:nidefawl.qubes.network.packet.Packet pollPacket() -> do
nidefawl.qubes.network.Handler -> JiL1IjJiIjL1iJll:
    boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    26:26:void handleHandshake(nidefawl.qubes.network.packet.PacketHandshake) -> do
    29:29:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    33:33:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    36:36:void handleSpawnInWorld(nidefawl.qubes.network.packet.PacketSSpawnInWorld) -> do
    39:39:void handleAuth(nidefawl.qubes.network.packet.PacketAuth) -> do
    46:46:void handleChunkDataMulti(nidefawl.qubes.network.packet.PacketSChunkData,int) -> do
    56:56:void handleBlock(nidefawl.qubes.network.packet.PacketSSetBlock) -> do
    59:59:void handleMultiBlock(nidefawl.qubes.network.packet.PacketSSetBlocks) -> do
    69:69:void handleLightChunk(nidefawl.qubes.network.packet.PacketSLightChunk) -> do
    76:76:void handleTrackChunk(nidefawl.qubes.network.packet.PacketSTrackChunk) -> do
    96:96:void handleChat(nidefawl.qubes.network.packet.PacketChatMessage) -> do
    103:103:void handleChannels(nidefawl.qubes.network.packet.PacketChatChannels) -> do
    110:110:void handleWorldTime(nidefawl.qubes.network.packet.PacketSWorldTime) -> do
    117:117:void handleTeleport(nidefawl.qubes.network.packet.PacketSTeleport) -> do
    123:123:void handleSync$41f19c9b() -> do
    136:136:void handleEntityUntrack(nidefawl.qubes.network.packet.PacketSEntityUnTrack) -> do
    142:142:void handleEntityTrack(nidefawl.qubes.network.packet.PacketSEntityTrack) -> do
    148:148:void handleEntityMove(nidefawl.qubes.network.packet.PacketSEntityMove) -> do
    154:154:void handleWorldBiomes(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    160:160:void handleServerDigState(nidefawl.qubes.network.packet.PacketSDigState) -> do
    163:163:void handleDebugBBs(nidefawl.qubes.network.packet.PacketSDebugBB) -> do
    169:169:void handleInvSync(nidefawl.qubes.network.packet.PacketSInvSync) -> do
    175:175:void handleCraftingProgress(nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
    178:178:void handleInvSyncIncr(nidefawl.qubes.network.packet.PacketSInvSyncIncr) -> do
    181:181:void handleInvCarried(nidefawl.qubes.network.packet.PacketSInvCarried) -> do
    187:187:void handleDebugPath$6ebe27c9() -> if
nidefawl.qubes.network.ReaderThread -> ll1LJi1LJijIjI1L:
    int ACTIVE_THREADS -> do
    nidefawl.qubes.network.Connection conn -> do
    boolean interrupted -> do
    24:44:void run() -> run
nidefawl.qubes.network.StreamIO -> jIiJL1jIIjiJJijI:
    void read(java.io.DataInput) -> do
    void write(java.io.DataOutput) -> do
nidefawl.qubes.network.WriterThread -> L1ll1LiJJiiJllL1:
    int ACTIVE_THREADS -> do
    nidefawl.qubes.network.Connection conn -> do
    boolean interrupted -> do
    23:45:void run() -> run
nidefawl.qubes.network.client.ClientHandler -> iJiJIjjI1LIjiJIj:
    int state -> do
    nidefawl.qubes.network.client.NetworkClient client -> do
    long time -> do
    int disconnectFrom -> if
    java.lang.String disconnectReason -> do
    nidefawl.qubes.world.WorldClient world -> do
    nidefawl.qubes.entity.PlayerSelf player -> do
    nidefawl.qubes.chunk.client.ChunkManagerClient chunkManager -> do
    java.util.zip.Inflater inflate -> do
    byte[] tmpBuffer -> do
    70:71:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    75:86:void handleHandshake(nidefawl.qubes.network.packet.PacketHandshake) -> do
    89:98:void handleSync$41f19c9b() -> do
    101:116:void handleAuth(nidefawl.qubes.network.packet.PacketAuth) -> do
    125:126:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    143:147:void onDisconnect(int,java.lang.String) -> do
    149:151:java.lang.String getDisconnectReason() -> do
    156:171:void handleSpawnInWorld(nidefawl.qubes.network.packet.PacketSSpawnInWorld) -> do
    177:183:void handleTeleport(nidefawl.qubes.network.packet.PacketSTeleport) -> do
    186:187:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    190:193:void byteToShortArray(byte[],short[],int) -> do
    199:224:void handleChunkDataMulti(nidefawl.qubes.network.packet.PacketSChunkData,int) -> do
    227:297:void processChunkData(nidefawl.qubes.network.packet.PacketSChunkData,byte[],int) -> do
    305:315:byte[] inflate(byte[]) -> do
    320:320:boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    324:325:void handleBlock(nidefawl.qubes.network.packet.PacketSSetBlock) -> do
    328:354:void handleMultiBlock(nidefawl.qubes.network.packet.PacketSSetBlocks) -> do
    357:370:void handleLightChunk(nidefawl.qubes.network.packet.PacketSLightChunk) -> do
    372:376:void handleTrackChunk(nidefawl.qubes.network.packet.PacketSTrackChunk) -> do
    379:380:void handleChat(nidefawl.qubes.network.packet.PacketChatMessage) -> do
    383:385:void handleChannels(nidefawl.qubes.network.packet.PacketChatChannels) -> do
    391:395:void handleWorldTime(nidefawl.qubes.network.packet.PacketSWorldTime) -> do
    401:405:void handleEntityUntrack(nidefawl.qubes.network.packet.PacketSEntityUnTrack) -> do
    411:421:void handleEntityTrack(nidefawl.qubes.network.packet.PacketSEntityTrack) -> do
    427:440:void handleEntityMove(nidefawl.qubes.network.packet.PacketSEntityMove) -> do
    444:446:void handleWorldBiomes(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    448:449:void handleServerDigState(nidefawl.qubes.network.packet.PacketSDigState) -> do
    451:456:void handleDebugBBs(nidefawl.qubes.network.packet.PacketSDebugBB) -> do
    458:461:void handleDebugPath$6ebe27c9() -> if
    464:471:void handleInvSync(nidefawl.qubes.network.packet.PacketSInvSync) -> do
    473:480:void handleInvSyncIncr(nidefawl.qubes.network.packet.PacketSInvSyncIncr) -> do
    482:492:void handleCraftingProgress(nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
    495:500:void handleInvCarried(nidefawl.qubes.network.packet.PacketSInvCarried) -> do
nidefawl.qubes.network.client.ClientHandler$1 -> IjiJllJiJiL1Ij:
    byte[] decpressData -> do
    nidefawl.qubes.network.packet.PacketSChunkData val$packet -> do
    int val$flags -> do
    nidefawl.qubes.network.client.ClientHandler this$0 -> do
    212:215:void post() -> if
    200:200:java.lang.Object call() -> call
nidefawl.qubes.network.client.NetworkClient -> jIllllL1jIiJIjll:
    nidefawl.qubes.network.client.ClientHandler handler -> do
    nidefawl.qubes.network.Connection conn -> do
    int netVersion -> do
    49:70:void processLogin() -> do
    81:82:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    85:86:void disconnect(java.lang.String) -> do
    90:91:void onKick$4f708078(java.lang.String) -> if
nidefawl.qubes.network.client.ThreadConnect -> jIiJL1lljIjIIjIj:
    java.lang.String host -> if
    int port -> do
    java.lang.Thread thread -> do
    boolean finished -> do
    boolean cancelled -> if
    boolean connected -> for
    java.lang.String stateStr -> do
    26:62:void run() -> run
nidefawl.qubes.network.packet.AbstractPacketWorldRef -> Jill1LJiL1IjJiJi:
    int worldID -> do
    20:21:void readPacket(java.io.DataInput) -> do
    25:26:void writePacket(java.io.DataOutput) -> do
nidefawl.qubes.network.packet.InvalidPacketException -> IjiJjIjIiJJiIjll:
    java.lang.Class clazz -> do
nidefawl.qubes.network.packet.Packet -> L11LiJIjL1JiIjll:
    int NEXT_PACKET_ID -> do
    java.lang.Class[] packets -> do
    boolean[] sentByServer -> do
    boolean[] sentByClient -> if
    java.util.Map classToIDMap -> do
    int id -> if
    nidefawl.qubes.network.packet.Packet lastSuccess -> do
    73:85:nidefawl.qubes.network.packet.Packet read(java.io.DataInput) -> do
    89:91:void write(nidefawl.qubes.network.packet.Packet,java.io.DataOutput) -> do
    void readPacket(java.io.DataInput) -> do
    void writePacket(java.io.DataOutput) -> do
    void handle(nidefawl.qubes.network.Handler) -> do
    105:113:nidefawl.qubes.network.packet.Packet makePacket(java.lang.Class) -> do
    121:126:void register(java.lang.Class,boolean,boolean) -> do
    135:135:java.lang.String readString(java.io.DataInput) -> do
    139:146:java.lang.String readString(java.io.DataInput,int) -> do
    149:156:void writeString(java.lang.String,java.io.DataOutput) -> do
    159:171:nidefawl.qubes.item.BaseStack readStack(java.io.DataInput) -> do
    177:188:void writeStack(nidefawl.qubes.item.BaseStack,java.io.DataOutput) -> do
nidefawl.qubes.network.packet.PacketAuth -> jIllJiIjL11LL1jI:
    java.lang.String name -> do
    boolean success -> do
    29:31:void readPacket(java.io.DataInput) -> do
    35:37:void writePacket(java.io.DataOutput) -> do
    41:42:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCCrafting -> iJjIjIJijIIjJijI:
    int catid -> do
    int recipeid -> if
    int action -> for
    int amount -> int
    32:36:void readPacket(java.io.DataInput) -> do
    40:44:void writePacket(java.io.DataOutput) -> do
    48:48:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCDigState -> JiIjL11LL11LL1L1:
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> if
    nidefawl.qubes.item.BaseStack stack -> do
    int stage -> for
    34:40:void readPacket(java.io.DataInput) -> do
    44:50:void writePacket(java.io.DataOutput) -> do
    56:57:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCInvClick -> IjJillllL1IjIjJi:
    int id -> do
    int idx -> if
    int button -> for
    int action -> int
    nidefawl.qubes.item.BaseStack stack -> do
    31:36:void readPacket(java.io.DataInput) -> do
    40:45:void writePacket(java.io.DataOutput) -> do
    49:49:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCInvTransaction -> iJL1iJL1ll1LiJ1L:
    int id -> do
    int action -> if
    25:27:void readPacket(java.io.DataInput) -> do
    31:33:void writePacket(java.io.DataOutput) -> do
    37:37:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCMovement -> jIiJ1LjI1L1LIjL1:
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> do
    27:31:void readPacket(java.io.DataInput) -> do
    35:41:void writePacket(java.io.DataOutput) -> do
    47:47:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSetBlock -> jIIj1LIjllJillJi:
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> if
    nidefawl.qubes.item.BlockStack stack -> do
    33:40:void readPacket(java.io.DataInput) -> do
    44:49:void writePacket(java.io.DataOutput) -> do
    55:56:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSetBlocks -> L1L1iJjIL1L11Lll:
    int x -> if
    int y -> for
    int z -> int
    int x2 -> new
    int y2 -> try
    int z2 -> byte
    nidefawl.qubes.item.BlockStack stack -> do
    int flags -> case
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> char
    47:60:void readPacket(java.io.DataInput) -> do
    64:75:void writePacket(java.io.DataOutput) -> do
    81:82:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSettings -> iJjIlljIllL1Jill:
    int chunkLoadDistance -> do
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:29:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSwitchWorld -> L1IjjIJiiJjIJiiJ:
    int flags -> do
    21:22:void readPacket(java.io.DataInput) -> do
    26:27:void writePacket(java.io.DataOutput) -> do
    33:33:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCTeleportAck -> L1JiiJlljIll1Lll:
    int sync -> if
    21:23:void readPacket(java.io.DataInput) -> do
    27:29:void writePacket(java.io.DataOutput) -> do
    35:35:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketChatChannels -> L1JiL11LJiJi:
    java.util.ArrayList list -> do
    40:45:void readPacket(java.io.DataInput) -> do
    52:56:void writePacket(java.io.DataOutput) -> do
    68:69:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketChatMessage -> iJJiL1iJlljIL1L1:
    java.lang.String channel -> do
    java.lang.String message -> if
    21:23:void readPacket(java.io.DataInput) -> do
    27:29:void writePacket(java.io.DataOutput) -> do
    33:34:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketDisconnect -> jIIj1LIjJijIIj1L:
    int code -> do
    java.lang.String message -> do
    20:22:void readPacket(java.io.DataInput) -> do
    26:28:void writePacket(java.io.DataOutput) -> do
    32:33:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketHandshake -> L1JiJi1LIjL1Ji1L:
    int version -> do
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:30:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketPing -> JiL11L1LjI1LiJjI:
    long time -> do
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:30:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSChunkData -> iJjIllL11LiJJi1L:
    int len -> if
    byte[] blocks -> do
    int flags -> for
    int[][] coords -> do
    23:33:void readPacket(java.io.DataInput) -> do
    37:46:void writePacket(java.io.DataOutput) -> do
    52:60:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSCraftingProgress -> iJjIllIj1LIjL1ll:
    int id -> do
    int action -> if
    long currentTime -> do
    long startTime -> if
    long endTime -> for
    int recipe -> for
    boolean finished -> do
    int amount -> int
    27:35:void readPacket(java.io.DataInput) -> do
    39:47:void writePacket(java.io.DataOutput) -> do
    51:52:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSDebugBB -> iJjIiJJijIiJ1LIj:
    java.util.List boxes -> do
    24:31:void readPacket(java.io.DataInput) -> do
    35:40:void writePacket(java.io.DataOutput) -> do
    44:45:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSDebugPath -> L1jI1L1L1LjIjIL1:
    java.util.List pts -> do
    25:33:void readPacket(java.io.DataInput) -> do
    37:44:void writePacket(java.io.DataOutput) -> do
    48:49:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSDigState -> IjiJjIIjjIIjjIL1:
    int stage -> if
    23:25:void readPacket(java.io.DataInput) -> do
    29:31:void writePacket(java.io.DataOutput) -> do
    37:39:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityMove -> JiiJL1IjlliJ:
    int entId -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> if
    float yawBodyOffset -> for
    37:46:void readPacket(java.io.DataInput) -> do
    50:62:void writePacket(java.io.DataOutput) -> do
    68:69:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityTrack -> IjJijI1LjIIjL1Ji:
    int entId -> do
    int entType -> if
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float yawbody -> if
    float pitch -> for
    nidefawl.qubes.nbt.Tag data -> do
    35:45:void readPacket(java.io.DataInput) -> do
    49:66:void writePacket(java.io.DataOutput) -> do
    72:73:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityUnTrack -> IjL1IjiJJi1LjIJi:
    int entId -> do
    30:31:void readPacket(java.io.DataInput) -> do
    35:36:void writePacket(java.io.DataOutput) -> do
    42:43:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSInvCarried -> jIJi1LlljIlliJIj:
    nidefawl.qubes.inventory.slots.SlotStack stack -> do
    27:29:void readPacket(java.io.DataInput) -> do
    33:34:void writePacket(java.io.DataOutput) -> do
    38:39:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSInvSync -> JijIJiL1iJlllljI:
    int invId -> do
    int invSize -> if
    java.util.Collection stacks -> do
    31:40:void readPacket(java.io.DataInput) -> do
    44:50:void writePacket(java.io.DataOutput) -> do
    54:55:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSInvSyncIncr -> llL1ll1LllJill1L:
    int invId -> do
    java.util.Collection stacks -> do
    30:38:void readPacket(java.io.DataInput) -> do
    42:47:void writePacket(java.io.DataOutput) -> do
    51:52:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSLightChunk -> JiiJllL1IjlljIll:
    int coordX -> if
    int coordZ -> for
    byte[] data -> do
    short min -> do
    short max -> if
    22:30:void readPacket(java.io.DataInput) -> do
    34:41:void writePacket(java.io.DataOutput) -> do
    47:50:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSSetBlock -> iJ1LlliJ1LL1IjjI:
    int x -> if
    int y -> for
    int z -> int
    int type -> new
    int light -> try
    29:36:void readPacket(java.io.DataInput) -> do
    40:46:void writePacket(java.io.DataOutput) -> do
    52:54:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSSetBlocks -> L1Ij1LIjiJIj1L1L:
    int chunkX -> if
    int chunkZ -> for
    short[] positions -> do
    short[] blocks -> if
    byte[] lights -> do
    short[] data -> for
    nidefawl.qubes.chunk.blockdata.BlockData[] bdata -> do
    int numBlockData -> int
    43:73:void readPacket(java.io.DataInput) -> do
    77:98:void writePacket(java.io.DataOutput) -> do
    104:106:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSSpawnInWorld -> L1JiIjiJiJ1LL1:
    nidefawl.qubes.world.IWorldSettings worldSettings -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    int flags -> do
    int entId -> if
    int worldType -> for
    31:37:void readPacket(java.io.DataInput) -> do
    41:48:void writePacket(java.io.DataOutput) -> do
    54:55:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSTeleport -> jI1LIjL1iJL1L1iJ:
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> if
    int sync -> for
    31:37:void readPacket(java.io.DataInput) -> do
    41:49:void writePacket(java.io.DataOutput) -> do
    55:56:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSTrackChunk -> iJlliJjIiJllL1L1:
    int x -> if
    int z -> for
    boolean add -> do
    24:29:void readPacket(java.io.DataInput) -> do
    33:37:void writePacket(java.io.DataOutput) -> do
    41:43:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSWorldBiomes -> IjiJL1L1llJi1Lll:
    int numBiomes -> if
    int[] coordsX -> do
    int[] coordsZ -> if
    byte[] biomes -> do
    34:44:void readPacket(java.io.DataInput) -> do
    48:55:void writePacket(java.io.DataOutput) -> do
    61:63:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSWorldTime -> L11LjIlllliJIjJi:
    long time -> do
    long daylen -> if
    boolean isFixed -> do
    25:29:void readPacket(java.io.DataInput) -> do
    33:37:void writePacket(java.io.DataOutput) -> do
    43:46:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSyncBlocks -> iJJiiJJiJiIjJiL1:
    short[] blockIds -> do
    23:32:void readPacket(java.io.DataInput) -> do
    36:39:void writePacket(java.io.DataOutput) -> do
    43:44:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.path.Path -> JillL1iJIjIj1LjI:
    nidefawl.qubes.path.PathPoint[] arr -> do
    int curPos -> do
    13:13:boolean isFinished() -> do
nidefawl.qubes.path.PathFinder -> iJiJiJlliJ1LIj1L:
    nidefawl.qubes.path.PathList path -> do
    java.util.Map block -> do
    nidefawl.qubes.vec.BlockPos size -> do
    nidefawl.qubes.path.PathPoint[] pathOptions -> do
    109:138:nidefawl.qubes.path.PathPoint getPoint(nidefawl.qubes.entity.Entity,int,int,int,int) -> do
    141:160:int getBlockState(nidefawl.qubes.entity.Entity,int,int,int) -> do
    163:175:nidefawl.qubes.path.Path createPath$2dbdd287(nidefawl.qubes.path.PathPoint) -> do
    178:191:nidefawl.qubes.path.PathPoint addPoint(int,int,int) -> do
nidefawl.qubes.path.PathList -> iJ1LiJJiL1JiJi1L:
    java.util.LinkedList list -> do
    java.util.Comparator comparator -> do
    25:33:void addPoint(nidefawl.qubes.path.PathPoint) -> do
nidefawl.qubes.path.PathList$1 -> jI1LIjjIIjL1jI1L:
    11:11:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.path.PathPoint -> JiIjJiJi1LllL1Ij:
    int x -> do
    int y -> if
    int z -> for
    float totalPathDistance -> do
    float distanceToNext -> if
    boolean isFirst -> do
    int pos -> int
    nidefawl.qubes.path.PathPoint previous -> do
    29:30:float distanceTo(nidefawl.qubes.path.PathPoint) -> do
    35:39:boolean equals(java.lang.Object) -> equals
    43:43:int hashCode() -> hashCode
    47:47:boolean inUse() -> do
    51:52:void getPosition(nidefawl.qubes.entity.EntityAI,nidefawl.qubes.vec.Vec3D) -> do
    56:56:java.lang.String toString() -> toString
nidefawl.qubes.path.RandomPosGen -> ll1LIjiJll1LL1Ji:
    nidefawl.qubes.vec.BlockPos tmp -> do
nidefawl.qubes.perf.TimingHelper -> lljI1L1LjIjI1LiJ:
    boolean useNanos -> do
    int LEN -> do
    long[] nanos -> do
    long[] millis -> if
    long[] calls -> for
    long[] beginNanos -> int
    long[] beginMillis -> new
    80:83:void startSilent(int) -> do
nidefawl.qubes.render.AbstractRenderer -> llIjjI1LiJllJiL1:
    boolean recompileShaders -> do
    java.util.List resourcesShaders -> do
    java.util.List resourcesShadersNew -> if
    java.util.List resourcesFramebuffers -> for
    25:37:void addResource(nidefawl.qubes.util.IManagedResource) -> do
    41:47:void release() -> for
    60:66:void popNewShaders() -> int
    72:76:void releaseNewShaders() -> new
    81:97:void releaseAll$5ce050c6(int) -> do
nidefawl.qubes.render.AbstractRenderer$1 -> L1iJiJIjjIllJiJi:
    int[] $SwitchMap$nidefawl$qubes$util$EResourceType -> do
nidefawl.qubes.render.BlurRenderer -> llIjJiiJiJIjIjjI:
    nidefawl.qubes.gl.FrameBuffer fbBlur1 -> do
    nidefawl.qubes.gl.FrameBuffer fbBlur2 -> if
    nidefawl.qubes.gl.FrameBuffer fbSSRBlurredX -> for
    nidefawl.qubes.gl.FrameBuffer fbSSRBlurredY -> int
    nidefawl.qubes.shader.Shader shaderBlurSeperate -> do
    nidefawl.qubes.shader.Shader shaderBlurKawase -> if
    boolean startup -> if
    int[][] kawaseKernelSizePasses -> do
    float w1 -> do
    float h1 -> if
    46:69:void initShaders() -> do
    105:108:void resize(int,int) -> do
nidefawl.qubes.render.FinalRenderer -> iJIjIjllL1IjJi:
    nidefawl.qubes.shader.Shader shaderBloomCombine -> do
    nidefawl.qubes.shader.Shader shaderFinal -> if
    nidefawl.qubes.shader.Shader shaderDeferred -> char
    nidefawl.qubes.shader.Shader shaderDeferredWater -> else
    nidefawl.qubes.shader.Shader shaderDeferredFirstPerson -> goto
    nidefawl.qubes.shader.Shader shaderInterpLum -> for
    nidefawl.qubes.shader.Shader shaderThreshold -> int
    nidefawl.qubes.shader.Shader shaderSSR -> new
    nidefawl.qubes.shader.Shader shaderSSRCombine -> try
    nidefawl.qubes.shader.Shader shaderDownsample4x -> byte
    nidefawl.qubes.shader.Shader shaderDownsample4xLum -> case
    nidefawl.qubes.shader.Shader shaderNormals -> long
    nidefawl.qubes.gl.FrameBuffer fbScene -> do
    nidefawl.qubes.gl.FrameBuffer fbSSR -> if
    nidefawl.qubes.gl.FrameBuffer fbSSRCombined -> for
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> int
    nidefawl.qubes.gl.FrameBuffer fbSSAO -> try
    nidefawl.qubes.gl.FrameBuffer fbFinal -> new
    nidefawl.qubes.gl.FrameBuffer[] fbLuminanceDownsample -> do
    nidefawl.qubes.gl.FrameBuffer[] fbLuminanceInterp -> if
    int preWaterDepthTex -> do
    boolean startup -> for
    int ssr -> if
    int frame -> for
    nidefawl.qubes.render.post.SMAA smaa -> do
    boolean aoNeedsInit -> if
    java.nio.FloatBuffer scaleMatBuf -> do
    int[] aoSize -> do
    186:188:void render(nidefawl.qubes.world.World,float,int) -> do
    363:524:void initShaders() -> do
    529:556:void initAO() -> if
    579:587:void initAA() -> try
    590:685:void resize(int,int) -> do
    688:692:void aoReinit() -> byte
    696:698:void release() -> for
    711:713:void setSSR(int) -> if
nidefawl.qubes.render.FinalRenderer$1 -> iJJi1LiJIjJi1LIj:
    369:373:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$2 -> L1iJJiL1jIjIJiIj:
    380:383:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$3 -> L1L1L1JiL1jIL1Ji:
    389:392:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$4 -> L1L1JiJiiJiJiJiJ:
    398:401:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$5 -> jIiJL1iJIjIjlljI:
    407:410:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$6 -> ll1LL1JiL1JiiJJi:
    417:419:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.FinalRenderer$7 -> JiL1L11LL1jIL1:
    430:432:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.LightCompute -> L1iJ1LL1llJi1L1L:
    nidefawl.qubes.shader.Shader shaderComputerLight -> do
    int[] lightTiles -> do
    nidefawl.qubes.shader.ShaderBuffer lights -> do
    int lightTilesTex -> do
    boolean startup -> if
    int[] debugResults -> if
    int numLights -> if
    46:67:void initShaders() -> do
    78:88:void resize(int,int) -> do
    91:115:void updateLights(nidefawl.qubes.world.WorldClient,float) -> do
    117:145:void render$1a015713(int) -> if
    239:239:int getTexture() -> do
nidefawl.qubes.render.ShadowRenderer -> ll1L1L1LjIjIJi1L:
    nidefawl.qubes.shader.Shader shadowShader -> do
    boolean startup -> if
    int renderMode -> do
    int SHADOW_BUFFER_SIZE -> if
    java.lang.String[] shaderNames -> do
    nidefawl.qubes.gl.FrameBuffer fbShadow -> do
    82:84:void init() -> do
    187:194:void resize$255f295() -> if
nidefawl.qubes.render.ShadowRenderer$1 -> iJJiJiiJL1L1llJi:
    52:55:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.WorldRenderer -> lljIlllllliJjIL1:
    nidefawl.qubes.vec.Vector3f skyColor -> if
    nidefawl.qubes.vec.Vector3f fogColor -> for
    java.util.HashMap debugBBs -> do
    java.util.HashMap debugPaths -> if
    int rendered -> do
    boolean startup -> if
    int texWaterNoise -> if
    nidefawl.qubes.shader.Shader terrainShader -> do
    nidefawl.qubes.shader.Shader terrainShaderFar -> int
    nidefawl.qubes.shader.Shader waterShader -> if
    nidefawl.qubes.shader.Shader shaderModelVoxel -> new
    nidefawl.qubes.shader.Shader shaderModelfirstPerson -> try
    nidefawl.qubes.models.render.QModelBatchedRender modelRender -> do
    nidefawl.qubes.gl.TesselatorState skybox1 -> do
    nidefawl.qubes.gl.TesselatorState skybox2 -> if
    nidefawl.qubes.shader.Shader shaderZPre -> byte
    nidefawl.qubes.shader.Shader skyShader2 -> for
    int idx -> int
    int texNoise3D -> for
    nidefawl.qubes.models.qmodel.QModelProperties modelProperties -> do
    nidefawl.qubes.vec.Vector3f mPos -> do
    float modelRot -> do
    float lastModelRot -> if
    102:177:void initShaders() -> do
    181:251:void reloadModel() -> if
    420:431:void renderEntities(nidefawl.qubes.world.World,int,float,nidefawl.qubes.shader.Shader,int) -> do
    546:609:void renderFirstPerson$5fb87b55(float) -> do
    725:796:void resize$255f295() -> try
nidefawl.qubes.render.WorldRenderer$1 -> jIL1L1iJIjJillll:
    110:113:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.WorldRenderer$2 -> iJJiL1IjiJJijIL1:
    122:125:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.WorldRenderer$3 -> iJJillIjiJllL1Ij:
    185:185:boolean accept(java.io.File) -> accept
nidefawl.qubes.render.gui.SingleBlockDraw -> llL1L1IjJiiJJill:
    nidefawl.qubes.gl.GLVBO vbo -> do
    nidefawl.qubes.gl.GLVBO vboIdx -> if
    nidefawl.qubes.gl.ReallocIntBuffer vboBuf -> do
    nidefawl.qubes.gl.ReallocIntBuffer vboIdxBuf -> if
    nidefawl.qubes.gl.BufferedMatrix modelMatrix -> do
    nidefawl.qubes.gl.BufferedMatrix projMatrix -> if
    float x -> if
    float y -> for
    float z -> int
    float scale -> do
    float rotX -> new
    float rotY -> try
    float rotZ -> byte
    66:107:void drawBlockDefault(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    109:122:void drawBlock(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> if
    125:134:void doRender(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> for
    143:146:void setOffset(float,float,float) -> do
    162:165:void setRotation(float,float,float) -> if
nidefawl.qubes.render.gui.SingleBlockRenderAtlas -> lljIJiiJllllL1Ji:
    nidefawl.qubes.render.gui.SingleBlockRenderAtlas instance -> do
    byte[] defaultData -> do
    nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas[] textures -> do
    java.util.Map map -> do
    boolean rendering -> do
    64:64:float getTexW() -> do
    67:67:float getX(int) -> do
    70:70:float getY(int) -> if
    73:73:int getXPx(int) -> do
    76:76:int getYPx(int) -> if
    101:101:nidefawl.qubes.render.gui.SingleBlockRenderAtlas getInstance() -> do
    118:126:nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas getAtlas(int,boolean) -> do
    162:162:void init() -> do
nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas -> JiJiiJllL1iJIjjI:
    int[] hashes -> do
    nidefawl.qubes.gl.FrameBuffer frameBuffer -> do
    48:57:int getTextureIdx(int) -> do
nidefawl.qubes.render.gui.SingleBlockRenderer -> Ijll1LllL1L1llIj:
    nidefawl.qubes.vec.BlockPos offset -> do
    nidefawl.qubes.util.SingleBlockWorld singleBlockWorld -> do
    nidefawl.qubes.gl.VertexBuffer singleBlockBuffer -> do
    32:38:nidefawl.qubes.gl.VertexBuffer renderSingleBlock(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    51:52:void putBuffer(nidefawl.qubes.block.Block,int) -> do
    54:55:void putSingleVert(nidefawl.qubes.block.Block,int,int) -> do
    57:58:void incVertCount(nidefawl.qubes.block.Block,int,int) -> if
    61:62:void putTriIndex(nidefawl.qubes.block.Block,int,int[]) -> do
nidefawl.qubes.render.post.HBAOPlus -> nidefawl.qubes.render.post.HBAOPlus:
    boolean hasContext -> hasContext
    boolean needsInit -> needsInit
    void createContext(int,int) -> createContext
    void deleteContext() -> deleteContext
    void renderAO() -> renderAO
    void setProjMatrix(long) -> setProjMatrix
    void setViewMatrix(long) -> setViewMatrix
    void setOutputFBO(int) -> setOutputFBO
    void setDepthTex(int) -> setDepthTex
    void setRenderMask(int) -> setRenderMask
    void setNormalTex(int) -> setNormalTex
    void setBias(float) -> setBias
    void setNormalDecodeScaleBias(float,float) -> setNormalDecodeScaleBias
    void setRadius(float) -> setRadius
    void setDetailAO(float) -> setDetailAO
    void setCoarseAO(float) -> setCoarseAO
    void setPowerExponent(float) -> setPowerExponent
    void setDepthStorage(int) -> setDepthStorage
    void setDepthClampMode(int) -> setDepthClampMode
    void setDepthThreshold(boolean,float,float) -> setDepthThreshold
    void setBlur(boolean,int,float) -> setBlur
    void setBlurSharpen(boolean,float,float,float) -> setBlurSharpen
    void debugControl(int) -> debugControl
    java.lang.String[] getCallStack() -> getCallStack
nidefawl.qubes.render.post.SMAA -> L1IjJiiJlliJL1ll:
    nidefawl.qubes.util.SimpleResourceManager mgr -> do
    nidefawl.qubes.shader.Shader shaderAAEdge -> do
    nidefawl.qubes.shader.Shader shaderAABlendWeight -> if
    nidefawl.qubes.shader.Shader shaderAANeighborBlend -> for
    nidefawl.qubes.gl.FrameBuffer fbAAEdge -> do
    nidefawl.qubes.gl.FrameBuffer fbAAWeightBlend -> if
    int areaTex -> do
    int searchTex -> if
    java.lang.String[] qualDefines -> do
    java.lang.String[] qualDesc -> if
    112:145:int makeAATexture$3e3a58ba(byte[],int,int,int,int) -> do
nidefawl.qubes.render.post.SMAA$1 -> IjllJijIllIjlliJ:
    int val$quality -> do
    58:61:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.render.region.MeshedRegion -> JiiJlljIL1IjJi1L:
    int[] vertexCount -> do
    int[] elementCount -> if
    boolean[] hasPass -> do
    int rX -> do
    int rZ -> if
    int rY -> for
    nidefawl.qubes.vec.AABBInt aabb -> do
    int[] frustumStates -> for
    boolean needsUpdate -> do
    boolean isUpdating -> if
    boolean isRenderable -> for
    boolean isValid -> int
    int failedCached -> int
    boolean hasAnyPass -> new
    nidefawl.qubes.gl.GLVBO[] vbo -> do
    nidefawl.qubes.gl.GLVBO[] vboIndices -> if
    int shadowDrawMode -> new
    boolean frustumStateChanged -> try
    int occlusionQueryState -> try
    int occlusionResult -> byte
    int occlFrameSkips -> case
    int distance -> char
    nidefawl.qubes.vec.Vector3f queryPos -> do
    long totalBytes -> do
    long[] alloc -> if
    long[] totalBytesPass -> do
    int nextBuffer -> else
    58:62:void renderRegion$2549578(int) -> do
    92:123:void uploadBuffer(int,nidefawl.qubes.gl.VertexBuffer,int) -> do
    127:146:void release() -> do
    157:168:void updateBB() -> if
    172:172:java.lang.String toString() -> toString
nidefawl.qubes.render.region.RegionRenderer -> iJIjIjiJiJL1JiL1:
    int RENDER_DISTANCE -> do
    int OFFS_OVER -> if
    int LENGTH_OVER -> for
    int HEIGHT_SLICES -> int
    java.util.Comparator compareUpdateRenderers -> do
    java.util.Comparator compareRenderers -> if
    int rendered -> new
    int occlCulled -> try
    int renderChunkX -> byte
    int renderChunkY -> goto
    int renderChunkZ -> case
    java.util.ArrayList renderList -> do
    java.util.ArrayList shadowRenderList -> for
    java.util.ArrayList regionsToUpdate -> if
    boolean needsSortingUpdateRenderers -> if
    int[] occlQueries -> do
    nidefawl.qubes.render.region.MeshedRegion[] occlQueriesRunning -> do
    int queriesRunning -> char
    nidefawl.qubes.shader.Shader occlQueryShader -> do
    boolean startup -> for
    float camX -> do
    float camY -> if
    float camZ -> for
    nidefawl.qubes.render.region.MeshedRegion[][] regions -> do
    int numV -> else
    nidefawl.qubes.gl.ReallocIntBuffer[] buffers -> do
    nidefawl.qubes.gl.ReallocIntBuffer[] idxShortBuffers -> if
    java.util.ArrayList justrendered -> int
    112:116:void init() -> do
    140:154:nidefawl.qubes.render.region.MeshedRegion[][] create() -> do
    218:224:nidefawl.qubes.render.region.MeshedRegion getByRegionCoord(int,int,int) -> do
    228:244:void resetAll() -> if
    254:279:void reRender() -> try
    303:316:void flagChunk(int,int) -> do
    488:513:void renderRegions$1b9a29e8(float,int,int,int) -> do
    518:521:void flushRegions() -> byte
    529:656:void update$6a54b3b6(nidefawl.qubes.world.WorldClient,float,float,float) -> do
    720:726:int sortUpdateRenderersCompare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> do
    732:738:int sortRenderersCompare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> if
nidefawl.qubes.render.region.RegionRenderer$1 -> iJJiJiIjIjL1L1L1:
    nidefawl.qubes.render.region.RegionRenderer this$0 -> do
    47:47:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.render.region.RegionRenderer$2 -> llJi1LiJjIllll1L:
    nidefawl.qubes.render.region.RegionRenderer this$0 -> do
    53:53:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.shader.AbstractUniform -> JiL11LiJ1LIjIjJi:
    int loc -> do
    boolean first -> do
    13:13:boolean validLoc() -> do
    18:18:void release() -> do
nidefawl.qubes.shader.ComputeShader -> jIIjjIlliJL1jIJi:
    int computeShader -> for
    49:66:void release() -> char
nidefawl.qubes.shader.GraphicShader -> lljIIj1LL1:
    int fragShader -> for
    int vertShader -> int
    int geometryShader -> new
    java.lang.String attr -> if
    98:145:void attach() -> new
    147:172:void release() -> char
nidefawl.qubes.shader.IShaderDef -> L1iJJiJi1L1L1LL1:
    java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.shader.Shader -> Ij1L1LL1jIll1LIj:
    int SHADERS -> do
    int shader -> if
    java.lang.String name -> do
    java.util.HashMap locations -> if
    java.util.HashMap uniforms -> do
    java.util.HashMap missinglocations -> for
    boolean valid -> do
    java.nio.IntBuffer buf -> do
    int lastBoundShader -> for
    31:32:void incUniformCalls() -> do
    77:96:void linkProgram() -> if
    100:102:int getStatus(int,int) -> do
    106:114:java.lang.String getLog(int,int) -> do
    117:121:void enable() -> for
    132:135:void disable() -> int
    139:143:void setProgramUniform1i(java.lang.String,int) -> do
    152:156:void setProgramUniform2f(java.lang.String,float,float) -> do
    158:162:void setProgramUniform1f(java.lang.String,float) -> do
    170:184:nidefawl.qubes.shader.AbstractUniform getUniform(java.lang.String,java.lang.Class) -> do
    188:192:void setProgramUniform4f(java.lang.String,float,float,float,float) -> do
    204:208:void setProgramUniformMatrix4$1ad3bb24(java.lang.String,boolean,java.nio.FloatBuffer) -> do
    234:234:int getType$37b71a40() -> if
nidefawl.qubes.shader.ShaderBuffer -> L1IjJijIIjiJJiIj:
    java.util.List buffers -> do
    java.lang.String name -> do
    int buffer -> do
    int len -> if
    int bindingPoint -> for
    java.util.List shaders -> if
    java.nio.ByteBuffer buf -> do
    java.nio.FloatBuffer bufFloat -> do
    java.nio.IntBuffer bufInt -> do
    java.nio.ByteBuffer readBuf -> if
    java.nio.FloatBuffer readBufFloat -> if
    51:52:nidefawl.qubes.shader.ShaderBuffer setSize(int) -> do
    55:80:void update() -> do
    100:107:void rebindShaders() -> if
    109:114:void init() -> for
    116:129:void bindBuffers(nidefawl.qubes.shader.Shader) -> do
    152:164:java.nio.ByteBuffer map(boolean) -> do
    198:199:void unmap() -> int
    201:202:void unbind() -> new
nidefawl.qubes.shader.ShaderCompileError -> JiiJllIjiJL1L1iJ:
    java.lang.String name -> do
    java.lang.String log -> if
    nidefawl.qubes.shader.ShaderSource code -> do
nidefawl.qubes.shader.ShaderSource -> iJ1LIjJijIJijIJi:
    java.util.regex.Pattern patternInclude -> do
    java.util.regex.Pattern patternDefine -> if
    java.util.regex.Pattern patternAttr -> for
    java.util.regex.Pattern lineErrorAMD -> int
    java.util.regex.Pattern lineErrorNVIDIA -> new
    java.util.HashMap sources -> do
    java.util.HashMap sourceNames -> if
    java.lang.String processed -> do
    int nInclude -> do
    java.lang.String attrTypes -> if
    41:42:void load(nidefawl.qubes.assets.AssetManager,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    44:149:java.lang.String readParse(nidefawl.qubes.assets.AssetManager,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef,boolean) -> do
    190:190:boolean isEmpty() -> do
    196:234:java.lang.String decorateErrors(java.lang.String) -> do
nidefawl.qubes.shader.ShaderSourceBundle -> JiiJllL1lljIjI:
    nidefawl.qubes.shader.ShaderSource computeCode -> do
    nidefawl.qubes.shader.ShaderSource vertCode -> if
    nidefawl.qubes.shader.ShaderSource fragCode -> for
    nidefawl.qubes.shader.ShaderSource geomCode -> int
    java.lang.String name -> do
nidefawl.qubes.shader.Shaders -> IjjIIjIjiJiJjIll:
    nidefawl.qubes.util.SimpleResourceManager shaders -> do
    nidefawl.qubes.util.SimpleResourceManager newshaders -> if
    boolean startup -> do
    nidefawl.qubes.shader.Shader depthBufShader -> do
    nidefawl.qubes.shader.Shader normals -> if
    nidefawl.qubes.shader.Shader wireframe -> for
    nidefawl.qubes.shader.Shader textured -> int
    nidefawl.qubes.shader.Shader colored -> new
    nidefawl.qubes.shader.Shader colored3D -> try
    nidefawl.qubes.shader.Shader textured3D -> long
    nidefawl.qubes.shader.Shader renderUINT -> byte
    nidefawl.qubes.shader.Shader singleblock -> case
    nidefawl.qubes.shader.Shader gui -> char
    nidefawl.qubes.shader.Shader item -> else
    nidefawl.qubes.shader.Shader tonemap -> goto
    17:18:void init() -> do
nidefawl.qubes.shader.Shaders$1 -> llIjL1IjjIll1LiJ:
    49:52:java.lang.String getDefinition(java.lang.String) -> do
nidefawl.qubes.shader.Uniform1f -> IjIjJi1L1LIjllJi:
    float lastX -> do
nidefawl.qubes.shader.Uniform1i -> jIIjL1L1IjJijIjI:
    int lastX -> if
nidefawl.qubes.shader.Uniform2f -> Jillll1LIj1LIj1L:
    float lastX -> do
    float lastY -> if
nidefawl.qubes.shader.Uniform3f -> L11LJiiJll1LJi:
    float lastX -> do
    float lastY -> if
    float lastZ -> for
nidefawl.qubes.shader.Uniform4f -> iJL1jIjIJijIJi1L:
    float lastX -> do
    float lastY -> if
    float lastZ -> for
    float lastW -> int
nidefawl.qubes.shader.UniformBuffer -> JiJilliJJiL1Ijll:
    int nextIdx -> do
    nidefawl.qubes.shader.UniformBuffer[] buffers -> do
    java.lang.String name -> do
    int buffer -> if
    int len -> for
    java.nio.FloatBuffer floatBuffer -> do
    int bindingPoint -> int
    nidefawl.qubes.shader.UniformBuffer uboMatrix3D -> do
    nidefawl.qubes.shader.UniformBuffer uboMatrix2D -> if
    nidefawl.qubes.shader.UniformBuffer uboMatrixShadow -> for
    nidefawl.qubes.shader.UniformBuffer uboSceneData -> int
    nidefawl.qubes.shader.UniformBuffer LightInfo -> new
    nidefawl.qubes.shader.UniformBuffer VertexDirections -> try
    nidefawl.qubes.shader.UniformBuffer TBNMat -> byte
    java.util.List shaders -> do
    41:42:nidefawl.qubes.shader.UniformBuffer addMat4() -> do
    45:46:nidefawl.qubes.shader.UniformBuffer addVec4() -> if
    53:54:void setPosition(int) -> do
    56:57:void reset() -> try
    59:60:void put(java.nio.FloatBuffer) -> if
    68:69:void put(float) -> do
    75:79:void put(float,float,float) -> do
    81:82:void putNeg(float,float,float) -> if
    84:93:void update() -> byte
    156:161:void init() -> do
    163:167:void destroy() -> if
    170:177:void rebindShaders() -> for
    180:193:void bindBuffers(nidefawl.qubes.shader.Shader) -> do
    217:327:void updateUBO(nidefawl.qubes.world.WorldClient,float) -> do
    333:393:void updateTBNMatrices() -> case
    474:480:void updateOrtho() -> int
    483:486:void setNormalMat(java.nio.FloatBuffer) -> do
    494:500:void updatePxOffset() -> new
nidefawl.qubes.shader.UniformMat4 -> IjiJL1L1iJjIjIIj:
    float[] last -> do
    boolean transpose -> if
    56:56:void release() -> do
nidefawl.qubes.texture.PNGDecoder -> iJL1L1jI1LIjIj:
    byte[] SIGNATURE -> do
    java.io.InputStream input -> do
    java.util.zip.CRC32 crc -> do
    byte[] buffer -> if
    int chunkLength -> new
    int chunkType -> try
    int chunkRemaining -> byte
    int width -> do
    int height -> if
    int bitdepth -> for
    int colorType -> int
    int bytesPerPixel -> case
    byte[] palette -> for
    byte[] paletteA -> int
    byte[] transPixel -> new
    boolean $assertionsDisabled -> do
    236:349:void decode(java.nio.ByteBuffer,int,nidefawl.qubes.texture.PNGDecoder$Format) -> do
    376:377:void copy(java.nio.ByteBuffer,byte[]) -> do
    380:399:void copyRGBtoABGR(java.nio.ByteBuffer,byte[]) -> if
    402:421:void copyRGBtoRGBA(java.nio.ByteBuffer,byte[]) -> for
    424:443:void copyRGBtoBGRA(java.nio.ByteBuffer,byte[]) -> int
    446:449:void copyRGBAtoABGR(java.nio.ByteBuffer,byte[]) -> new
    452:455:void copyRGBAtoBGRA(java.nio.ByteBuffer,byte[]) -> try
    458:461:void copyRGBAtoRGB(java.nio.ByteBuffer,byte[]) -> byte
    464:468:void copyGreyscaleToARGB(java.nio.ByteBuffer,byte[]) -> case
    472:491:void copyPALtoARGB(java.nio.ByteBuffer,byte[]) -> char
    494:497:void copyRGBAtoARGB(java.nio.ByteBuffer,byte[]) -> else
    499:518:void copyRGBtoARGB(java.nio.ByteBuffer,byte[]) -> goto
    521:540:void copyPALtoABGR(java.nio.ByteBuffer,byte[]) -> long
    543:562:void copyPALtoRGBA(java.nio.ByteBuffer,byte[]) -> this
    565:584:void copyPALtoBGRA(java.nio.ByteBuffer,byte[]) -> void
    587:594:void expand4(byte[],byte[]) -> do
    597:606:void expand2(byte[],byte[]) -> if
    609:622:void expand1(byte[],byte[]) -> for
    645:649:void unfilterSub(byte[]) -> do
    652:656:void unfilterUp(byte[],byte[]) -> int
    659:668:void unfilterAverage(byte[],byte[]) -> new
    671:691:void unfilterPaeth(byte[],byte[]) -> try
    788:802:void closeChunk() -> do
    805:811:void openChunk() -> if
    814:818:void openChunk(int) -> do
    821:824:void checkChunkLength(int) -> if
    827:833:int readChunk(byte[],int,int) -> do
    837:843:void refillInflater(java.util.zip.Inflater) -> do
    846:866:void readChunkUnzip(java.util.zip.Inflater,byte[],int,int) -> do
    871:878:void readFully(byte[],int,int) -> do
    881:881:int readInt(byte[],int) -> do
    899:904:boolean checkSignature(byte[]) -> do
nidefawl.qubes.texture.PNGDecoder$1 -> jIjIIjL1jIJiL1Ij:
    int[] $SwitchMap$nidefawl$qubes$texture$PNGDecoder$Format -> do
nidefawl.qubes.texture.PNGDecoder$Format -> Ji1L1LL1iJllJiIj:
    nidefawl.qubes.texture.PNGDecoder$Format ALPHA -> do
    nidefawl.qubes.texture.PNGDecoder$Format LUMINANCE -> if
    nidefawl.qubes.texture.PNGDecoder$Format LUMINANCE_ALPHA -> for
    nidefawl.qubes.texture.PNGDecoder$Format RGB -> int
    nidefawl.qubes.texture.PNGDecoder$Format RGBA -> new
    nidefawl.qubes.texture.PNGDecoder$Format BGRA -> try
    nidefawl.qubes.texture.PNGDecoder$Format ABGR -> byte
    nidefawl.qubes.texture.PNGDecoder$Format ARGB -> case
    int numComponents -> do
    nidefawl.qubes.texture.PNGDecoder$Format[] $VALUES -> do
    14:14:nidefawl.qubes.texture.PNGDecoder$Format[] values() -> values
    14:14:nidefawl.qubes.texture.PNGDecoder$Format valueOf(java.lang.String) -> valueOf
nidefawl.qubes.texture.TextureManager -> lliJllIjL1iJiJll:
    nidefawl.qubes.texture.TextureManager instance -> do
    int texNoise -> do
    int texEmpty -> if
    java.nio.ByteBuffer directBuf -> do
    41:41:nidefawl.qubes.texture.TextureManager getInstance() -> do
    77:92:int makeNewTexture(byte[],int,int,boolean,boolean,int) -> do
    96:96:int makeNewTexture(nidefawl.qubes.assets.AssetTexture,boolean,boolean,int) -> do
    106:153:void uploadTexture(byte[],int,int,int,int,int,boolean,boolean,int) -> do
    162:162:void destroy() -> do
nidefawl.qubes.texture.array.BlockNormalMapArray -> Ij1LJiIjL1lliJll:
    nidefawl.qubes.texture.array.BlockNormalMapArray instance -> do
    27:27:nidefawl.qubes.texture.array.BlockNormalMapArray getInstance() -> do
    39:44:void findMaxTileWidth() -> do
    49:74:void collectTextures(nidefawl.qubes.assets.AssetManager) -> do
    77:131:void uploadTextures() -> if
    136:154:void postUpload() -> for
nidefawl.qubes.texture.array.BlockTextureArray -> jIJill1LjIjIiJ1L:
    nidefawl.qubes.texture.array.BlockTextureArray instance -> do
    30:30:nidefawl.qubes.texture.array.BlockTextureArray getInstance() -> do
    38:57:void postUpload() -> for
    60:102:void uploadTextures() -> if
    106:130:void collectTextures(nidefawl.qubes.assets.AssetManager) -> do
nidefawl.qubes.texture.array.ItemTextureArray -> JilljIJiL1IjJiiJ:
    nidefawl.qubes.texture.array.ItemTextureArray instance -> do
    30:30:nidefawl.qubes.texture.array.ItemTextureArray getInstance() -> do
    40:84:void uploadTextures() -> if
    88:112:void collectTextures(nidefawl.qubes.assets.AssetManager) -> do
    116:134:void postUpload() -> for
nidefawl.qubes.texture.array.TextureArray -> llIjjIllll1LIj:
    java.util.HashMap texNameToAssetMap -> do
    java.util.HashMap blockIDToAssetList -> if
    java.util.HashMap slotTextureMap -> for
    boolean firstInit -> if
    int[] textures -> do
    int glid -> do
    int tileSize -> if
    int numTextures -> for
    int numMipmaps -> int
    int subtypeBits -> new
    boolean report -> do
    float loadprogress -> do
    float uploadprogress -> if
    57:59:void preUpdate() -> int
    61:69:void _load() -> case
    71:73:void load() -> new
    76:81:void reload() -> try
    85:91:void postUpdate() -> byte
    105:111:java.nio.ByteBuffer put(java.nio.ByteBuffer,byte[]) -> do
    115:115:int getTextureIdx(int,int) -> do
    118:119:void setTexture(int,int,int) -> do
    132:151:void findMaxTileWidth() -> do
    void uploadTextures() -> if
    void collectTextures(nidefawl.qubes.assets.AssetManager) -> do
    void postUpload() -> for
nidefawl.qubes.util.BinaryStreamReader -> IjL1llL1L1iJIjiJ:
    int offset -> do
    nidefawl.qubes.assets.AssetBinary asset -> do
    33:34:float readFloat() -> do
    45:45:nidefawl.qubes.vec.Vector3f readVec3() -> do
    53:53:nidefawl.qubes.vec.Vector4f readVec4() -> do
    57:64:int readInt() -> do
    67:72:int readUShort() -> if
    75:78:int readUByte() -> for
    87:90:java.lang.String readString(int) -> do
nidefawl.qubes.util.BlockColl -> iJ1LiJllIjjIiJL1:
    nidefawl.qubes.vec.AABB blockBB -> do
nidefawl.qubes.util.CollisionQuery -> IjJiiJIjllL1IjL1:
    java.util.ArrayList collisions -> do
    nidefawl.qubes.vec.AABBFloat[] tmpBBs -> do
    int numCollisions -> do
    29:66:void query(nidefawl.qubes.world.World,nidefawl.qubes.vec.AABB) -> do
    72:72:nidefawl.qubes.util.BlockColl get(int) -> do
nidefawl.qubes.util.CrashInfo -> nidefawl.qubes.util.CrashInfo:
    java.lang.String title -> title
    java.lang.String desc -> desc
    java.lang.String outBuf -> outBuf
    java.lang.String errBuf -> errBuf
    java.lang.String exc -> exc
    40:42:void setLogBuf(java.lang.String) -> setLogBuf
    48:50:void setErrBuf(java.lang.String) -> setErrBuf
    56:61:void setException(java.lang.Throwable) -> setException
nidefawl.qubes.util.EResourceType -> JijIjI1LIjIjL1Ji:
    int SHADER$78a1f91f -> do
    int FRAMEBUFFER$78a1f91f -> if
    int[] $VALUES$2628ef5a -> do
    10:10:int[] values$34a06927() -> do
nidefawl.qubes.util.GameError -> iJllJijIL1llJi1L:
nidefawl.qubes.util.GameMath -> iJ1LIj1LJiIjL11L:
    float[] m -> do
    float[] inv -> if
    12:12:float cos(float) -> do
    15:15:float sin(float) -> if
    20:20:float atan(float) -> for
    25:25:float atan2(float,float) -> do
    39:40:int floor(double) -> do
    43:43:int ceil(double) -> if
    51:91:void invertMat4x(java.nio.FloatBuffer,java.nio.FloatBuffer) -> do
    120:120:float coTangent(float) -> int
    124:124:float degreesToRadians(float) -> new
    128:128:float sqrtf(float) -> try
    132:135:int randomI(long) -> do
    144:144:int lhToZ(long) -> if
    147:147:int lhToX(long) -> for
    150:150:long toLong(int,int) -> do
    159:165:int log2(int) -> do
    168:168:int signum(float) -> do
    171:171:boolean isNormalFloat(float) -> do
    181:181:float clamp(float,float,float) -> do
    184:187:int distSq3Di(int,int,int,int,int,int) -> do
    226:240:double getAngle(double,double,double,double) -> do
    243:243:float tan(float) -> byte
    248:248:float easeInOutCubic(float) -> case
    251:262:int[] downsample(int,int,int) -> do
    266:266:int round(float) -> if
    269:274:float wrapAngle(float) -> char
nidefawl.qubes.util.IManagedResource -> JiIjll1LlljIiJJi:
    void release() -> char
    int getType$37b71a40() -> if
nidefawl.qubes.util.IResourceManager -> L1iJjI1LiJ1L1LiJ:
    void addResource(nidefawl.qubes.util.IManagedResource) -> do
nidefawl.qubes.util.Project -> IjlliJjIJiJiJi1L:
    float[] IDENTITY_MATRIX -> do
    java.nio.FloatBuffer finalMatrix -> do
    java.nio.FloatBuffer tempMatrix -> if
    float[] in -> if
    float[] out -> for
    nidefawl.qubes.vec.Vector3f tmp3 -> do
    nidefawl.qubes.vec.Vector3f tmp4 -> if
    nidefawl.qubes.vec.Vector3f tmp5 -> for
    45:78:boolean gluUnProject(float,float,float,java.nio.FloatBuffer,java.nio.FloatBuffer,java.nio.IntBuffer,java.nio.FloatBuffer) -> do
    199:210:void fovProjMat(float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    213:221:void orthoMat(float,float,float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    229:261:void lookAt(float,float,float,float,float,float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
nidefawl.qubes.util.RayTrace -> iJ1LJiL11Lll1LiJ:
    nidefawl.qubes.vec.Vector3f dirFrac -> do
    nidefawl.qubes.vec.AABBFloat bb -> do
    nidefawl.qubes.util.RayTrace$RayTraceIntersection intersection -> do
    nidefawl.qubes.vec.BlockPos quarter -> do
    boolean quarterMode -> do
    41:42:void reset() -> do
    45:142:void doRaytrace(nidefawl.qubes.world.World,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,int) -> do
    185:185:float intbound(float,float) -> do
    190:190:boolean hasHit() -> do
nidefawl.qubes.util.RayTrace$RayTraceIntersection -> IjJiIjjIllllllL1:
    int hit$66fbf084 -> do
    int blockId -> if
    nidefawl.qubes.vec.BlockPos blockPos -> do
    nidefawl.qubes.vec.BlockPos q -> if
    nidefawl.qubes.vec.Vector3f pos -> do
    float distance -> do
    int face -> for
nidefawl.qubes.util.RegionMap -> JiiJjIL1L1Ij:
    byte bits -> do
    int halfSize -> do
nidefawl.qubes.util.Renderable -> jIiJJiIj1LIj1LJi:
    void render(float,double,double) -> do
    void initGui(boolean) -> if
nidefawl.qubes.util.SimpleResourceManager -> L1Ijll1LllIjL1Ij:
    java.util.List resources -> do
    20:21:void addResource(nidefawl.qubes.util.IManagedResource) -> do
    25:28:void release() -> do
nidefawl.qubes.util.SingleBlockWorld -> JijIL1ll1LiJjIL1:
    int id -> do
    int data -> if
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.chunk.blockdata.BlockData bdata -> do
    nidefawl.qubes.biome.Biome biome -> do
    47:50:int getType(int,int,int) -> if
    60:60:boolean is(int,int,int) -> do
    80:82:int getData(int,int,int) -> do
    87:90:boolean isNormalBlock(int,int,int,int) -> do
    100:100:int getLight(int,int,int) -> int
    105:105:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    129:129:int getBiomeFaceColor$e764ff2(int,int,int,int,int,int) -> do
    134:134:int getWater(int,int,int) -> for
nidefawl.qubes.util.Stats -> iJ1LiJ1LiJjIll1L:
    int fpsCounter -> do
    int uniformCalls -> if
    float avgFrameTime -> do
    double timeMeshing -> do
    double timeRendering -> if
    double fpsInteval -> for
    int regionUpdates -> for
    int tessDrawCalls -> int
    int modelDrawCalls -> new
    int regionDrawCalls -> try
    int lastFrameDrawCalls -> byte
    int uploadBytes -> case
    19:24:void resetDrawCalls() -> do
nidefawl.qubes.util.SysInfo -> JijIiJIjllL1L1jI:
    java.lang.String osName -> if
    boolean isWindows -> do
    boolean is64Bit -> if
    java.lang.String openGLVersion -> do
nidefawl.qubes.util.Timer -> llL1iJIjiJL1IjIj:
    int tickspersec -> if
    long ms -> if
    long ns -> for
    long last -> int
    int ticks -> do
    float partialTick -> do
    long el -> new
    long absTime -> do
    25:83:long getTime() -> do
    87:93:void calculate() -> do
nidefawl.qubes.util.UnsafeHelper -> llIj1LjIIjJiIjjI:
    long ADDRESS -> do
    long CAPACITY -> if
    sun.misc.Unsafe UNSAFE -> do
    java.nio.ByteBuffer BYTE_BUFFER -> do
    java.nio.ShortBuffer SHORT_BUFFER -> do
    java.nio.CharBuffer CHAR_BUFFER -> do
    java.nio.IntBuffer INT_BUFFER -> do
    java.nio.LongBuffer LONG_BUFFER -> do
    java.nio.FloatBuffer FLOAT_BUFFER -> do
    java.nio.DoubleBuffer DOUBLE_BUFFER -> do
    long PARENT_BYTE -> for
    71:98:sun.misc.Unsafe getUnsafeInstance() -> do
    102:125:java.lang.reflect.Field getField(java.nio.Buffer,java.lang.Object) -> do
    131:143:java.lang.reflect.Field getDeclaredField(java.lang.Class,java.lang.String) -> do
    154:158:java.nio.ByteBuffer memByteBuffer(long,int) -> do
    162:162:long memAddress0(java.nio.Buffer) -> do
nidefawl.qubes.vec.AABB -> JijI1LJiIjJiIjiJ:
    double minX -> do
    double minY -> if
    double minZ -> for
    double maxX -> int
    double maxY -> new
    double maxZ -> try
    33:33:double getWidth() -> do
    39:39:double getLength() -> if
    43:49:void offset(double,double,double) -> do
    52:64:void expandTo(double,double,double) -> if
    77:83:void set(double,double,double,double,double,double) -> do
    88:89:void set(nidefawl.qubes.vec.AABB) -> do
    97:97:double getCenterX() -> for
    105:105:double getCenterZ() -> int
    126:142:double getXOffset(nidefawl.qubes.vec.AABB,double) -> do
    146:162:double getZOffset(nidefawl.qubes.vec.AABB,double) -> if
    166:182:double getYOffset(nidefawl.qubes.vec.AABB,double) -> for
    187:187:java.lang.String toString() -> toString
    192:198:void read(java.io.DataInput) -> do
    202:208:void write(java.io.DataOutput) -> do
nidefawl.qubes.vec.AABBFloat -> lllliJ1LL1iJjIiJ:
    float minX -> do
    float minY -> if
    float minZ -> for
    float maxX -> int
    float maxY -> new
    float maxZ -> try
    long negativeZeroFloatBits -> do
    35:41:void offset(float,float,float) -> do
    69:75:void set(float,float,float,float,float,float) -> do
    80:81:void set(nidefawl.qubes.vec.AABBFloat) -> do
    128:128:java.lang.String toString() -> toString
    144:195:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    200:205:boolean min(float,float) -> do
    208:213:boolean max(float,float) -> if
nidefawl.qubes.vec.AABBInt -> iJJi1LL1JiiJ1LL1:
    int minX -> do
    int minY -> if
    int minZ -> for
    int maxX -> int
    int maxY -> new
    int maxZ -> try
    115:115:java.lang.String toString() -> toString
nidefawl.qubes.vec.BlockBoundingBox -> Ji1LJillL1L11Lll:
    int lowX -> do
    int highX -> if
    int lowY -> for
    int highY -> int
    int lowZ -> new
    int highZ -> try
    67:73:void set(int,int,int,int,int,int) -> do
    132:132:java.lang.String toString() -> toString
nidefawl.qubes.vec.BlockPos -> ll1LiJJi1LiJ:
    int x -> do
    int y -> if
    int z -> for
    24:24:java.lang.String toString() -> toString
    29:33:boolean equals(java.lang.Object) -> equals
    38:38:int hashCode() -> hashCode
    42:42:nidefawl.qubes.vec.BlockPos copy() -> do
    50:53:void set(int,int,int) -> do
    58:61:void offset(int) -> do
    64:67:void read(java.io.DataInput) -> do
    70:73:void write(java.io.DataOutput) -> do
    78:81:void set(nidefawl.qubes.vec.BlockPos) -> do
nidefawl.qubes.vec.Frustum -> L1ll1L1LL1L1L11L:
    nidefawl.qubes.vec.Vector4f[] frustum -> do
    nidefawl.qubes.vec.Vector3f up -> do
    nidefawl.qubes.vec.Vector3f forward -> if
    nidefawl.qubes.vec.Vector3f cam -> for
    nidefawl.qubes.vec.Vector3f X -> int
    nidefawl.qubes.vec.Vector3f Y -> new
    nidefawl.qubes.vec.Vector3f Z -> try
    float znear -> do
    float zfar -> if
    float ratio -> for
    float tang -> int
    float angle -> new
    float sphereFactorY -> try
    float sphereFactorX -> byte
    81:111:void set(nidefawl.qubes.vec.Matrix4f) -> do
    124:124:float planeDistance(nidefawl.qubes.vec.Vector4f,float,float,float) -> do
    246:246:int checkFrustum$6a205da3(nidefawl.qubes.vec.AABBInt) -> do
nidefawl.qubes.vec.Matrix4f -> iJjIll1LL11LL1Ji:
    float m00 -> do
    float m01 -> if
    float m02 -> for
    float m03 -> int
    float m10 -> new
    float m11 -> try
    float m12 -> byte
    float m13 -> case
    float m20 -> char
    float m21 -> else
    float m22 -> goto
    float m23 -> long
    float m30 -> this
    float m31 -> void
    float m32 -> break
    float m33 -> catch
    51:56:java.lang.String toString() -> toString
    64:64:nidefawl.qubes.vec.Matrix4f setIdentity() -> do
    98:98:nidefawl.qubes.vec.Matrix4f setZero() -> if
    133:133:nidefawl.qubes.vec.Matrix4f load(nidefawl.qubes.vec.Matrix4f) -> do
    198:216:nidefawl.qubes.vec.Matrix4f load(float[]) -> do
    254:270:nidefawl.qubes.vec.Matrix4f store(java.nio.FloatBuffer) -> do
    415:452:nidefawl.qubes.vec.Matrix4f mul(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    489:502:nidefawl.qubes.vec.Vector3f transform(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    559:559:nidefawl.qubes.vec.Matrix4f transpose() -> for
    568:568:nidefawl.qubes.vec.Matrix4f translate(float,float,float) -> do
    586:586:nidefawl.qubes.vec.Matrix4f scale(nidefawl.qubes.vec.Vector3f) -> do
    598:610:nidefawl.qubes.vec.Matrix4f scale(float,float,float) -> if
    645:645:nidefawl.qubes.vec.Matrix4f rotate(float,float,float,float) -> do
    779:779:nidefawl.qubes.vec.Matrix4f translate(float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    817:853:nidefawl.qubes.vec.Matrix4f transpose(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    893:893:float determinant3x3(float,float,float,float,float,float,float,float,float) -> do
    958:1011:nidefawl.qubes.vec.Matrix4f invert(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> if
    1072:1120:void mulMat(nidefawl.qubes.vec.Matrix4f) -> do
    1204:1220:void addWeighted(nidefawl.qubes.vec.Matrix4f,float) -> do
    1290:1297:void clearTranslation() -> int
nidefawl.qubes.vec.Quaternion -> llJijIiJllJiJi1L:
    float x -> do
    float y -> if
    float z -> for
    float w -> int
    298:298:java.lang.String toString() -> toString
nidefawl.qubes.vec.StackChangeCallBack -> iJjIiJIjL1llJiIj:
    218:220:void onChange(nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.vec.TransformStack -> jI1L1LL1llJijIJi:
    nidefawl.qubes.vec.Vector3f[] stack -> do
    int stackSize -> do
    nidefawl.qubes.vec.Vector3f tmp -> do
    nidefawl.qubes.vec.StackChangeCallBack cb -> do
    24:34:void translate(float,float,float) -> do
    36:40:void push() -> do
    42:47:void push(float,float,float) -> if
    49:54:void pop() -> if
    56:60:nidefawl.qubes.vec.Vector3f get() -> do
    79:81:void setScissors(int,int,int,int) -> do
nidefawl.qubes.vec.Vec3D -> JillL11LjIIjL1jI:
    double x -> do
    double y -> if
    double z -> for
    28:31:void set(nidefawl.qubes.vec.Vec3D) -> do
    39:42:void set(double,double,double) -> do
    143:152:java.lang.String toString() -> toString
    205:208:double distanceSq(nidefawl.qubes.vec.Vec3D) -> do
nidefawl.qubes.vec.Vector3f -> L1L1IjL1iJiJiJ1L:
    nidefawl.qubes.vec.Vector3f ZERO -> do
    float x -> do
    float y -> if
    float z -> for
    56:57:void set(nidefawl.qubes.vec.Vector3f) -> do
    63:66:void set(float,float,float) -> do
    103:107:nidefawl.qubes.vec.Vector3f add(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    123:127:nidefawl.qubes.vec.Vector3f sub(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> if
    144:149:nidefawl.qubes.vec.Vector3f cross(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> for
    208:208:float dot(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    244:248:nidefawl.qubes.vec.Vector3f scale(float) -> do
    257:261:nidefawl.qubes.vec.Vector3f store(java.nio.FloatBuffer) -> do
    268:277:java.lang.String toString() -> toString
    332:332:float length() -> do
    341:346:nidefawl.qubes.vec.Vector3f normalise() -> do
    373:376:void addVec(nidefawl.qubes.vec.Vector3f) -> if
    385:388:float distanceSq(float,float,float) -> do
    392:395:void write(java.io.DataOutput) -> do
    398:401:void read(java.io.DataInput) -> do
    418:423:void interp(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,float,nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.vec.Vector4f -> L1iJ1L1LllL11LL1:
    float x -> do
    float y -> if
    float z -> for
    float w -> int
    239:239:java.lang.String toString() -> toString
nidefawl.qubes.world.IBlockWorld -> iJJiJilliJiJiJL1:
    int getType(int,int,int) -> if
    int getData(int,int,int) -> do
    boolean isNormalBlock(int,int,int,int) -> do
    int getLight(int,int,int) -> int
    nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    int getBiomeFaceColor$e764ff2(int,int,int,int,int,int) -> do
    int getWater(int,int,int) -> for
nidefawl.qubes.world.IWorldSettings -> JiIjiJIjlliJJill:
    long getSeed() -> do
    long getTime() -> if
    int getId() -> do
    java.lang.String getName() -> do
    long getDayLen() -> for
    boolean isFixedTime() -> do
    void setTime(long) -> do
    void setDayLen(long) -> if
    void setFixedTime(boolean) -> do
nidefawl.qubes.world.SunLightModel -> iJL1llL1jI1LL1iJ:
nidefawl.qubes.world.World -> jI1LjIllJiJiJi:
    java.util.ArrayList lights -> do
    int worldHeight -> do
    int worldHeightBits -> if
    long seed -> do
    nidefawl.qubes.chunk.ChunkManager chunkMgr -> do
    java.util.Random rand -> do
    int id -> for
    nidefawl.qubes.world.IWorldSettings settings -> do
    nidefawl.qubes.biomes.IBiomeManager biomeManager -> do
    java.lang.String name -> do
    nidefawl.qubes.chunk.ChunkManager makeChunkManager() -> do
    101:101:int getType(nidefawl.qubes.vec.BlockPos) -> do
    115:123:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    127:135:int getType(int,int,int) -> if
    139:147:int getWater(int,int,int) -> for
    151:159:int getData(int,int,int) -> do
    void flagBlock(int,int,int) -> do
    258:258:nidefawl.qubes.chunk.Chunk getChunk(int,int) -> do
    272:282:void addLight(nidefawl.qubes.vec.Vector3f) -> do
    392:395:int getLight(int,int,int) -> int
    425:428:boolean isNormalBlock(int,int,int,int) -> do
    java.util.List getEntityList() -> do
    441:441:int getBiomeFaceColor$e764ff2(int,int,int,int,int,int) -> do
nidefawl.qubes.world.WorldClient -> L1iJL1IjllIjllL1:
    float dayLightIntensity -> do
    float nightNoon -> if
    float dayNoon -> for
    float lightAngleUp -> int
    nidefawl.qubes.vec.Matrix4f sunModelView -> do
    nidefawl.qubes.vec.Matrix4f moonModelView -> if
    nidefawl.qubes.vec.Vector3f sunPosition -> do
    nidefawl.qubes.vec.Vector3f moonPosition -> if
    nidefawl.qubes.vec.Vector3f lightPosition -> for
    nidefawl.qubes.vec.Vector3f lightDirection -> int
    nidefawl.qubes.vec.Vector3f tmp1 -> new
    java.util.HashMap entities -> do
    java.util.ArrayList entityList -> if
    java.util.ArrayList entityRemove -> for
    66:66:nidefawl.qubes.chunk.ChunkManager makeChunkManager() -> do
    123:124:void flagBlock(int,int,int) -> do
    160:167:boolean addEntity(nidefawl.qubes.entity.Entity) -> do
    171:177:boolean removeEntity(nidefawl.qubes.entity.Entity) -> if
    182:182:nidefawl.qubes.entity.Entity getEntity(int) -> do
    186:186:java.util.List getEntityList() -> do
nidefawl.qubes.world.WorldSettingsClient -> L1IjIjllL1iJIjiJ:
    java.util.UUID uuid -> do
    long seed -> do
    long time -> if
    int id -> do
    java.lang.String worldName -> do
    long dayLen -> for
    boolean isFixedTime -> do
    21:28:void read(java.io.DataInput) -> do
    32:32:void write(java.io.DataOutput) -> do
    41:41:long getSeed() -> do
    51:51:long getTime() -> if
    56:56:int getId() -> do
    61:61:java.lang.String getName() -> do
    66:66:long getDayLen() -> for
    71:71:boolean isFixedTime() -> do
    76:77:void setTime(long) -> do
    81:82:void setFixedTime(boolean) -> do
    86:87:void setDayLen(long) -> if
