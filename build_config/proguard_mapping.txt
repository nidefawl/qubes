nidefawl.qubes.BootClient -> nidefawl.qubes.BootClient:
    int appId -> appId
    11:11:void <init>() -> <init>
    16:48:void main(java.lang.String[]) -> main
    51:68:nidefawl.qubes.GameBase getInstance() -> getInstance
    12:12:void <clinit>() -> <clinit>
nidefawl.qubes.Game -> Ij1LIjL1jIL1iJIj:
    nidefawl.qubes.Game instance -> do
    java.lang.String buildIdentifier -> do
    nidefawl.qubes.PlayerProfile profile -> do
    nidefawl.qubes.config.ClientSettings settings -> do
    nidefawl.qubes.gui.GuiOverlayStats statsOverlay -> do
    nidefawl.qubes.gui.GuiCached statsCached -> do
    nidefawl.qubes.gui.GuiOverlayChat chatOverlay -> do
    nidefawl.qubes.network.client.ThreadConnect connect -> do
    nidefawl.qubes.network.client.NetworkClient client -> do
    nidefawl.qubes.world.WorldClient world -> do
    nidefawl.qubes.entity.PlayerSelf player -> do
    nidefawl.qubes.input.CameraController cameraController -> do
    nidefawl.qubes.input.WorldPlayerController worldPlayerController -> do
    nidefawl.qubes.input.DigController dig -> do
    nidefawl.qubes.input.Selection leftSelection -> do
    nidefawl.qubes.input.Selection rightSelection -> if
    nidefawl.qubes.gl.PositionMouseOver rightMouseOver -> do
    nidefawl.qubes.gl.PositionMouseOver leftMouseOver -> if
    boolean follow -> do
    nidefawl.qubes.item.BlockStack selBlock -> do
    long lastShaderLoadTime -> do
    nidefawl.qubes.vec.Vector3f vCam -> do
    nidefawl.qubes.vec.Vector3f vPlayer -> if
    nidefawl.qubes.vec.Vector3f vLastCam -> for
    nidefawl.qubes.vec.Vector3f vLastPlayer -> int
    float lastTpDistance -> do
    boolean updateRenderers -> if
    boolean showGrid -> for
    boolean thirdPerson -> int
    boolean testMode -> new
    java.lang.String serverAddr -> if
    int throttleClick -> do
    boolean showControllers -> try
    nidefawl.qubes.server.LocalGameServer server -> do
    nidefawl.qubes.render.gui.VRGuiRenderer vrGui -> do
    nidefawl.qubes.vec.Vector3f tmp -> new
    nidefawl.qubes.util.RayTrace rayTrace -> do
    nidefawl.qubes.input.GameMode mode -> do
    129:129:nidefawl.qubes.input.GameMode getMode() -> do
    133:139:void connectTo(java.lang.String) -> do
    142:149:void connectTo(java.lang.String,int,boolean) -> do
    69:156:void <init>() -> <init>
    160:196:void initGame() -> initGame
    199:199:java.lang.String getAppTitle() -> getAppTitle
    204:263:void lateInitGame() -> lateInitGame
    266:277:void toggleGameMode() -> do
    297:309:void setWorld(nidefawl.qubes.world.WorldClient) -> do
    311:330:void updateGui3dMode() -> updateGui3dMode
    334:338:void shutdown() -> shutdown
    345:359:void onTextInput(long,int) -> onTextInput
    363:405:void onKeyPress(long,int,int,int,int) -> onKeyPress
    409:448:void onWheelScroll(long,double,double) -> onWheelScroll
    451:487:void onMouseClick(long,int,int,int) -> onMouseClick
    490:498:void setGrabbed(boolean) -> setGrabbed
    501:509:boolean needsGrab() -> needsGrab
    514:674:void render(float) -> render
    677:692:void renderCrossHair(float) -> do
    696:755:void renderChunkGrid(float) -> if
    759:782:void renderGui(float,double,double) -> do
    786:1127:void renderWorld(float,int,nidefawl.qubes.gl.FrameBuffer) -> do
    1130:1159:void render3dGUI(float) -> for
    1163:1193:void onStatsUpdated() -> onStatsUpdated
    1197:1199:void postRenderUpdate(float) -> postRenderUpdate
    1204:1367:void preRenderUpdate(float) -> preRenderUpdate
    1371:1447:void updateCameraFromPlayer(nidefawl.qubes.entity.PlayerSelf,float) -> do
    1450:1450:boolean has3dGUIMouseFocus() -> if
    1453:1456:void onGuiClosed(nidefawl.qubes.gui.Gui,nidefawl.qubes.gui.Gui) -> onGuiClosed
    1459:1462:void onGuiOpened(nidefawl.qubes.gui.Gui,nidefawl.qubes.gui.Gui) -> onGuiOpened
    1467:1486:void onWindowResize(int,int) -> onWindowResize
    1489:1497:void setRenderResolution(int,int) -> setRenderResolution
    1500:1540:void tick() -> tick
    1543:1549:void returnToMenu() -> if
    1552:1552:boolean isConnected() -> do
    1556:1559:void addDebugOnScreen(java.lang.String) -> if
    1562:1562:nidefawl.qubes.world.World getWorld() -> do
    1566:1576:void setConnection(nidefawl.qubes.network.client.NetworkClient) -> do
    1579:1579:nidefawl.qubes.entity.PlayerSelf getPlayer() -> do
    1583:1584:void setPlayer(nidefawl.qubes.entity.PlayerSelf) -> do
    1587:1590:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    1593:1593:nidefawl.qubes.PlayerProfile getProfile() -> do
    1601:1606:void saveSettings() -> for
    1609:1614:void saveProfile() -> int
    1617:1624:void loadProfile() -> new
    1627:1634:void loadSettings() -> try
    1648:1648:nidefawl.qubes.input.Selection getSelection() -> do
    1651:1651:nidefawl.qubes.input.Selection getSelection(int) -> do
    1654:1654:nidefawl.qubes.gl.PositionMouseOver getMouseOver(int) -> do
    1658:1659:nidefawl.qubes.network.client.ClientHandler getClientHandler() -> do
    1662:1662:nidefawl.qubes.input.WorldPlayerController getWPCtrl() -> do
    1666:1683:void parseCmdArgs(java.lang.String[]) -> parseCmdArgs
    1687:1713:void onControllerButton(int,int,int) -> onControllerButton
    1716:1743:void processChatInput(java.lang.String) -> for
    1747:1747:boolean canRenderGui3d() -> canRenderGui3d
    67:117:void <clinit>() -> <clinit>
nidefawl.qubes.Game$1 -> jI1LJi1LllJi:
    nidefawl.qubes.Game this$0 -> do
    118:118:void <init>(nidefawl.qubes.Game) -> <init>
    120:122:boolean rayTraceBlock(nidefawl.qubes.block.Block) -> do
nidefawl.qubes.Game$2 -> Ij1LL1JiIjIjjI:
    nidefawl.qubes.texture.array.TextureArray val$arr -> do
    nidefawl.qubes.Game this$0 -> do
    221:221:void <init>(nidefawl.qubes.Game,nidefawl.qubes.texture.array.TextureArray) -> <init>
    225:229:void pre() -> pre
    232:233:void post() -> post
    237:241:java.lang.Void call() -> do
    245:245:nidefawl.qubes.async.AsyncTask$TaskType getType() -> getType
    221:221:java.lang.Object call() -> call
nidefawl.qubes.GameBase -> ll1LL1JiiJL1iJL1:
    java.lang.String appName -> appName
    int windowWidth -> windowWidth
    int windowHeight -> windowHeight
    int displayWidth -> displayWidth
    int displayHeight -> displayHeight
    int guiWidth -> guiWidth
    int guiHeight -> guiHeight
    boolean GL_ERROR_CHECKS -> GL_ERROR_CHECKS
    boolean VR_SUPPORT -> VR_SUPPORT
    long windowId -> windowId
    int initWidth -> initWidth
    int initHeight -> initHeight
    int TICKS_PER_SEC -> TICKS_PER_SEC
    org.lwjgl.glfw.GLFWErrorCallback errorCallback -> errorCallback
    org.lwjgl.glfw.GLFWWindowSizeCallback cbWindowSize -> cbWindowSize
    org.lwjgl.glfw.GLFWKeyCallback cbKeyboard -> cbKeyboard
    org.lwjgl.glfw.GLFWMouseButtonCallback cbMouseButton -> cbMouseButton
    org.lwjgl.glfw.GLFWScrollCallback cbScrollCallback -> cbScrollCallback
    org.lwjgl.glfw.GLFWWindowFocusCallback cbWindowFocus -> cbWindowFocus
    org.lwjgl.glfw.GLFWCursorPosCallback cbCursorPos -> cbCursorPos
    org.lwjgl.glfw.GLFWCharCallback cbText -> cbText
    boolean hasTextHook -> hasTextHook
    boolean toggleTiming -> toggleTiming
    boolean DO_TIMING -> DO_TIMING
    float renderTime -> renderTime
    float absTime -> absTime
    int ticksran -> ticksran
    int lastFPS -> lastFPS
    long timeLastFPS -> timeLastFPS
    long timeLastFrame -> timeLastFrame
    nidefawl.qubes.util.Timer timer -> timer
    int tick -> tick
    boolean startRender -> startRender
    nidefawl.qubes.util.GameError showError -> showError
    nidefawl.qubes.logging.LogBufferStream outStream -> outStream
    nidefawl.qubes.logging.LogBufferStream errStream -> errStream
    long frameTime -> frameTime
    boolean vsync -> vsync
    boolean running -> running
    boolean wasrunning -> wasrunning
    boolean sysExit -> sysExit
    boolean minimized -> minimized
    boolean hasWindowFocus -> hasWindowFocus
    boolean useWindowSizeAsRenderResolution -> useWindowSizeAsRenderResolution
    boolean renderGui3d -> renderGui3d
    boolean isStarting -> isStarting
    java.lang.Thread thread -> thread
    int newWidth -> newWidth
    int newHeight -> newHeight
    nidefawl.qubes.gl.GPUVendor vendor -> vendor
    nidefawl.qubes.GameBase baseInstance -> baseInstance
    nidefawl.qubes.gui.LoadingScreen loadingScreen -> loadingScreen
    nidefawl.qubes.input.KeybindManager movement -> movement
    nidefawl.qubes.gui.Gui gui -> gui
    boolean reinittexthook -> reinittexthook
    boolean wasGrabbed -> wasGrabbed
    org.lwjgl.opengl.GLCapabilities caps -> caps
    java.util.ArrayList glProfileResults -> glProfileResults
    int throttleClick -> throttleClick
    boolean needsGrab -> needsGrab
    102:105:void startGame() -> startGame
    70:920:void <init>() -> <init>
    125:125:boolean isRunning() -> isRunning
    129:129:nidefawl.qubes.gl.GPUVendor getVendor() -> getVendor
    135:188:void run() -> run
    191:267:void initCallbacks() -> initCallbacks
    272:351:void initDisplay(boolean) -> initDisplay
    354:354:java.lang.String getAppTitle() -> getAppTitle
    359:369:void destroyContext() -> destroyContext
    372:375:void onDestroy() -> onDestroy
    378:382:void shutdown() -> shutdown
    385:421:void checkResize() -> checkResize
    void onStatsUpdated() -> onStatsUpdated
    426:431:void setVSync(boolean) -> setVSync
    434:434:boolean getVSync() -> getVSync
    438:438:java.lang.Thread getMainThread() -> getMainThread
    442:447:boolean _checkGLError(java.lang.String) -> _checkGLError
    451:471:java.lang.String getGlErrorString(int) -> getGlErrorString
    476:477:void updateDisplay() -> updateDisplay
    480:480:boolean isCloseRequested() -> isCloseRequested
    484:491:void setVSync_impl(boolean) -> setVSync_impl
    494:496:void updateInput() -> updateInput
    499:512:void updateGuiContext() -> updateGuiContext
    515:516:void setTitle(java.lang.String) -> setTitle
    519:532:void limitFpsTo(int) -> limitFpsTo
    535:650:void runFrame() -> runFrame
    653:653:boolean needsGrab() -> needsGrab
    661:721:void mainLoop() -> mainLoop
    724:784:void initGLContext() -> initGLContext
    787:795:void updateTime() -> updateTime
    799:830:void showErrorScreen(java.lang.String,java.util.List,java.lang.Throwable,boolean) -> showErrorScreen
    833:834:void setException(nidefawl.qubes.util.GameError) -> setException
    837:837:long getTime() -> getTime
    841:841:boolean hasTextHook() -> hasTextHook
    844:850:void setTextHook(boolean) -> setTextHook
    void onTextInput(long,int) -> onTextInput
    void onKeyPress(long,int,int,int,int) -> onKeyPress
    void onWheelScroll(long,double,double) -> onWheelScroll
    void render(float) -> render
    void preRenderUpdate(float) -> preRenderUpdate
    void postRenderUpdate(float) -> postRenderUpdate
    void setRenderResolution(int,int) -> setRenderResolution
    868:869:void onWindowResize(int,int) -> onWindowResize
    void tick() -> tick
    void initGame() -> initGame
    void lateInitGame() -> lateInitGame
    879:911:void showGUI(nidefawl.qubes.gui.Gui) -> showGUI
    914:914:void onGuiClosed(nidefawl.qubes.gui.Gui,nidefawl.qubes.gui.Gui) -> onGuiClosed
    917:917:void onGuiOpened(nidefawl.qubes.gui.Gui,nidefawl.qubes.gui.Gui) -> onGuiOpened
    922:963:void onMouseClick(long,int,int,int) -> onMouseClick
    965:970:void setGrabbed(boolean) -> setGrabbed
    973:973:boolean isGrabbed() -> isGrabbed
    977:984:void input(float) -> input
    987:987:nidefawl.qubes.gui.Gui getGui() -> getGui
    991:1007:java.lang.String getValue(java.lang.String[],int,java.lang.String) -> getValue
    1010:1010:void parseCmdArgs(java.lang.String[]) -> parseCmdArgs
    1013:1038:void toggleVR() -> toggleVR
    1041:1041:void updateGui3dMode() -> updateGui3dMode
    1044:1047:void setVRViewport() -> setVRViewport
    1049:1052:void setWindowViewport() -> setWindowViewport
    1054:1057:void setGUIViewport() -> setGUIViewport
    1059:1062:void updateProjection() -> updateProjection
    1065:1065:void onControllerButton(int,int,int) -> onControllerButton
    1068:1068:boolean canRenderGui3d() -> canRenderGui3d
    39:39:int access$002(nidefawl.qubes.GameBase,int) -> access$002
    39:39:int access$102(nidefawl.qubes.GameBase,int) -> access$102
    40:66:void <clinit>() -> <clinit>
nidefawl.qubes.GameBase$1 -> jI1LJi1L1LJiiJll:
    nidefawl.qubes.GameBase this$0 -> do
    192:192:void <init>(nidefawl.qubes.GameBase) -> <init>
    196:198:void invoke(long,int,int) -> invoke
nidefawl.qubes.GameBase$2 -> IjllL1JiJiiJJiJi:
    nidefawl.qubes.GameBase this$0 -> do
    200:200:void <init>(nidefawl.qubes.GameBase) -> <init>
    204:208:void invoke(long,int,int,int,int) -> invoke
nidefawl.qubes.GameBase$3 -> JiL1lljI1Lll1LL1:
    nidefawl.qubes.GameBase this$0 -> do
    210:210:void <init>(nidefawl.qubes.GameBase) -> <init>
    215:219:void invoke(long,int,int,int) -> invoke
nidefawl.qubes.GameBase$4 -> Ij1LIjiJllL11LJi:
    nidefawl.qubes.GameBase this$0 -> do
    221:221:void <init>(nidefawl.qubes.GameBase) -> <init>
    225:231:void invoke(long,double,double) -> invoke
nidefawl.qubes.GameBase$5 -> iJlljI1LiJiJiJJi:
    nidefawl.qubes.GameBase this$0 -> do
    234:234:void <init>(nidefawl.qubes.GameBase) -> <init>
    239:245:void invoke(long,boolean) -> invoke
nidefawl.qubes.GameBase$6 -> iJll1LjIL1IjJiIj:
    nidefawl.qubes.GameBase this$0 -> do
    247:247:void <init>(nidefawl.qubes.GameBase) -> <init>
    251:255:void invoke(long,double,double) -> invoke
nidefawl.qubes.GameBase$7 -> IjJillL1ll1LJiL1:
    nidefawl.qubes.GameBase this$0 -> do
    257:257:void <init>(nidefawl.qubes.GameBase) -> <init>
    261:265:void invoke(long,int) -> invoke
nidefawl.qubes.GameRegistry -> L1JiJiiJ1L1LJiJi:
    java.util.Map terrainGenerators -> do
    java.util.Map terrainPopulators -> if
    36:46:nidefawl.qubes.worldgen.WorldGenInit newGenerator(nidefawl.qubes.world.WorldServer,nidefawl.qubes.world.WorldSettings) -> do
    55:55:java.lang.Class getTerrainGen(java.lang.String) -> do
    63:63:java.lang.Class getTerrainPop(java.lang.String) -> if
    67:72:void registerChunkPopulator(java.lang.String,java.lang.Class) -> do
    74:80:void registerTerrainGenerator(java.lang.String,java.lang.Class) -> if
    27:28:void <clinit>() -> <clinit>
nidefawl.qubes.NativeClassLoader -> nidefawl.qubes.NativeClassLoader:
    nidefawl.qubes.NativeClassLoader instance -> instance
    12:13:void <init>() -> <init>
    byte[] cppLoadClass(java.lang.String) -> cppLoadClass
    byte[] cppLoadResource(java.lang.String) -> cppLoadResource
    19:19:java.lang.Class loadClassRedirect(java.lang.String) -> loadClassRedirect
    24:31:java.lang.Class findClass(java.lang.String) -> findClass
    34:36:byte[] loadGameResource(java.lang.String) -> loadGameResource
    40:46:void setLoader() -> setLoader
    52:52:nidefawl.qubes.NativeClassLoader getInstance() -> getInstance
nidefawl.qubes.NativeInterface -> nidefawl.qubes.NativeInterface:
    nidefawl.qubes.NativeInterface instance -> instance
    boolean isPresent -> isPresent
    16:16:nidefawl.qubes.NativeInterface getInstance() -> getInstance
    20:31:void start(int) -> start
    33:33:boolean isPresent() -> isPresent
    35:36:void <init>() -> <init>
    void gameCrashed(nidefawl.qubes.util.CrashInfo) -> gameCrashed
    void gameAlive() -> gameAlive
    13:14:void <clinit>() -> <clinit>
nidefawl.qubes.PlayerProfile -> JiL1JiiJIjiJiJ1L:
    java.util.UUID uuid -> do
    java.lang.String name -> do
    14:15:void <init>() -> <init>
    22:25:void setDefaults() -> do
    36:37:void setName(java.lang.String) -> do
    43:43:java.lang.String getName() -> do
    48:50:void load() -> if
    54:56:void save() -> for
nidefawl.qubes.assets.Asset -> ll1LIjjIIjL1IjIj:
    nidefawl.qubes.assets.AssetPack pack -> do
    3:3:void <init>() -> <init>
    6:7:void setPack(nidefawl.qubes.assets.AssetPack) -> do
    12:12:nidefawl.qubes.assets.AssetPack getPack() -> do
nidefawl.qubes.assets.AssetBinary -> jIL1Ij1LIjiJIj:
    byte[] data -> do
    java.lang.String name -> do
    12:14:void <init>() -> <init>
    16:18:void <init>(java.lang.String) -> <init>
    21:34:void load(nidefawl.qubes.assets.AssetInputStream) -> do
    36:36:byte[] getData() -> do
    43:43:java.lang.String getName() -> do
nidefawl.qubes.assets.AssetInputStream -> jI1LiJlliJ1LiJjI:
    nidefawl.qubes.assets.AssetPack source -> do
    java.io.InputStream inputStream -> do
    19:22:void <init>(nidefawl.qubes.assets.AssetPack,java.io.InputStream) -> <init>
    30:32:void close() -> do
nidefawl.qubes.assets.AssetManager -> JiIjjIiJL1jIiJiJ:
    nidefawl.qubes.assets.AssetManager instance -> do
    java.util.ArrayList assetPacks -> do
    java.io.File folder -> do
    13:13:nidefawl.qubes.assets.AssetManager getInstance() -> do
    15:20:void <init>() -> <init>
    22:28:void init() -> do
    void _init() -> if
    void toggleExternalResources() -> for
    boolean isExternalResources() -> do
    nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String) -> do
    nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,java.lang.String,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    47:48:java.io.InputStream getInputStream(java.lang.String) -> do
    52:71:nidefawl.qubes.assets.AssetBinary loadBin(java.lang.String) -> do
    83:105:nidefawl.qubes.assets.AssetInputStream findResource(java.lang.String,boolean) -> do
    135:135:nidefawl.qubes.assets.AssetTexture loadPNGAsset(java.lang.String) -> do
    138:162:nidefawl.qubes.assets.AssetTexture loadPNGAsset(java.lang.String,boolean) -> do
nidefawl.qubes.assets.AssetManagerClient -> IjIjJiJiiJjIjIJi:
    nidefawl.qubes.shader.ShaderSource lastFailedShader -> do
    boolean externalResources -> do
    11:14:void <init>() -> <init>
    18:20:void toggleExternalResources() -> for
    23:23:boolean isExternalResources() -> do
    51:51:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String) -> do
    55:55:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    61:69:java.lang.String[] splitPath(java.lang.String) -> do
    73:107:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,java.lang.String,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    117:149:void _init() -> if
nidefawl.qubes.assets.AssetManagerServer -> IjIjjIJiL1iJ1LJi:
    11:11:void <init>() -> <init>
    15:15:void toggleExternalResources() -> for
    19:19:boolean isExternalResources() -> do
    29:29:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String) -> do
    34:34:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    44:50:void _init() -> if
    54:54:nidefawl.qubes.shader.Shader loadShader(nidefawl.qubes.util.IResourceManager,java.lang.String,java.lang.String,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
nidefawl.qubes.assets.AssetPack -> iJiJ1LllL1L1jI1L:
    13:13:void <init>() -> <init>
    nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
nidefawl.qubes.assets.AssetPackClassPath -> lliJiJJiJill1L1L:
    17:18:void <init>() -> <init>
    22:25:nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
    33:33:java.lang.String toString() -> toString
nidefawl.qubes.assets.AssetPackFolder -> iJIjiJiJlliJ:
    java.io.File directory -> do
    20:22:void <init>(java.io.File) -> <init>
    27:33:nidefawl.qubes.assets.AssetInputStream getInputStream(java.lang.String) -> do
    38:38:java.lang.String toString() -> toString
nidefawl.qubes.assets.AssetTexture -> L1llJi1LJiL1jIiJ:
    int width -> if
    int height -> for
    byte[] data -> do
    int slot -> do
    java.lang.String name -> do
    int bits -> int
    int colorComps -> new
    short[] shortData -> do
    19:27:void <init>() -> <init>
    19:31:void <init>(java.lang.String) -> <init>
    33:61:boolean loadImageIO(nidefawl.qubes.assets.AssetInputStream) -> do
    66:85:boolean loadPNGDecoder(nidefawl.qubes.assets.AssetInputStream) -> if
    88:88:int getBits() -> do
    91:91:int getComponents() -> if
    94:94:int getWidth() -> for
    97:97:int getHeight() -> int
    100:100:byte[] getData() -> do
    107:129:void rescale(int) -> do
    135:146:void cutH() -> do
    149:150:void setSlot(int) -> if
    153:153:int getSlot() -> new
    160:160:java.lang.String getName() -> do
    171:171:short[] getUShortData() -> do
nidefawl.qubes.async.AsyncTask -> L1Ij1LIjJijIjI1L:
    java.util.concurrent.Future future -> future
    6:6:void <init>() -> <init>
    nidefawl.qubes.async.AsyncTask$TaskType getType() -> getType
    16:16:void pre() -> pre
    19:19:void post() -> post
    21:22:void setFuture(java.util.concurrent.Future) -> setFuture
    24:24:boolean isDone() -> isDone
    27:27:boolean isCancelled() -> isCancelled
nidefawl.qubes.async.AsyncTask$TaskType -> iJIjiJllll1LlliJ:
    nidefawl.qubes.async.AsyncTask$TaskType CHUNK_DECOMPRESS -> do
    nidefawl.qubes.async.AsyncTask$TaskType LOAD_TEXTURES -> if
    nidefawl.qubes.async.AsyncTask$TaskType[] $VALUES -> do
    9:9:nidefawl.qubes.async.AsyncTask$TaskType[] values() -> values
    9:9:nidefawl.qubes.async.AsyncTask$TaskType valueOf(java.lang.String) -> valueOf
    9:9:void <init>(java.lang.String,int) -> <init>
    9:10:void <clinit>() -> <clinit>
nidefawl.qubes.async.AsyncTaskThread -> Ij1L1LL1JillIjJi:
    java.util.zip.Inflater inflate -> do
    int i10Meg -> do
    byte[] tmpBuffer -> do
    8:16:void <init>(java.lang.Runnable) -> <init>
    18:28:byte[] inflate(byte[]) -> do
nidefawl.qubes.async.AsyncTasks -> JiJillL1llIjL1jI:
    java.util.ArrayList tasks -> do
    java.util.concurrent.ExecutorService service -> do
    15:33:void init() -> do
    36:50:void submit(nidefawl.qubes.async.AsyncTask) -> do
    52:72:boolean completeTasks() -> do
    75:79:void shutdown() -> if
    12:12:void <clinit>() -> <clinit>
nidefawl.qubes.async.AsyncTasks$1 -> iJ1LiJlljIllIj:
    26:26:void <init>() -> <init>
    29:29:java.lang.Thread newThread(java.lang.Runnable) -> newThread
nidefawl.qubes.async.AsyncTasks$2 -> JiIjL1IjiJJi1L1L:
    21:21:void <init>() -> <init>
    24:25:void uncaughtException(java.lang.Thread,java.lang.Throwable) -> uncaughtException
nidefawl.qubes.biome.Biome -> JiJiJiJiL11LJi1L:
    nidefawl.qubes.biome.Biome[] biomes -> do
    int maxBiome -> do
    nidefawl.qubes.biome.Biome MEADOW_GREEN -> do
    nidefawl.qubes.biome.Biome MEADOW_BLUE -> if
    nidefawl.qubes.biome.Biome MEADOW_RED -> for
    nidefawl.qubes.biome.Biome DESERT -> int
    nidefawl.qubes.biome.Biome DESERT_RED -> new
    nidefawl.qubes.biome.Biome ICE -> try
    nidefawl.qubes.biome.Biome MEADOW_GREEN2 -> byte
    int color -> if
    int colorFoliage -> for
    int colorFoliage2 -> int
    int colorLeaves -> new
    int colorGrass -> try
    int id -> byte
    72:81:void <init>(int) -> <init>
    83:99:nidefawl.qubes.biome.Biome setColor(nidefawl.qubes.biome.BiomeColor,int) -> do
    107:108:nidefawl.qubes.biome.Biome setDebugColor(int) -> do
    116:121:nidefawl.qubes.biome.Biome get(int) -> if
    129:145:int getFaceColor(nidefawl.qubes.biome.BiomeColor) -> do
    150:173:int getStone(nidefawl.qubes.world.WorldServer,int,int,int,nidefawl.qubes.world.biomes.HexBiome,java.util.Random) -> do
    177:177:int getOre(nidefawl.qubes.world.WorldServer,int,int,int,nidefawl.qubes.world.biomes.HexBiome,java.util.Random) -> if
    204:204:nidefawl.qubes.block.Block getStone() -> do
    207:207:nidefawl.qubes.block.Block getTopBlock() -> if
    210:210:nidefawl.qubes.block.Block getSoilBlock() -> for
    19:62:void <clinit>() -> <clinit>
nidefawl.qubes.biome.Biome$1 -> L1IjjIL1jI1LL1L1:
    int[] $SwitchMap$nidefawl$qubes$biome$BiomeColor -> do
    83:83:void <clinit>() -> <clinit>
nidefawl.qubes.biome.BiomeColor -> lllljIJiL1iJIjIj:
    nidefawl.qubes.biome.BiomeColor GRASS -> do
    nidefawl.qubes.biome.BiomeColor LEAVES -> if
    nidefawl.qubes.biome.BiomeColor FOLIAGE -> for
    nidefawl.qubes.biome.BiomeColor FOLIAGE2 -> int
    nidefawl.qubes.biome.BiomeColor[] $VALUES -> do
    10:10:nidefawl.qubes.biome.BiomeColor[] values() -> values
    10:10:nidefawl.qubes.biome.BiomeColor valueOf(java.lang.String) -> valueOf
    10:10:void <init>(java.lang.String,int) -> <init>
    10:12:void <clinit>() -> <clinit>
nidefawl.qubes.biome.BiomeDesert -> IjjIL1jIJijIJijI:
    14:18:void <init>(int) -> <init>
    22:22:nidefawl.qubes.block.Block getStone() -> do
    25:25:nidefawl.qubes.block.Block getTopBlock() -> if
    28:28:nidefawl.qubes.block.Block getSoilBlock() -> for
nidefawl.qubes.biome.BiomeDesertRed -> Ji1LjIL1JiiJjI1L:
    14:18:void <init>(int) -> <init>
    22:22:nidefawl.qubes.block.Block getStone() -> do
    25:25:nidefawl.qubes.block.Block getTopBlock() -> if
    28:28:nidefawl.qubes.block.Block getSoilBlock() -> for
nidefawl.qubes.biome.BiomeIce -> Ijll1L1LjIL1Jill:
    14:15:void <init>(int) -> <init>
    20:20:nidefawl.qubes.block.Block getStone() -> do
    24:24:nidefawl.qubes.block.Block getTopBlock() -> if
    28:28:nidefawl.qubes.block.Block getSoilBlock() -> for
nidefawl.qubes.biome.BiomeMeadow -> jIllIjjIJiiJJiIj:
    12:13:void <init>(int) -> <init>
nidefawl.qubes.block.Block -> iJL1llIj1LJi1LIj:
    nidefawl.qubes.block.Block[] registeredblocks -> if
    short[] registeredblockIds -> do
    nidefawl.qubes.block.Block[] block -> do
    java.lang.String[] NO_TEXTURES -> do
    nidefawl.qubes.block.Block air -> do
    nidefawl.qubes.block.Block grass -> if
    nidefawl.qubes.block.Block dirt -> for
    nidefawl.qubes.block.BlockGroupStones stones -> do
    nidefawl.qubes.block.Block water -> int
    nidefawl.qubes.block.Block sand -> new
    nidefawl.qubes.block.Block sand_red -> try
    nidefawl.qubes.block.Block snow -> byte
    nidefawl.qubes.block.Block ice -> case
    nidefawl.qubes.block.Block gravel -> char
    nidefawl.qubes.block.BlockGroupLogs logs -> do
    nidefawl.qubes.block.BlockGroup wood -> do
    nidefawl.qubes.block.BlockGroupLeaves leaves -> do
    nidefawl.qubes.block.Block grassbush -> else
    nidefawl.qubes.block.Block heath -> goto
    nidefawl.qubes.block.Block aloe_vera -> long
    nidefawl.qubes.block.Block nasturtium -> this
    nidefawl.qubes.block.Block thingrass -> void
    nidefawl.qubes.block.Block vines -> break
    nidefawl.qubes.block.Block treemoss -> catch
    nidefawl.qubes.block.Block quarter -> class
    nidefawl.qubes.block.BlockGroupOres ores -> do
    nidefawl.qubes.block.BlockGroup bricks -> if
    nidefawl.qubes.block.BlockGroup stonebricks -> for
    nidefawl.qubes.block.BlockGroup smoothstones -> int
    nidefawl.qubes.block.BlockGroup stonepath -> new
    nidefawl.qubes.block.BlockGroup cobblestones -> try
    nidefawl.qubes.block.BlockGroup slabs -> byte
    nidefawl.qubes.block.BlockGroup stairs -> case
    nidefawl.qubes.block.BlockGroup walls -> char
    nidefawl.qubes.block.BlockGroup fences -> else
    nidefawl.qubes.block.BlockGroup parquets -> goto
    nidefawl.qubes.block.Block flower_fmn_black -> const
    nidefawl.qubes.block.Block flower_fmn_blue -> final
    nidefawl.qubes.block.Block flower_compositae_camille -> float
    nidefawl.qubes.block.Block flower_compositae_milkspice -> short
    nidefawl.qubes.block.Block flower_compositae_pinkpanther -> super
    nidefawl.qubes.block.Block flower_compositae_tigerteeth -> throw
    nidefawl.qubes.block.Block flower_violet -> while
    nidefawl.qubes.block.Block flower_rose -> double
    nidefawl.qubes.block.Block flower_poppy1 -> import
    nidefawl.qubes.block.Block flower_poppy2 -> native
    nidefawl.qubes.block.Block flower_poppy3 -> public
    nidefawl.qubes.block.Block flower_oxmorina_blue -> return
    nidefawl.qubes.block.Block flower_cup_0 -> static
    nidefawl.qubes.block.Block flower_cup_1 -> switch
    nidefawl.qubes.block.Block flower_cup_2 -> throws
    nidefawl.qubes.block.Block flower_cup_3 -> boolean
    nidefawl.qubes.block.Block flower_cup_4 -> default
    nidefawl.qubes.block.Block flower_cup_5 -> extends
    nidefawl.qubes.block.Block flower_cup_6 -> finally
    nidefawl.qubes.block.Block flower_cup_7 -> package
    nidefawl.qubes.block.Block flower_star_frost -> private
    nidefawl.qubes.block.Block flower_star_sundown -> abstract
    nidefawl.qubes.block.Block flower_dandelion -> continue
    nidefawl.qubes.block.Block flower_lotus -> strictfp
    nidefawl.qubes.block.Block flower_lavender -> volatile
    nidefawl.qubes.block.Block flower_tulip1 -> interface
    nidefawl.qubes.block.Block flower_tulip2 -> protected
    nidefawl.qubes.block.Block flower_tulip3 -> transient
    nidefawl.qubes.block.Block flower_tulip4 -> implements
    nidefawl.qubes.block.Block flower_tulip5 -> instanceof
    nidefawl.qubes.block.Block flower_tulip6 -> synchronized
    nidefawl.qubes.block.Block flower_nomades -> ZssZSS2zz2SSZssZ
    nidefawl.qubes.block.Block flower_sheeps_meal -> z22zZsSSSS2zZsSS
    nidefawl.qubes.block.Block rhubarb -> Zsz22z2z2zZsZs
    nidefawl.qubes.block.Block fern1 -> sZz2SSZssZz2z2z2
    nidefawl.qubes.block.Block fern2 -> SSZsZs2zsZsZ2zsZ
    nidefawl.qubes.block.Block fern3 -> z2ZsZs2zZsZs2zsZ
    nidefawl.qubes.block.Block fern4 -> ZssZZsz2sZsZ2zz2
    nidefawl.qubes.block.Block double_heath -> sZSSZsZsz2ZsZssZ
    nidefawl.qubes.block.Block tallgrass1 -> SSZsz2ZssZsZz2
    nidefawl.qubes.block.Block tallgrass2 -> z2z22zSSZs2z2z2z
    nidefawl.qubes.block.Block cattail -> sZZsZsZsSSsZ
    nidefawl.qubes.block.Block waterlily -> sZ2zsZSSZssZsZ2z
    nidefawl.qubes.block.Block pad -> Zs2z2zSSz2Zsz2
    nidefawl.qubes.block.BlockGroup modelled -> long
    nidefawl.qubes.block.Block torch -> z2SS2zsZSSZs
    int id -> do
    java.lang.String name -> do
    boolean transparent -> do
    java.lang.String[] textures -> if
    java.lang.String[] normalMaps -> for
    nidefawl.qubes.vec.AABBFloat blockBounds -> do
    nidefawl.qubes.block.BlockTextureMode textureMode -> do
    nidefawl.qubes.block.BlockCategory blockCategory -> do
    nidefawl.qubes.models.qmodel.ModelBlock[] loadedModels -> do
    java.lang.String[] models -> int
    nidefawl.qubes.block.BlockGroup blockGroup -> this
    141:141:void preInit() -> do
    143:166:void postInit() -> if
    172:189:void <init>(java.lang.String,boolean) -> <init>
    195:196:nidefawl.qubes.block.Block setBlockGroup(nidefawl.qubes.block.BlockGroup) -> do
    200:201:nidefawl.qubes.block.Block setCategory(nidefawl.qubes.block.BlockCategory) -> do
    204:204:nidefawl.qubes.block.BlockCategory getBlockCategory() -> do
    208:208:void init() -> for
    210:211:void <init>(java.lang.String) -> <init>
    218:218:java.lang.String[] getTextures() -> do
    221:221:java.lang.String[] getNormalMaps() -> if
    225:229:nidefawl.qubes.block.Block setTextures(java.lang.String[]) -> do
    232:236:nidefawl.qubes.block.Block setNormalMaps(java.lang.String[]) -> if
    240:241:nidefawl.qubes.block.Block setModels(java.lang.String[]) -> for
    244:244:java.lang.String[] getModels() -> for
    253:253:java.lang.String getName() -> do
    257:257:boolean isTransparent() -> do
    260:260:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    263:264:nidefawl.qubes.block.Block setTextureMode(nidefawl.qubes.block.BlockTextureMode) -> do
    267:267:int getTexturePasses() -> do
    285:296:int getTexture(int,int,int) -> do
    299:299:int getLODPass() -> if
    302:302:int getRenderPass() -> for
    305:305:int getRenderType() -> int
    308:308:boolean isValid(int) -> do
    311:311:nidefawl.qubes.block.Block get(int) -> do
    314:314:boolean applyAO() -> if
    317:317:boolean isOccluding() -> for
    321:324:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    327:327:float getAlpha() -> do
    330:330:int getLightValue() -> new
    333:333:boolean isOpaque(int) -> if
    337:338:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    341:365:boolean isVisibleBounds(nidefawl.qubes.world.IBlockWorld,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    369:372:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    382:382:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    388:388:boolean isSlab() -> int
    394:394:boolean isStairs() -> new
    408:408:boolean canPlaceAt(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    420:420:int prePlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    431:431:void postPlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    442:443:void place(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> if
    448:448:boolean isReplaceable() -> try
    451:454:int placeOffset(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> if
    468:473:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    476:476:boolean isFullBB() -> byte
    479:479:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    485:485:short[] getRegisteredIDs() -> do
    492:492:nidefawl.qubes.block.Block[] getRegisteredBlocks() -> do
    496:499:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    506:506:int getRenderShadow() -> try
    511:513:java.lang.String toString() -> toString
    517:521:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    525:525:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
    529:537:int getItems(java.util.List) -> do
    541:541:int getMeshedColor(nidefawl.qubes.meshing.BlockSurface) -> do
    545:545:int getTextureByIdx(int) -> do
    549:549:int getLightLoss(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
    579:579:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    587:587:int getInvRenderData(nidefawl.qubes.item.BlockStack) -> do
    593:593:float getInvRenderRotation() -> if
    596:596:boolean canMineWith(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    599:599:void onBlockMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    602:602:void onUpdate(nidefawl.qubes.world.World,int,int,int,int) -> do
    604:604:nidefawl.qubes.models.qmodel.ModelBlock getBlockModel(nidefawl.qubes.world.IBlockWorld,int,int,int,int) -> do
    607:610:int getNormalMap(int) -> if
    613:613:float getRoughness(int) -> do
    616:616:nidefawl.qubes.block.Block getBaseBlock() -> do
    619:619:boolean canWalkThru(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.entity.Entity) -> do
    622:622:boolean renderMeshedAndNormal() -> case
    35:123:void <clinit>() -> <clinit>
nidefawl.qubes.block.Block$1 -> L1ll1L1LJillIjL1:
    int[] $SwitchMap$nidefawl$qubes$block$BlockTextureMode -> do
    285:285:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockAir -> lliJlliJL1JijIjI:
    25:26:void <init>(java.lang.String) -> <init>
    28:30:void <init>(java.lang.String,boolean) -> <init>
    33:33:nidefawl.qubes.block.Block setTextures(java.lang.String[]) -> do
    41:41:int getTexture(int,int,int) -> do
    45:45:int getRenderPass() -> for
    48:48:int getRenderType() -> int
    52:52:boolean applyAO() -> if
    55:55:boolean isOccluding() -> for
    59:59:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    62:62:float getAlpha() -> do
    65:65:int getLightValue() -> new
    70:70:boolean isVisibleBounds(nidefawl.qubes.world.IBlockWorld,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    74:74:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    78:78:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    82:82:boolean isReplaceable() -> try
    87:87:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    90:90:boolean isFullBB() -> byte
    95:95:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    99:99:int getItems(java.util.List) -> do
    104:104:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
nidefawl.qubes.block.BlockCategory -> IjIjllIjJiIjJiL1:
    nidefawl.qubes.block.BlockCategory GROUND -> do
    nidefawl.qubes.block.BlockCategory ROCK -> if
    nidefawl.qubes.block.BlockCategory LEAVES -> for
    nidefawl.qubes.block.BlockCategory STONE -> int
    nidefawl.qubes.block.BlockCategory LOG -> new
    nidefawl.qubes.block.BlockCategory FLOWER -> try
    nidefawl.qubes.block.BlockCategory VINE -> byte
    nidefawl.qubes.block.BlockCategory PLANT -> case
    nidefawl.qubes.block.BlockCategory UNASSIGNED -> char
    nidefawl.qubes.block.BlockCategory[] $VALUES -> do
    10:10:nidefawl.qubes.block.BlockCategory[] values() -> values
    10:10:nidefawl.qubes.block.BlockCategory valueOf(java.lang.String) -> valueOf
    10:10:void <init>(java.lang.String,int) -> <init>
    10:11:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockConnect -> llllL1IjJiIjjIll:
    nidefawl.qubes.block.BlockConnect FENCE -> do
    nidefawl.qubes.block.BlockConnect WALL -> if
    nidefawl.qubes.block.BlockConnect PANE -> for
    nidefawl.qubes.block.BlockConnect[] $VALUES -> do
    10:10:nidefawl.qubes.block.BlockConnect[] values() -> values
    10:10:nidefawl.qubes.block.BlockConnect valueOf(java.lang.String) -> valueOf
    10:10:void <init>(java.lang.String,int) -> <init>
    10:11:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockDoubleCatTail -> llJill1LjIiJjIIj:
    8:9:void <init>(java.lang.String) -> <init>
    13:13:int getTexturePasses() -> do
    17:20:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockDoublePlant -> iJjIllJiL1L1Ji:
    21:23:void <init>(java.lang.String) -> <init>
    30:30:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    34:37:void postPlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    40:40:int getRenderType() -> int
    45:45:boolean applyAO() -> if
    50:50:boolean isOccluding() -> for
    58:58:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    62:62:boolean isReplaceable() -> try
    66:66:boolean isFullBB() -> byte
    73:76:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    81:86:int getTexture(int,int,int) -> do
    91:91:int getRenderShadow() -> try
    98:101:void onUpdate(nidefawl.qubes.world.World,int,int,int,int) -> do
    103:108:boolean canStayOn(nidefawl.qubes.world.World,int,int,int) -> do
nidefawl.qubes.block.BlockFence -> lliJJiIjL1llL1L1:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    19:19:nidefawl.qubes.block.Block getBaseBlock() -> do
    23:32:int setFenceConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> do
    36:42:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    46:46:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
    50:53:void <init>(java.lang.String,nidefawl.qubes.block.Block) -> <init>
    59:59:int getLightValue() -> new
    64:64:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    69:69:float getAlpha() -> do
    73:79:int getTexture(int,int,int) -> do
    83:83:int getRenderType() -> int
    88:88:boolean isOccluding() -> for
    93:93:boolean isFullBB() -> byte
    98:98:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    103:103:int getRenderShadow() -> try
    108:124:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    129:181:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
nidefawl.qubes.block.BlockFlowerFMN -> L1jIL11LjIL1llIj:
    21:23:void <init>(java.lang.String) -> <init>
    29:32:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    35:35:int getTexturePasses() -> do
    39:42:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockGrass -> jIllL1JiJilliJll:
    13:15:void <init>(java.lang.String) -> <init>
    19:21:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    25:34:int getTexture(int,int,int) -> do
    37:37:int getMeshedColor(nidefawl.qubes.meshing.BlockSurface) -> do
    41:41:int getTexturePasses() -> do
    45:45:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    49:54:int getNormalMap(int) -> if
nidefawl.qubes.block.BlockGrassBush -> L1JiL1jIjIlljIJi:
    21:23:void <init>(java.lang.String) -> <init>
    27:27:boolean applyRandomOffset() -> char
    31:31:int getLODPass() -> if
    35:35:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
nidefawl.qubes.block.BlockGravel -> iJL1jIIjjIjIiJ1L:
    10:20:void <init>(java.lang.String) -> <init>
nidefawl.qubes.block.BlockGroup -> Ji1LL11Lll1LJiiJ:
    int NEXT_GROUP_ID -> do
    int id -> if
    java.util.List blocks -> do
    14:21:void <init>() -> <init>
    24:26:void addBlock(nidefawl.qubes.block.Block) -> do
    java.util.List getNames() -> do
    31:31:java.util.List getBlocks() -> if
    34:34:nidefawl.qubes.block.Block getFirst() -> do
    15:15:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockGroupBricks -> llL1IjiJJiJiiJ:
    java.util.List stoneNames -> do
    15:23:void <init>(nidefawl.qubes.block.BlockGroup) -> <init>
    27:27:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupCobbleStones -> iJL1JilllliJJiiJ:
    java.util.List stoneNames -> do
    15:25:void <init>(nidefawl.qubes.block.BlockGroup) -> <init>
    29:29:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupFences -> iJ1LiJiJllL1Ji1L:
    java.util.List stoneNames -> do
    17:40:void <init>(nidefawl.qubes.block.BlockGroup[]) -> <init>
    44:44:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupLeaves -> jIiJL1JiJiiJL1iJ:
    java.util.List leaveNames -> do
    nidefawl.qubes.block.Block acacia -> do
    nidefawl.qubes.block.Block birch -> if
    nidefawl.qubes.block.Block oak -> for
    15:26:void <init>() -> <init>
    29:29:java.util.List getNames() -> do
    8:8:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockGroupLogs -> ll1L1LIj1LL1jI1L:
    java.util.List logNames -> do
    nidefawl.qubes.block.Block oak -> do
    14:31:void <init>() -> <init>
    35:35:java.util.List getNames() -> do
    9:9:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockGroupModelledStones -> iJ1LllL1iJJillL1:
    java.util.List stoneNames -> do
    19:49:void <init>(nidefawl.qubes.block.BlockGroup[]) -> <init>
    53:53:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupOres -> lliJL1JiL1L11LIj:
    java.util.List stoneNames -> do
    9:31:void <init>(nidefawl.qubes.block.BlockGroup,nidefawl.qubes.block.Block[]) -> <init>
    35:35:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupParquets -> jI1LIjjIiJlljIll:
    10:25:void <init>() -> <init>
    28:28:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupSlabs -> L1L1jIJiiJIjiJjI:
    java.util.List stoneNames -> do
    16:38:void <init>(nidefawl.qubes.block.BlockGroup[]) -> <init>
    42:42:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupSmoothStones -> llL1IjjIJiiJlljI:
    java.util.List stoneNames -> do
    15:26:void <init>(nidefawl.qubes.block.BlockGroup) -> <init>
    30:30:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStairs -> jIjIJi1LIjlliJL1:
    java.util.List stoneNames -> do
    17:40:void <init>(nidefawl.qubes.block.BlockGroup[]) -> <init>
    44:44:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStoneBricks -> jIiJJiL11LiJL1:
    java.util.List stoneNames -> do
    15:30:void <init>(nidefawl.qubes.block.BlockGroup) -> <init>
    34:34:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStonePath -> IjiJ1LIj1L1LIjIj:
    java.util.List stoneNames -> do
    15:25:void <init>(nidefawl.qubes.block.BlockGroup) -> <init>
    29:29:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupStones -> Ji1LJilliJjI1LJi:
    java.util.List stoneNames -> do
    nidefawl.qubes.block.Block granite -> do
    nidefawl.qubes.block.Block basalt -> if
    nidefawl.qubes.block.Block diorite -> for
    nidefawl.qubes.block.Block marble -> int
    nidefawl.qubes.block.Block obsidian -> new
    nidefawl.qubes.block.Block sandstone -> try
    nidefawl.qubes.block.Block sandstone_red -> byte
    15:41:void <init>() -> <init>
    44:44:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupWalls -> L11LjIllL11LIjJi:
    java.util.List stoneNames -> do
    17:39:void <init>(nidefawl.qubes.block.BlockGroup[]) -> <init>
    43:43:java.util.List getNames() -> do
nidefawl.qubes.block.BlockGroupWood -> jIJi1LiJL11Lll1L:
    10:23:void <init>() -> <init>
    26:26:java.util.List getNames() -> do
nidefawl.qubes.block.BlockIce -> lljIIjL1JiL1llIj:
    15:16:void <init>(java.lang.String) -> <init>
    20:20:int getRenderPass() -> for
    25:25:boolean applyAO() -> if
    30:30:float getAlpha() -> do
    35:35:boolean isOccluding() -> for
    40:40:int getRenderShadow() -> try
    44:44:int getLightLoss(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
    48:52:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    56:56:int getLODPass() -> if
    59:67:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    71:76:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    81:81:boolean isFullBB() -> byte
    85:85:int getRenderType() -> int
nidefawl.qubes.block.BlockLeaves -> IjlljIIjllJillL1:
    int leavesColor -> if
    22:24:void <init>(java.lang.String) -> <init>
    27:29:void <init>(java.lang.String,int) -> <init>
    33:33:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    38:38:boolean applyAO() -> if
    43:43:boolean isOccluding() -> for
    47:47:int getLightLoss(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
    52:52:boolean renderMeshedAndNormal() -> case
    56:56:int getRenderType() -> int
    59:61:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockLog -> Ijll1LjIJiJiJiL1:
    int index -> if
    29:32:void <init>(java.lang.String,int) -> <init>
    35:35:int getIndex() -> byte
    40:66:int getTexture(int,int,int) -> do
    71:71:int getTexturePasses() -> do
    76:81:void onBlockMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    85:89:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    94:94:int getRenderType() -> int
nidefawl.qubes.block.BlockModelled -> jIlliJjIlliJ1Lll:
    13:14:void <init>(java.lang.String) -> <init>
    18:18:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    23:23:boolean isFullBB() -> byte
    27:27:boolean isTransparent() -> do
    31:31:int getLODPass() -> if
    35:35:int getRenderPass() -> for
    39:39:int getRenderShadow() -> try
    43:43:boolean isOccluding() -> for
    48:48:int getRenderType() -> int
nidefawl.qubes.block.BlockOre -> JillIjlljIIjjIjI:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    19:22:void <init>(java.lang.String,nidefawl.qubes.block.Block,java.util.List) -> <init>
    26:26:int getLightValue() -> new
    31:31:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    36:40:int getTexture(int,int,int) -> do
    45:45:int getTexturePasses() -> do
    50:57:void onBlockMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    61:65:boolean skipTexturePassSide(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    69:69:int getNormalMap(int) -> if
    73:73:int getRenderType() -> int
nidefawl.qubes.block.BlockPane -> iJJiJilliJ1LjI:
    18:27:int setPaneConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    31:31:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    35:41:int getConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> if
    45:45:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
    53:53:int getRenderType() -> int
    59:59:int getRenderShadow() -> try
    64:64:boolean isOccluding() -> for
    69:69:boolean isFullBB() -> byte
    74:74:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    80:109:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    114:166:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
nidefawl.qubes.block.BlockPlantCrossedSquares -> IjL1jI1LL1jIIj:
    boolean multipass -> do
    25:26:void <init>(java.lang.String) -> <init>
    28:31:void <init>(java.lang.String,boolean) -> <init>
    38:41:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    45:45:int getRenderType() -> int
    50:50:boolean isOccluding() -> for
    58:58:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    62:62:boolean isReplaceable() -> try
    66:66:boolean isFullBB() -> byte
    69:69:boolean applyRandomOffset() -> char
    73:76:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    81:81:int getRenderShadow() -> try
    84:84:int getTexturePasses() -> do
    88:91:int getTexture(int,int,int) -> do
    97:97:int getLODPass() -> if
    104:107:void onUpdate(nidefawl.qubes.world.World,int,int,int,int) -> do
    109:110:boolean canStayOn(nidefawl.qubes.world.World,int,int,int) -> do
nidefawl.qubes.block.BlockPlantFlat -> lllliJL1IjiJL1L1:
    22:25:void <init>(java.lang.String) -> <init>
    32:32:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    36:36:int getRenderType() -> int
    41:41:boolean isOccluding() -> for
    46:46:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    50:50:boolean isReplaceable() -> try
    54:54:boolean isFullBB() -> byte
    61:68:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    73:73:int getRenderShadow() -> try
    79:79:int getLODPass() -> if
nidefawl.qubes.block.BlockQuarterBlock -> L1lliJIjjI1LiJJi:
    short[] readOnly -> do
    32:34:void <init>(java.lang.String) -> <init>
    36:40:short[] getSafeRead(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    45:49:nidefawl.qubes.chunk.blockdata.BlockDataQuarterBlock getSafeCast(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    54:60:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    63:69:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    73:98:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    102:106:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    111:128:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    132:138:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    144:197:int getItems(java.util.List) -> do
    201:205:void postPlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    28:28:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockSand -> iJiJ1LL1IjIjiJll:
    16:18:void <init>(java.lang.String) -> <init>
nidefawl.qubes.block.BlockSlab -> jIL1IjjIL1llIj:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    int overrideTextureIdx -> if
    27:27:nidefawl.qubes.block.Block getBaseBlock() -> do
    31:32:void <init>(java.lang.String,nidefawl.qubes.block.Block) -> <init>
    34:38:void <init>(java.lang.String,nidefawl.qubes.block.Block,int) -> <init>
    42:42:boolean isOccluding() -> for
    48:48:int getLightValue() -> new
    53:53:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    58:58:float getAlpha() -> do
    63:63:boolean applyAO() -> if
    68:68:boolean isTransparent() -> do
    73:82:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    87:87:java.lang.String getName() -> do
    92:99:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    104:104:boolean canPlaceAt(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    108:120:int prePlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    124:131:int placeOffset(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> if
    136:171:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    175:176:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    183:183:boolean isSlab() -> int
    188:194:int getTexture(int,int,int) -> do
    197:197:boolean isFullBB() -> byte
    200:200:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    205:215:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    219:220:int getItems(java.util.List) -> do
nidefawl.qubes.block.BlockSliced -> iJ1LL1L1llL1lliJ:
    8:9:void <init>(java.lang.String,boolean) -> <init>
    13:13:int getRenderType() -> int
nidefawl.qubes.block.BlockStairs -> Ij1LL1IjIjL1IjjI:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    int overrideTextureIdx -> if
    int[] offsetXZ -> do
    int[] offsetXZ2 -> if
    27:27:nidefawl.qubes.block.Block getBaseBlock() -> do
    31:31:boolean isUpsideDown(int) -> for
    34:35:void <init>(java.lang.String,nidefawl.qubes.block.Block) -> <init>
    37:41:void <init>(java.lang.String,nidefawl.qubes.block.Block,int) -> <init>
    45:45:boolean isOccluding() -> for
    51:51:int getLightValue() -> new
    56:56:boolean applyAO() -> if
    61:61:boolean isTransparent() -> do
    66:85:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    89:108:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    113:113:java.lang.String getName() -> do
    118:118:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    123:123:float getAlpha() -> do
    128:135:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    141:160:int prePlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    165:186:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    192:192:boolean isNormalBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    198:198:boolean isStairs() -> new
    203:209:int getTexture(int,int,int) -> do
    212:212:boolean isFullBB() -> byte
    228:261:int stairTypeAt(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    265:322:void getQuarters(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    330:389:void setStairBB(nidefawl.qubes.vec.AABBFloat,int,int,int,int) -> do
    391:391:boolean isOccludingBlock(nidefawl.qubes.world.IBlockWorld,int,int,int) -> if
    215:221:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockStone -> lllljIL1L1iJ1LJi:
    10:11:void <init>(java.lang.String) -> <init>
    15:15:float getRoughness(int) -> do
nidefawl.qubes.block.BlockStoneModelled -> jIJiL1jIjIiJiJJi:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    int overrideTextureIdx -> if
    12:13:void <init>(java.lang.String,nidefawl.qubes.block.Block) -> <init>
    15:19:void <init>(java.lang.String,nidefawl.qubes.block.Block,int) -> <init>
    22:28:int getTexture(int,int,int) -> do
nidefawl.qubes.block.BlockTextureMode -> jIiJL1Ij1LL1L1Ji:
    nidefawl.qubes.block.BlockTextureMode DEFAULT -> do
    nidefawl.qubes.block.BlockTextureMode TOP -> if
    nidefawl.qubes.block.BlockTextureMode TOP_BOTTOM -> for
    nidefawl.qubes.block.BlockTextureMode SUBTYPED_TEX_PER_TYPE -> int
    nidefawl.qubes.block.BlockTextureMode[] $VALUES -> do
    10:10:nidefawl.qubes.block.BlockTextureMode[] values() -> values
    10:10:nidefawl.qubes.block.BlockTextureMode valueOf(java.lang.String) -> valueOf
    10:10:void <init>(java.lang.String,int) -> <init>
    10:12:void <clinit>() -> <clinit>
nidefawl.qubes.block.BlockTorch -> L1IjIjlliJiJIjL1:
    21:22:void <init>(java.lang.String) -> <init>
    25:25:int getRenderType() -> int
    29:29:int getLightValue() -> new
    36:36:boolean applyAO() -> if
    41:41:boolean isOccluding() -> for
    45:45:boolean isFullBB() -> byte
    49:49:int getRenderShadow() -> try
    53:74:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    79:79:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    82:85:void onUpdate(nidefawl.qubes.world.World,int,int,int,int) -> do
    87:88:boolean canStayOn(nidefawl.qubes.world.World,int,int,int) -> do
nidefawl.qubes.block.BlockVine -> iJlliJJiL1iJJi:
    28:30:void <init>(java.lang.String) -> <init>
    34:34:int getRenderType() -> int
    39:39:int getLODPass() -> if
    45:48:boolean canPlaceAt(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    53:88:int prePlace(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,int,int) -> do
    94:94:boolean isOccluding() -> for
    99:99:boolean isFullBB() -> byte
    104:104:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    109:109:int getRenderShadow() -> try
    114:114:boolean isReplaceable() -> try
    119:125:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    130:130:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    135:135:int setSelectionBB(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.AABBFloat) -> do
    139:171:int setSelectionBB(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    176:176:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    180:180:int getInvRenderData(nidefawl.qubes.item.BlockStack) -> do
    186:186:float getInvRenderRotation() -> if
    189:204:void onUpdate(nidefawl.qubes.world.World,int,int,int,int) -> do
nidefawl.qubes.block.BlockWall -> JiL1lliJ1LL1jIll:
    nidefawl.qubes.block.Block baseBlock -> sZ2zsZsZsZZsz2SS
    int overrideTextureIdx -> if
    23:23:nidefawl.qubes.block.Block getBaseBlock() -> do
    27:40:int setWallConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> do
    44:50:boolean canConnectTo(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    55:55:boolean canBlockConnect(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.block.BlockConnect,int,int) -> do
    60:61:void <init>(java.lang.String,nidefawl.qubes.block.Block) -> <init>
    63:67:void <init>(java.lang.String,nidefawl.qubes.block.Block,int) -> <init>
    73:73:int getLightValue() -> new
    78:78:int getFaceColor(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int) -> do
    83:83:float getAlpha() -> do
    87:93:int getTexture(int,int,int) -> do
    97:97:int getRenderType() -> int
    103:103:boolean isOccluding() -> for
    108:108:boolean isFullBB() -> byte
    113:113:boolean isFaceVisible(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,nidefawl.qubes.block.Block,nidefawl.qubes.vec.AABBFloat) -> do
    118:118:int getRenderShadow() -> try
    123:135:nidefawl.qubes.vec.AABBFloat getRenderBlockBounds(nidefawl.qubes.world.IBlockWorld,int,int,int,nidefawl.qubes.vec.AABBFloat) -> do
    140:192:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    197:198:int getItems(java.util.List) -> do
nidefawl.qubes.block.BlockWater -> jIiJJiL11L1LlliJ:
    8:9:void <init>(java.lang.String) -> <init>
    13:13:int getRenderPass() -> for
    18:18:boolean applyAO() -> if
    23:23:float getAlpha() -> do
    28:28:boolean isOccluding() -> for
    33:33:boolean isReplaceable() -> try
    38:38:int getBBs(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.AABBFloat[]) -> do
    43:43:int getRenderShadow() -> try
    47:47:int getLightLoss(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
    50:50:float getRoughness(int) -> do
nidefawl.qubes.block.BlockWaterLily -> iJiJIjllIjll1LL1:
    19:21:void <init>(java.lang.String) -> <init>
    24:24:int getRenderType() -> int
    27:30:void onUpdate(nidefawl.qubes.world.World,int,int,int,int) -> do
    32:32:boolean canStayOn(nidefawl.qubes.world.World,int,int,int) -> do
nidefawl.qubes.block.BlockWood -> IjjIiJ1LllIjiJ:
    int index -> if
    8:10:void <init>(java.lang.String,int) -> <init>
    12:12:int getIndex() -> byte
nidefawl.qubes.block.IDMappingBlocks -> llJijI1LIjiJIjiJ:
    boolean CHANGED -> do
    boolean LOADED -> if
    int HIGHEST_BLOCK_ID -> do
    com.google.common.collect.ImmutableBiMap map -> do
    java.lang.Object sync -> do
    33:72:void load() -> do
    74:115:void save() -> if
    117:149:int get(java.lang.String) -> do
    25:30:void <clinit>() -> <clinit>
nidefawl.qubes.blocklight.BlockLightThread -> iJllL1L1JiIjjIjI:
    long sleepTime -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    nidefawl.qubes.blocklight.LightChunkCache[] caches -> do
    int misses -> do
    int hits -> if
    boolean isRunning -> do
    nidefawl.qubes.world.WorldServer world -> do
    boolean finished -> if
    nidefawl.qubes.blocklight.BlockLightUpdate lightUpdater -> do
    16:36:void <init>(nidefawl.qubes.world.WorldServer) -> <init>
    46:121:void run() -> run
    130:149:nidefawl.qubes.blocklight.LightChunkCache getCache(nidefawl.qubes.world.WorldServer,int,int) -> do
    154:172:void halt() -> do
    175:177:long toHash(long,long,long,long) -> do
    181:181:int getX(long) -> do
    185:185:int getZ(long) -> if
    189:189:int getY(long) -> for
    193:193:int getFlags(long) -> int
    197:200:void queueBlock(int,int,int,int) -> do
    203:205:void queueChunk(int,int,int) -> do
    211:213:void ensureEmpty() -> if
    15:15:void <clinit>() -> <clinit>
nidefawl.qubes.blocklight.BlockLightUpdate -> ll1LL1jIllIjIjJi:
    long[] stackRemove -> do
    long[] stackAdd -> if
    int[] stackRemoveLight -> do
    int numBlocksUpdate -> do
    14:20:void <init>() -> <init>
    25:59:void updateChunk(nidefawl.qubes.blocklight.LightChunkCache,int,int,int) -> do
    64:185:void updateBlock(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
    188:190:void setLight(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int,int,int) -> do
    194:228:int getNewLightLevel(nidefawl.qubes.blocklight.LightChunkCache,int,int,int,int) -> do
nidefawl.qubes.blocklight.LightChunkCache -> L1jIllJiL1iJ1LiJ:
    nidefawl.qubes.chunk.Chunk[] chunks -> do
    int lastX -> do
    int lastZ -> if
    boolean isValid -> do
    int[] flaggedNumBlocks -> do
    nidefawl.qubes.vec.BlockBoundingBox[] flaggedBlocks -> do
    int worldHeightMin1 -> for
    int nUse -> new
    int drainedChunks -> int
    28:44:void <init>() -> <init>
    47:51:void resetFlaggedBlocks() -> do
    54:56:void invalidate() -> if
    59:64:int idx(int,int) -> do
    68:68:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    72:73:boolean canSeeSky(int,int,int) -> do
    77:78:boolean isTransparent(int,int,int) -> if
    82:83:int getHeight(int,int) -> if
    87:90:int getLight(int,int,int,int) -> do
    93:96:int getWater(int,int,int) -> do
    103:107:int getTypeId(int,int,int) -> if
    119:134:boolean setLight(int,int,int,int,int,int) -> do
    138:147:boolean isValid(nidefawl.qubes.world.WorldServer,int,int) -> do
    150:165:boolean cache(nidefawl.qubes.world.WorldServer,int,int) -> if
    176:188:void drainFlagged(nidefawl.qubes.server.PlayerChunkTracker) -> do
    196:200:boolean hasBlock(int,int) -> do
    207:208:void flagUsed() -> for
    217:217:int getNumUses() -> do
nidefawl.qubes.chat.ChannelManager -> jIjIIjJiiJjIL11L:
    java.util.Map channels -> do
    nidefawl.qubes.chat.channel.GlobalChannel global -> do
    nidefawl.qubes.server.GameServer server -> do
    25:36:void <init>(nidefawl.qubes.server.GameServer) -> <init>
    42:42:nidefawl.qubes.server.GameServer getServer() -> do
    49:50:void registerChannel(nidefawl.qubes.chat.channel.AbstractChannel) -> do
    53:53:nidefawl.qubes.chat.channel.AbstractChannel getChannel(java.lang.String) -> do
    64:71:void addUser(nidefawl.qubes.chat.ChatUser) -> do
    77:84:void removeUser(nidefawl.qubes.entity.PlayerServer) -> do
    92:96:void handlePlayerChat(nidefawl.qubes.chat.ChatUser,java.lang.String,java.lang.String) -> do
nidefawl.qubes.chat.ChatUser -> JiL1jIJillll1LjI:
    java.util.Collection getJoinedChannels() -> do
    java.lang.String getChatName() -> do
    void sendMessage(java.lang.String,java.lang.String) -> do
nidefawl.qubes.chat.channel.AbstractChannel -> JiiJL1iJjIllJill:
    java.lang.String name -> do
    java.lang.String tag -> if
    nidefawl.qubes.chat.ChannelManager channelManager -> do
    31:31:java.lang.String getTag() -> do
    39:43:void <init>(nidefawl.qubes.chat.ChannelManager,java.lang.String,java.lang.String) -> <init>
    java.util.Collection getUsers() -> do
    void addUser(nidefawl.qubes.chat.ChatUser) -> do
    void removeUser(nidefawl.qubes.chat.ChatUser) -> if
    56:56:boolean containsUser(nidefawl.qubes.chat.ChatUser) -> do
    64:66:void onChat(nidefawl.qubes.chat.ChatUser,java.lang.String) -> do
    73:76:void broadcastUserMessage(nidefawl.qubes.chat.ChatUser,java.lang.String) -> if
    93:94:java.lang.String formatMessage(nidefawl.qubes.chat.ChatUser,java.lang.String) -> do
nidefawl.qubes.chat.channel.GlobalChannel -> L1iJIjIjIjJiJiJi:
    24:25:void <init>(nidefawl.qubes.chat.ChannelManager,java.lang.String) -> <init>
    29:29:java.util.Collection getUsers() -> do
    34:34:void addUser(nidefawl.qubes.chat.ChatUser) -> do
    38:38:void removeUser(nidefawl.qubes.chat.ChatUser) -> if
nidefawl.qubes.chat.client.ChatLine -> L1IjIjll1LJiIjJi:
    java.lang.String rawMessage -> do
    long receiveTime -> do
    17:20:void <init>(java.lang.String,long) -> <init>
    25:25:java.lang.String getLine() -> do
    31:31:long getTime() -> do
nidefawl.qubes.chat.client.ChatManager -> iJJiJi1L1LjIiJjI:
    java.util.ArrayList line -> do
    java.util.ArrayList hist -> if
    boolean saveHistory -> do
    nidefawl.qubes.chat.client.ChatManager instance -> do
    21:31:void <init>() -> <init>
    37:37:nidefawl.qubes.chat.client.ChatManager getInstance() -> do
    45:46:void receiveMessage(java.lang.String,java.lang.String) -> do
    52:52:java.util.List getLines() -> do
    59:65:int getNumNewLines() -> do
    69:69:void syncChannels(java.util.ArrayList) -> do
    75:87:void loadInputHistory() -> do
    93:106:void saveInputHistory() -> if
    109:111:void addHistory(java.lang.String) -> do
    115:115:int getHistorySize() -> if
    120:120:java.lang.String getHistory(int) -> do
    125:125:int indexOfHistory(java.lang.String) -> do
    130:132:void removeHistory(int) -> do
    137:139:void addHistory(int,java.lang.String) -> do
    26:26:void <clinit>() -> <clinit>
nidefawl.qubes.chunk.Chunk -> JiL1Ij1LjIllJi1L:
    nidefawl.qubes.world.World world -> do
    int x -> do
    int z -> if
    int worldHeightBits -> for
    int height -> int
    short[] blocks -> do
    nidefawl.qubes.chunk.ChunkDataSliced2 blockMetadata -> do
    nidefawl.qubes.chunk.blockdata.BlockDataSliced blockData -> do
    byte[] blockLight -> do
    int[] heightMap -> do
    byte[] biomes -> if
    byte[] waterMask -> for
    long loadTime -> do
    boolean updateHeightMap -> do
    boolean needsSave -> if
    boolean isEmpty -> for
    boolean isLit -> int
    boolean isValid -> new
    boolean isUnloading -> try
    boolean isPopulated -> byte
    26:50:void <init>(nidefawl.qubes.world.World,int,int,int) -> <init>
    53:61:void checkIsEmtpy() -> do
    68:68:int getBlockX() -> do
    72:72:int getBlockZ() -> if
    76:76:int getWater(int,int,int) -> do
    80:80:int getTypeId(int,int,int) -> if
    89:89:nidefawl.qubes.biome.Biome getBiome(int,int) -> do
    93:93:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    96:96:int getData(int,int,int) -> for
    106:106:short getFullData(int,int,int) -> do
    110:110:boolean setFullData(int,int,int,short) -> do
    114:114:boolean setData(int,int,int,int) -> do
    117:117:boolean setBlockData(int,int,int,nidefawl.qubes.chunk.blockdata.BlockData) -> do
    121:133:int getTopBlock(int,int) -> do
    144:168:boolean setTypeData(int,int,int,int,int) -> do
    172:185:boolean setType(int,int,int,int) -> if
    189:191:void flagModified() -> if
    216:216:boolean justLoaded() -> do
    220:220:short[] getBlocks() -> do
    224:224:byte[] getBlockLight() -> do
    228:239:int getLight(int,int,int,int) -> do
    244:252:int getLight(int,int,int) -> int
    256:274:boolean setLight(int,int,int,int,int) -> if
    278:279:int getHeightMap(int,int) -> if
    285:314:void updateHeightMap(int,int) -> do
    318:330:void initLight() -> for
    334:353:void initHeightMap() -> int
    363:368:void postLoad() -> new
    371:372:void postGenerate() -> try
    379:396:byte[] getLights(nidefawl.qubes.vec.BlockBoundingBox) -> do
    405:425:boolean setLights(byte[],nidefawl.qubes.vec.BlockBoundingBox) -> do
    433:433:java.lang.String toString() -> toString
    440:440:byte[] getWaterMask() -> if
nidefawl.qubes.chunk.ChunkData -> L1JiL1jI1LiJL1Ji:
    14:14:void <init>() -> <init>
    boolean setByte(int,int,int,boolean,int) -> do
    21:21:boolean setLower(int,int,int,int) -> do
    27:27:nidefawl.qubes.nbt.Tag$Compound writeToTag() -> do
    33:33:void readFromTag(nidefawl.qubes.nbt.Tag$Compound) -> do
nidefawl.qubes.chunk.ChunkDataSliced2 -> L1L1lliJiJL1llIj:
    short[][] array -> do
    22:25:void <init>() -> <init>
    28:31:short get(int,int,int) -> do
    35:42:boolean set(int,int,int,short) -> do
    45:58:boolean setByte(int,int,int,boolean,int) -> do
    62:69:short[] getArray(int,boolean) -> do
    76:96:nidefawl.qubes.nbt.Tag$Compound writeToTag() -> do
    103:121:void readFromTag(nidefawl.qubes.nbt.Tag$Compound) -> do
    127:131:short[][] getArrays() -> do
nidefawl.qubes.chunk.ChunkManager -> jIJiL1llllIjjIIj:
    nidefawl.qubes.world.World world -> do
    nidefawl.qubes.chunk.ChunkTable table -> do
    13:16:void <init>(nidefawl.qubes.world.World) -> <init>
    nidefawl.qubes.chunk.ChunkTable makeChunkTable() -> do
    27:27:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    31:31:int getChunksLoaded() -> do
    35:35:void saveAll() -> do
    38:38:void queueLoadChecked(long) -> do
    45:45:int deleteAllChunks() -> if
    48:48:int regenChunks(java.util.Collection) -> do
nidefawl.qubes.chunk.ChunkTable -> JiJillllJiL1jIiJ:
    nidefawl.qubes.chunk.Chunk[][] values -> do
    int size -> do
    int halfSize -> if
    int approxLoaded -> byte
    int mswLow -> for
    int mswHigh -> int
    int lswLow -> new
    int lswHigh -> try
    25:33:void <init>(int) -> <init>
    36:50:boolean put(int,int,nidefawl.qubes.chunk.Chunk) -> do
    55:59:void updateBounds(int,int) -> do
    62:62:nidefawl.qubes.chunk.Chunk get(long) -> do
    66:71:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    76:83:nidefawl.qubes.chunk.Chunk remove(int,int) -> if
    98:111:int size() -> do
    150:152:nidefawl.qubes.chunk.Chunk[][] clear() -> do
    156:156:nidefawl.qubes.chunk.Chunk remove(long) -> if
    161:173:java.util.List asList() -> do
    234:234:java.util.Iterator iterator() -> iterator
nidefawl.qubes.chunk.ChunkTable$ChunkRegionTableIterator -> iJ1LJiIjIjiJjIIj:
    nidefawl.qubes.chunk.Chunk value -> do
    int msw -> do
    int lsw -> if
    nidefawl.qubes.chunk.ChunkTable table -> if
    nidefawl.qubes.chunk.ChunkTable this$0 -> do
    182:187:void <init>(nidefawl.qubes.chunk.ChunkTable,nidefawl.qubes.chunk.ChunkTable) -> <init>
    190:204:boolean hasNext() -> hasNext
    209:211:nidefawl.qubes.chunk.Chunk next() -> do
    216:216:void remove() -> remove
    177:177:java.lang.Object next() -> next
nidefawl.qubes.chunk.blockdata.BlockData -> IjlljIJiIj1Lllll:
    20:26:boolean isEqual(nidefawl.qubes.chunk.blockdata.BlockData,nidefawl.qubes.chunk.blockdata.BlockData) -> do
    29:30:void <init>() -> <init>
    33:33:boolean compareTo(nidefawl.qubes.chunk.blockdata.BlockData) -> do
    boolean compareData(nidefawl.qubes.chunk.blockdata.BlockData) -> if
    int getTypeId() -> do
    int getLength() -> if
    42:46:nidefawl.qubes.chunk.blockdata.BlockData fromType(int) -> do
    50:57:int writeHeader(byte[],int) -> do
    int writeData(byte[],int) -> if
    int readData(byte[],int) -> for
    63:66:int writeDataToStream(java.io.DataOutput) -> do
    74:77:void readDataFromStream(java.io.DataInput) -> do
    nidefawl.qubes.chunk.blockdata.BlockData copy() -> do
nidefawl.qubes.chunk.blockdata.BlockDataQuarterBlock -> iJ1LJiL1lliJjIL1:
    short[] blockIDs -> do
    byte[] blockMeta -> do
    15:17:void <init>() -> <init>
    21:28:boolean compareData(nidefawl.qubes.chunk.blockdata.BlockData) -> if
    33:33:int getTypeId() -> do
    38:38:int getLength() -> if
    43:48:int writeData(byte[],int) -> if
    53:57:int readData(byte[],int) -> for
    61:64:void fillIntArr(int[]) -> do
    67:72:void setTypeAndData(int,int,int,int,int) -> do
    74:79:void setType(int,int,int,int) -> do
    86:87:int getType(int,int,int) -> do
    90:91:int getData(int,int,int) -> if
    97:100:int idx(int,int,int) -> for
    105:110:nidefawl.qubes.chunk.blockdata.BlockData copy() -> do
nidefawl.qubes.chunk.blockdata.BlockDataSliced -> L1llJijI1LL1lljI:
    nidefawl.qubes.chunk.blockdata.BlockData[][] array -> do
    24:27:void <init>() -> <init>
    30:33:nidefawl.qubes.chunk.blockdata.BlockData get(int,int,int) -> do
    37:44:boolean set(int,int,int,nidefawl.qubes.chunk.blockdata.BlockData) -> do
    48:55:nidefawl.qubes.chunk.blockdata.BlockData[] getArray(int,boolean) -> do
    63:85:nidefawl.qubes.nbt.Tag$Compound writeToTag() -> do
    92:113:byte[] sliceToBytes(nidefawl.qubes.chunk.blockdata.BlockData[],byte[],int) -> do
    121:136:void readFromTag(nidefawl.qubes.nbt.Tag$Compound) -> do
    143:161:void sliceFromBytes(byte[],nidefawl.qubes.chunk.blockdata.BlockData[]) -> do
    167:171:nidefawl.qubes.chunk.blockdata.BlockData[][] getArrays() -> do
nidefawl.qubes.chunk.client.ChunkManagerClient -> iJIjllIj1LiJIjiJ:
    10:11:void <init>(nidefawl.qubes.world.World) -> <init>
    15:15:nidefawl.qubes.chunk.ChunkTable makeChunkTable() -> do
    19:25:nidefawl.qubes.chunk.Chunk getOrMake(int,int) -> if
    33:37:void remove(int,int) -> do
nidefawl.qubes.chunk.server.ChunkLoadThread -> L1L1jI1LlliJiJjI:
    java.util.concurrent.LinkedBlockingQueue queue -> do
    nidefawl.qubes.chunk.server.ChunkManagerServer mgr -> do
    nidefawl.qubes.chunk.server.ChunkLoadThread$LoadThread[] threads -> do
    11:78:void <init>(nidefawl.qubes.chunk.server.ChunkManagerServer,nidefawl.qubes.world.WorldServer) -> <init>
    81:84:void startThreads() -> do
    91:93:void ensureEmpty() -> if
    96:101:boolean isRunning() -> do
    109:112:void queueLoadChecked(long) -> do
    115:119:void halt() -> for
    10:10:nidefawl.qubes.chunk.server.ChunkManagerServer access$000(nidefawl.qubes.chunk.server.ChunkLoadThread) -> do
    10:10:java.util.concurrent.LinkedBlockingQueue access$100(nidefawl.qubes.chunk.server.ChunkLoadThread) -> do
nidefawl.qubes.chunk.server.ChunkLoadThread$LoadThread -> JijI1LJiL1Ij1LIj:
    boolean isRunning -> do
    boolean finished -> if
    nidefawl.qubes.chunk.server.ChunkManagerServer mgr -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    16:23:void <init>(nidefawl.qubes.chunk.server.ChunkLoadThread) -> <init>
    29:51:void run() -> run
    54:69:void halt() -> do
nidefawl.qubes.chunk.server.ChunkManagerServer -> JiIjJiiJ1LiJiJIj:
    nidefawl.qubes.chunk.server.ChunkLoadThread thread -> do
    nidefawl.qubes.chunk.server.ChunkUnloadThread unloadThread -> do
    nidefawl.qubes.chunk.server.ChunkReader reader -> do
    nidefawl.qubes.chunk.server.RegionFileCache regionFileCache -> do
    java.lang.Object syncObj -> do
    java.lang.Object syncObj2 -> if
    nidefawl.qubes.world.WorldServer worldServer -> do
    java.util.Iterator it -> do
    21:95:void <init>(nidefawl.qubes.world.WorldServer,java.io.File) -> <init>
    34:36:void startThreads() -> if
    38:46:void onWorldUnload() -> for
    50:50:nidefawl.qubes.chunk.ChunkTable makeChunkTable() -> do
    54:81:void loadOrGenerate(int,int) -> do
    86:87:void queueLoadChecked(int,int) -> if
    89:93:void queueLoadChecked(long) -> do
    97:117:void saveAndUnloadChunks(int) -> do
    119:124:void unloadChunk(int,int) -> for
    126:129:void saveChunk(nidefawl.qubes.chunk.Chunk) -> do
    136:148:void saveAll() -> do
    150:150:boolean isRunning() -> do
    156:156:java.util.Iterator newUpdateIterator() -> do
    163:179:int deleteAllChunks() -> if
    182:206:int regenChunks(java.util.Collection) -> do
nidefawl.qubes.chunk.server.ChunkReader -> iJ1LIj1LL11Lll:
    nidefawl.qubes.chunk.server.ChunkManagerServer mgr -> do
    nidefawl.qubes.chunk.server.RegionFileCache fileCache -> do
    16:19:void <init>(nidefawl.qubes.chunk.server.ChunkManagerServer,nidefawl.qubes.chunk.server.RegionFileCache) -> <init>
    22:33:nidefawl.qubes.chunk.Chunk loadChunk(nidefawl.qubes.world.World,int,int) -> do
    37:45:void saveChunk(nidefawl.qubes.chunk.Chunk) -> do
    48:72:nidefawl.qubes.nbt.Tag$Compound writeChunk(nidefawl.qubes.chunk.Chunk) -> do
    76:102:nidefawl.qubes.chunk.Chunk readChunk(nidefawl.qubes.world.World,int,int,nidefawl.qubes.nbt.Tag$Compound) -> do
    106:115:void readBlocks(byte[],short[]) -> do
nidefawl.qubes.chunk.server.ChunkUnloadThread -> JiIjjIIjjI1LJi1L:
    long sleepTime -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    boolean isRunning -> do
    nidefawl.qubes.chunk.server.ChunkManagerServer mgr -> do
    boolean finished -> if
    13:24:void <init>(nidefawl.qubes.chunk.server.ChunkManagerServer) -> <init>
    33:64:void run() -> run
    70:72:void ensureEmpty() -> do
    76:84:void queueUnloadChecked(java.lang.Long) -> do
    87:105:void halt() -> if
    12:12:void <clinit>() -> <clinit>
nidefawl.qubes.chunk.server.RegionFile -> jIiJjIJiL1jIJi:
    java.io.RandomAccessFile randomAccess -> do
    java.lang.String name -> do
    nidefawl.qubes.chunk.server.RegionFile$RegionFileHeader header -> do
    long timeWrite -> do
    long timeSeek -> if
    long timeSetSec -> for
    long timeFindSec -> int
    long timeWriteHeader -> new
    78:103:void <init>(java.io.File,int,int) -> <init>
    105:120:int deleteChunks() -> do
    124:136:byte[] readChunk(int,int) -> do
    146:195:void writeChunk(int,int,byte[]) -> do
    198:210:void writeAtOffset(nidefawl.qubes.chunk.server.RegionFile$DataChunkMeta,byte[]) -> do
    213:218:void setSectors(int,int,boolean) -> do
    221:221:int toBytes(int) -> do
    225:225:int toSectors(int) -> if
    229:229:nidefawl.qubes.chunk.server.RegionFile$DataChunkMeta getMeta(int) -> do
    233:235:void writeHeader() -> if
    238:244:boolean readHeader() -> do
    248:248:java.lang.String getName(int,int) -> do
    252:256:void close() -> do
    259:264:int getLastUsedSec() -> if
    268:273:int getLastFreeSec() -> for
    277:277:java.lang.String getFileName() -> do
    139:143:void <clinit>() -> <clinit>
nidefawl.qubes.chunk.server.RegionFile$DataChunkMeta -> JiIjllL1JiL1JiiJ:
    long byteOffset -> do
    int offset -> do
    int size -> if
    int writetime -> for
    46:51:void <init>(long) -> <init>
    54:57:void read(java.io.RandomAccessFile) -> do
    60:63:void write(java.io.RandomAccessFile) -> if
nidefawl.qubes.chunk.server.RegionFile$RegionFileHeader -> JijIllL1JilliJll:
    int version -> do
    nidefawl.qubes.chunk.server.RegionFile$DataChunkMeta[] chunks -> do
    java.util.ArrayList usedSectors -> do
    10:17:void <init>() -> <init>
    20:33:void read(java.io.RandomAccessFile) -> do
    36:41:void write(java.io.RandomAccessFile) -> if
nidefawl.qubes.chunk.server.RegionFileCache -> IjL1L1JiiJiJL11L:
    java.util.regex.Pattern FILE_PATTERN -> do
    java.io.File dir -> do
    java.util.HashMap map -> do
    15:33:void <init>(java.io.File) -> <init>
    30:30:long toLong(int,int) -> do
    36:36:nidefawl.qubes.chunk.server.RegionFile getRegionFileChunk(int,int) -> do
    40:56:nidefawl.qubes.chunk.server.RegionFile getRegionFile(int,int) -> if
    60:61:java.io.File getFile(java.io.File,int,int) -> do
    65:76:void closeAll() -> do
    79:103:int deleteChunks() -> do
    12:12:void <clinit>() -> <clinit>
nidefawl.qubes.chunk.server.RegionFileCache$1 -> ll1LjIL1JiiJll1L:
    nidefawl.qubes.chunk.server.RegionFileCache this$0 -> do
    80:80:void <init>(nidefawl.qubes.chunk.server.RegionFileCache) -> <init>
    84:84:boolean accept(java.io.File) -> accept
nidefawl.qubes.config.AbstractYMLConfig -> llJilljIiJllJiIj:
    java.util.Map map -> do
    17:22:void <init>(boolean) -> <init>
    25:42:void write(java.io.File) -> do
    45:71:void save(java.io.OutputStream) -> do
    74:86:void load(java.io.File) -> if
    89:96:void load(java.io.InputStream) -> do
    99:102:java.lang.String getString(java.lang.String,java.lang.String) -> do
    106:109:java.lang.Boolean getBoolean(java.lang.String,boolean) -> do
    113:116:int getInt(java.lang.String,int) -> do
    120:123:long getLong(java.lang.String,long) -> do
    127:130:float getFloat(java.lang.String,float) -> do
    141:142:void setString(java.lang.String,java.lang.String) -> do
    148:149:void setBoolean(java.lang.String,boolean) -> do
    152:153:void setInt(java.lang.String,int) -> do
    157:158:void setFloat(java.lang.String,float) -> do
    161:162:void setLong(java.lang.String,long) -> do
    void setDefaults() -> do
    void load() -> if
    void save() -> for
nidefawl.qubes.config.ClientSettings -> L1IjL1IjlliJIj1L:
    int chunkLoadDistance -> do
    int shadowDrawMode -> if
    int ssr -> for
    int aa -> int
    int smaaQuality -> new
    float thirdpersonDistance -> do
    boolean dirty -> do
    int saveTicks -> char
    int ao -> try
    java.lang.String lastserver -> do
    int anisotropicFiltering -> byte
    int normalMapping -> case
    boolean gui3d -> if
    12:13:void <init>() -> <init>
    31:41:void setDefaults() -> do
    45:56:void load() -> if
    60:71:void save() -> for
    78:84:boolean lazySave() -> do
nidefawl.qubes.config.InvalidConfigException -> lliJll1LjIL1jIiJ:
    7:8:void <init>(java.lang.String) -> <init>
    11:12:void <init>(java.lang.String,java.lang.Exception) -> <init>
nidefawl.qubes.config.ServerConfig -> L1iJL11LJiiJlljI:
    int port -> do
    java.lang.String listenAddr -> do
    int packetTimeout -> if
    int chunkCompressionLevel -> for
    5:6:void <init>() -> <init>
    15:19:void setDefaults() -> do
    23:27:void load() -> if
    31:35:void save() -> for
nidefawl.qubes.config.WorkingEnv -> jIjIL1llL1jIll1L:
    java.io.File workingDir -> do
    java.io.File assetDir -> if
    java.io.File packsDir -> for
    java.io.File worlds -> int
    java.io.File config -> new
    java.io.File playerdata -> try
    19:34:void init(java.lang.String) -> do
    37:37:java.io.File getAssetFolder() -> do
    43:43:java.io.File getConfigFolder() -> if
    46:46:java.io.File getWorldsFolder() -> for
    50:50:java.io.File getPlayerData() -> int
    11:11:void <clinit>() -> <clinit>
nidefawl.qubes.crafting.CraftingCategory -> llllllJill1L1LjI:
    nidefawl.qubes.crafting.CraftingCategory[] categories -> do
    nidefawl.qubes.crafting.CraftingCategory tools -> do
    nidefawl.qubes.crafting.CraftingCategory wood -> if
    nidefawl.qubes.crafting.CraftingCategory stone -> for
    nidefawl.qubes.crafting.CraftingCategory blocks -> int
    java.lang.String name -> do
    int id -> do
    java.util.ArrayList recipes -> do
    java.util.HashMap map -> do
    19:19:nidefawl.qubes.crafting.CraftingCategory getCatId(int) -> do
    23:29:void <init>(int,java.lang.String) -> <init>
    31:31:int getId() -> do
    38:46:void addRecipe(java.lang.String,nidefawl.qubes.crafting.recipes.CraftingRecipe) -> do
    13:17:void <clinit>() -> <clinit>
nidefawl.qubes.crafting.CraftingManager -> iJjIJilljIjIJi1L:
    nidefawl.qubes.entity.PlayerServer player -> do
    19:22:void <init>(nidefawl.qubes.entity.PlayerServer,int) -> <init>
    25:44:int handleRequest(nidefawl.qubes.crafting.CraftingCategory,nidefawl.qubes.crafting.recipes.CraftingRecipe,int,int) -> do
    48:53:void reset() -> do
    56:88:int craft(nidefawl.qubes.crafting.CraftingCategory,nidefawl.qubes.crafting.recipes.CraftingRecipe,int) -> do
    92:127:boolean update() -> do
    131:186:int findInputs(nidefawl.qubes.crafting.recipes.CraftingRecipe,nidefawl.qubes.inventory.slots.SlotsInventoryBase,nidefawl.qubes.inventory.slots.SlotsCrafting,int) -> do
    190:201:nidefawl.qubes.network.packet.PacketSCraftingProgress getStatePacket(int) -> do
nidefawl.qubes.crafting.CraftingManagerBase -> JiiJiJiJL1IjL1ll:
    int id -> do
    int amount -> if
    long startTime -> do
    long endTime -> if
    boolean finished -> do
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    11:17:void <init>() -> <init>
    21:29:nidefawl.qubes.nbt.Tag$Compound save() -> do
    32:37:void load(nidefawl.qubes.nbt.Tag$Compound) -> do
    40:53:int calcMaxAmount(nidefawl.qubes.crafting.recipes.CraftingRecipe,nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    56:56:int getAmount() -> do
    59:59:int getId() -> if
    62:62:long getStartTime() -> do
    65:65:long getEndTime() -> if
    68:68:nidefawl.qubes.crafting.recipes.CraftingRecipe getRecipe() -> do
    71:71:boolean isRunning() -> if
    74:74:boolean isFinished() -> for
nidefawl.qubes.crafting.CraftingManagerClient -> L1lljIjIiJIjjIIj:
    nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry guiElement -> do
    nidefawl.qubes.entity.PlayerSelf player -> do
    long recvTime -> for
    int state -> for
    16:20:void <init>(nidefawl.qubes.entity.PlayerSelf,int) -> <init>
    22:22:nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry getGuiElement() -> do
    31:45:void handleRequest(int,nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
nidefawl.qubes.crafting.recipes.CraftingRecipe -> iJIjiJll1LjIllL1:
    int NEXT_ID -> do
    nidefawl.qubes.item.BaseStack[] in -> do
    nidefawl.qubes.item.BaseStack[] out -> if
    int id -> if
    nidefawl.qubes.item.BaseStack preview -> do
    nidefawl.qubes.crafting.CraftingCategory category -> do
    java.lang.String subCat -> do
    19:22:void <init>() -> <init>
    24:24:int getId() -> do
    27:27:nidefawl.qubes.item.BaseStack[] getIn() -> do
    30:30:nidefawl.qubes.item.BaseStack[] getOut() -> if
    33:33:nidefawl.qubes.item.BaseStack getPreview() -> do
    55:55:long getTime() -> do
    58:58:nidefawl.qubes.crafting.CraftingCategory getCategory() -> do
    61:67:void setInput(nidefawl.qubes.item.BaseStack[]) -> do
    69:78:void setOutput(nidefawl.qubes.item.BaseStack[]) -> if
    80:82:void setCategory(nidefawl.qubes.crafting.CraftingCategory,java.lang.String) -> do
    9:9:void <clinit>() -> <clinit>
nidefawl.qubes.crafting.recipes.CraftingRecipes -> iJjIJillJill1LjI:
    java.util.ArrayList all -> do
    nidefawl.qubes.crafting.recipes.CraftingRecipe[] recipesArray -> do
    16:17:void add(nidefawl.qubes.crafting.recipes.CraftingRecipe) -> do
    21:111:void init() -> do
    114:114:nidefawl.qubes.crafting.recipes.CraftingRecipe getRecipeId(int) -> do
    12:12:void <clinit>() -> <clinit>
nidefawl.qubes.entity.Entity -> jIiJ1LjIJijIjI:
    int NEXT_ENT_ID -> do
    int id -> if
    nidefawl.qubes.world.World world -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    nidefawl.qubes.vec.Vec3D lastPos -> if
    nidefawl.qubes.vec.Vec3D mot -> for
    nidefawl.qubes.vec.Vec3D lastMot -> int
    float yaw -> do
    float lastYaw -> if
    float yawBodyOffset -> for
    float lastYawBodyOffset -> int
    float pitch -> new
    float lastPitch -> try
    boolean noclip -> do
    boolean hitGround -> if
    nidefawl.qubes.vec.AABB aabb -> do
    nidefawl.qubes.vec.AABB aabb2 -> if
    nidefawl.qubes.vec.AABB aabb3 -> for
    nidefawl.qubes.vec.AABB aabb4 -> int
    nidefawl.qubes.vec.AABB dbg -> new
    nidefawl.qubes.util.CollisionQuery coll -> do
    nidefawl.qubes.vec.Vector3f renderPos -> do
    nidefawl.qubes.vec.Vector3f renderRot -> if
    nidefawl.qubes.vec.Vec3D remotePos -> new
    nidefawl.qubes.vec.Vector3f remoteRotation -> for
    int rotticks -> for
    int posticks -> int
    double width -> do
    double height -> if
    double length -> for
    int ticks1 -> new
    float timeJump -> byte
    float timePunch -> case
    boolean flagRemove -> for
    java.util.Random random -> do
    nidefawl.qubes.entity.EntityProperties properties -> do
    nidefawl.qubes.item.BaseStack[] equipment -> do
    int swingAnim -> try
    int swingProgress -> byte
    float swingProgressF -> char
    float prevSwingProgressF -> else
    float distanceMoved -> goto
    float prevDistanceMoved -> long
    boolean isServerSide -> int
    18:69:void <init>(boolean) -> <init>
    73:73:int hashCode() -> hashCode
    78:78:boolean equals(java.lang.Object) -> equals
    82:86:void tickUpdate() -> do
    89:89:boolean doesFall() -> do
    92:92:boolean doesFly() -> if
    95:143:void postStep() -> if
    145:154:void preStep() -> for
    156:313:void step() -> int
    316:316:boolean findEdge() -> for
    320:320:float getGravity() -> do
    324:325:void move(nidefawl.qubes.vec.Vec3D) -> do
    328:329:void move(nidefawl.qubes.vec.Vector3f) -> do
    331:336:void move(double,double,double) -> do
    342:345:void setYawPitch(float,float) -> do
    351:356:nidefawl.qubes.nbt.Tag writeClientData(boolean) -> do
    361:368:void readClientData(nidefawl.qubes.nbt.Tag) -> do
    370:374:void readProperties(nidefawl.qubes.nbt.Tag) -> if
    nidefawl.qubes.entity.EntityType getEntityType() -> do
    383:391:int getLookDir() -> do
    400:404:nidefawl.qubes.vec.Vector3f getRenderPos(float) -> do
    413:428:nidefawl.qubes.vec.Vector3f getRenderRot(float) -> if
    435:437:void setRemotePos(nidefawl.qubes.vec.Vec3D) -> if
    445:471:void setRemoteRotation(float,float,float) -> do
    474:475:void remove() -> new
    478:478:java.util.Random getRandom() -> do
    482:482:float getPathWeight(int,int,int) -> do
    485:485:nidefawl.qubes.vec.AABB getAabb() -> do
    489:493:void adjustRenderProps(nidefawl.qubes.models.qmodel.QModelProperties,float) -> do
    496:496:nidefawl.qubes.models.EntityModel getEntityModel() -> do
    499:499:nidefawl.qubes.entity.EntityProperties getEntityProperties() -> do
    502:505:nidefawl.qubes.item.BaseStack getActiveItem(int) -> do
    510:511:void setEquipment(nidefawl.qubes.item.BaseStack[]) -> do
    514:514:int getSwinglen() -> if
    517:530:void animUpdate() -> byte
    532:538:void swing() -> try
    542:544:float getSwingProgress(float) -> do
    17:17:void <clinit>() -> <clinit>
nidefawl.qubes.entity.EntityAI -> JiJiIj1LL1IjJi:
    nidefawl.qubes.entity.ai.TaskManager taskManager -> do
    nidefawl.qubes.entity.ai.AINav nav -> do
    nidefawl.qubes.entity.ai.AIMove move -> do
    float moveForward -> this
    boolean jump -> new
    float landMovementFactor -> void
    float airMovementFactor -> break
    10:20:void <init>(boolean) -> <init>
    25:69:void tickUpdate() -> do
    73:83:void preStep() -> for
    86:99:void setMotion(float,float,float) -> if
    103:103:nidefawl.qubes.entity.ai.AINav getNav() -> do
    108:108:nidefawl.qubes.entity.ai.AIMove getMove() -> do
    114:115:void setMoveForward(float) -> do
nidefawl.qubes.entity.EntityAnimal -> iJ1LIjjIjIIjjIIj:
    8:12:void <init>(boolean) -> <init>
nidefawl.qubes.entity.EntityArcher -> jIL1iJjI1LL1jI1L:
    10:15:void <init>(boolean) -> <init>
    19:19:nidefawl.qubes.entity.EntityType getEntityType() -> do
    24:24:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityCat -> jI1L1L1LiJjIIjJi:
    9:10:void <init>(boolean) -> <init>
    14:14:nidefawl.qubes.entity.EntityType getEntityType() -> do
    19:19:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityChicken -> iJllL11LL1L1lliJ:
    10:11:void <init>(boolean) -> <init>
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityDemon -> JiIjJiJiIjjIL11L:
    8:13:void <init>(boolean) -> <init>
    17:17:nidefawl.qubes.entity.EntityType getEntityType() -> do
    22:22:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityDog -> lljIL1llIjJiIjiJ:
    10:11:void <init>(boolean) -> <init>
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityDuck -> iJJill1L1LjI1Lll:
    10:11:void <init>(boolean) -> <init>
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityGoat -> iJJilljIiJIjlliJ:
    10:11:void <init>(boolean) -> <init>
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityMob -> IjJiIjiJll1LiJll:
    10:12:void <init>(boolean) -> <init>
nidefawl.qubes.entity.EntityPig -> llL1iJjIlliJllL1:
    10:11:void <init>(boolean) -> <init>
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityPony -> jIiJjIll1LlljIiJ:
    10:11:void <init>(boolean) -> <init>
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityProperties -> IjJijIJiiJjIIjjI:
    int[] properties -> do
    6:8:void <init>() -> <init>
    11:11:int getOption(int,int) -> do
    15:23:nidefawl.qubes.nbt.Tag$Compound save() -> do
    26:35:void load(nidefawl.qubes.nbt.Tag$Compound) -> do
    38:42:void setOption(int,int) -> do
nidefawl.qubes.entity.EntityPuppy -> IjiJIj1LiJL1IjjI:
    10:11:void <init>(boolean) -> <init>
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntitySheep -> iJjI1LjIiJJijIiJ:
    10:11:void <init>(boolean) -> <init>
    15:15:nidefawl.qubes.entity.EntityType getEntityType() -> do
    20:20:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntitySkeleton -> L1IjIjIjIjjIL11L:
    10:14:void <init>(boolean) -> <init>
    18:18:nidefawl.qubes.entity.EntityType getEntityType() -> do
    23:23:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityType -> iJL1iJ1L1LJi1LjI:
    nidefawl.qubes.entity.EntityType[] mapping -> do
    nidefawl.qubes.entity.EntityType PLAYER -> do
    nidefawl.qubes.entity.EntityType PLAYER_SERVER -> if
    nidefawl.qubes.entity.EntityType CAT -> for
    nidefawl.qubes.entity.EntityType CHICKEN -> int
    nidefawl.qubes.entity.EntityType DOG -> new
    nidefawl.qubes.entity.EntityType DUCK -> try
    nidefawl.qubes.entity.EntityType GOAT -> byte
    nidefawl.qubes.entity.EntityType PIG -> case
    nidefawl.qubes.entity.EntityType PONY -> char
    nidefawl.qubes.entity.EntityType PUPPY -> else
    nidefawl.qubes.entity.EntityType SHEEP -> goto
    nidefawl.qubes.entity.EntityType SKELETON -> long
    nidefawl.qubes.entity.EntityType ZOMBIE -> this
    nidefawl.qubes.entity.EntityType ARCHER -> void
    nidefawl.qubes.entity.EntityType WARRIOR -> break
    nidefawl.qubes.entity.EntityType DEMON -> catch
    int id -> do
    java.lang.Class clazz -> do
    double width -> do
    double length -> if
    double height -> for
    31:47:void load() -> do
    57:64:void <init>(int,java.lang.Class,double,double,double) -> <init>
    68:72:nidefawl.qubes.entity.Entity newById(int,boolean) -> do
    77:79:nidefawl.qubes.entity.Entity newInstance(boolean) -> do
    84:84:double getWidth() -> do
    87:87:double getHeight() -> if
    90:90:double getLength() -> for
    95:95:boolean isValid(int) -> do
    13:13:void <clinit>() -> <clinit>
nidefawl.qubes.entity.EntityWarrior -> iJL1L11LIjlljIll:
    10:15:void <init>(boolean) -> <init>
    19:19:nidefawl.qubes.entity.EntityType getEntityType() -> do
    24:24:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.EntityZombie -> iJ1Lllll1LiJIjll:
    10:14:void <init>(boolean) -> <init>
    18:18:nidefawl.qubes.entity.EntityType getEntityType() -> do
    23:23:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.Player -> JiIjIjL1jIL1JijI:
    java.lang.String name -> do
    int punchTicks -> case
    nidefawl.qubes.inventory.PlayerInventory inventory -> do
    nidefawl.qubes.inventory.slots.SlotsInventory slotsInventory -> do
    nidefawl.qubes.inventory.slots.SlotsCrafting[] slotsCrafting -> do
    nidefawl.qubes.inventory.PlayerInventoryCrafting[] inventoryCraft -> do
    float armOffsetPitchPrev -> this
    float armOffsetYawPrev -> void
    float armOffsetPitch -> break
    float armOffsetYaw -> catch
    16:31:void <init>(boolean) -> <init>
    34:34:java.lang.String getName() -> if
    39:57:void tickUpdate() -> do
    59:62:void updateTicks() -> byte
    66:66:nidefawl.qubes.inventory.PlayerInventory getInventory() -> do
    70:82:nidefawl.qubes.inventory.BaseInventory getInv(int) -> do
    86:98:nidefawl.qubes.inventory.slots.Slots getSlots(int) -> do
    102:109:nidefawl.qubes.models.EntityModel getEntityModel() -> do
nidefawl.qubes.entity.PlayerRemote -> jIiJiJiJllllJiL1:
    23:24:void <init>() -> <init>
    27:34:void readClientData(nidefawl.qubes.nbt.Tag) -> do
    37:63:void preStep() -> for
    66:66:void step() -> int
    69:69:void postStep() -> if
    73:74:void tickUpdate() -> do
    77:77:nidefawl.qubes.entity.EntityType getEntityType() -> do
nidefawl.qubes.entity.PlayerSelf -> jIIjL1JijIJiL1Ij:
    float forward -> super
    float strafe -> throw
    float maxSpeed -> while
    boolean fly -> new
    boolean jumped -> try
    boolean sneak -> byte
    float jump -> double
    float eyeHeight -> class
    nidefawl.qubes.PlayerProfile profile -> do
    nidefawl.qubes.network.client.ClientHandler clientHandler -> do
    nidefawl.qubes.crafting.CraftingManagerClient[] crafting -> do
    float cameraYaw -> const
    float cameraPitch -> final
    float prevCameraPitch -> float
    float prevCameraYaw -> short
    23:48:void <init>(nidefawl.qubes.network.client.ClientHandler,nidefawl.qubes.PlayerProfile) -> <init>
    50:50:nidefawl.qubes.crafting.CraftingManagerClient getCrafting(int) -> do
    54:90:void updateInputDirect(nidefawl.qubes.input.KeybindManager) -> do
    93:103:void update(float,float,float,float,float,boolean) -> do
    107:199:void tickUpdate() -> do
    201:201:boolean isDead() -> int
    204:204:boolean doesFly() -> if
    209:209:float getGravity() -> do
    213:214:void toggleFly() -> case
    217:218:void setFly(boolean) -> do
    222:222:nidefawl.qubes.entity.EntityType getEntityType() -> do
    230:234:void clicked(int,boolean) -> do
    238:240:nidefawl.qubes.item.BaseStack getActiveItem(int) -> do
    243:243:boolean findEdge() -> for
nidefawl.qubes.entity.PlayerServer -> Ij1LIjjIJiiJ1L:
    nidefawl.qubes.network.server.ServerHandlerPlay netHandler -> do
    boolean flying -> new
    int chunkX -> char
    int chunkZ -> else
    boolean chunkTracked -> try
    java.util.Set chunks -> do
    java.util.Set sendChunks -> if
    int lastLight -> goto
    java.util.UUID spawnWorld -> do
    int chunkLoadDistance -> long
    java.util.Set joinedChannels -> for
    nidefawl.qubes.world.BlockPlacer blockPlace -> do
    java.util.HashMap worldPositions -> do
    nidefawl.qubes.server.PlayerEntityTracker entTracker -> do
    nidefawl.qubes.crafting.CraftingManager[] crafting -> do
    57:78:void <init>(boolean) -> <init>
    80:80:nidefawl.qubes.crafting.CraftingManager getCrafting(int) -> do
    85:177:void tickUpdate() -> do
    180:198:void load(nidefawl.qubes.player.EntityData) -> do
    201:216:nidefawl.qubes.player.EntityData save() -> do
    221:221:int getChunkLoadDistance() -> for
    225:229:void watchingChunk(long,int,int) -> do
    232:239:void unwatchingChunk(long,int,int) -> if
    242:243:void kick(java.lang.String) -> do
    249:253:void setChunkLoadDistance(int) -> do
    258:258:java.util.Collection getJoinedChannels() -> do
    264:264:void preExecuteCommand(nidefawl.qubes.server.commands.Command) -> do
    269:275:void onError(nidefawl.qubes.server.commands.Command,nidefawl.qubes.server.commands.CommandException) -> do
    279:280:void onUnknownCommand(java.lang.String,java.lang.String) -> if
    284:284:nidefawl.qubes.server.GameServer getServer() -> do
    289:290:void sendMessage(java.lang.String) -> if
    294:294:java.lang.String getChatName() -> do
    299:300:void sendMessage(java.lang.String,java.lang.String) -> do
    303:304:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    311:313:void move(double,double,double) -> do
    317:323:nidefawl.qubes.nbt.Tag writeClientData(boolean) -> do
    328:329:nidefawl.qubes.item.BaseStack recvItem(nidefawl.qubes.item.BaseStack) -> do
    333:334:void onWorldLeave() -> case
    337:343:void syncInventory() -> char
    346:359:void updatePostTick() -> else
    362:362:nidefawl.qubes.world.WorldServer getWorld() -> do
    366:366:nidefawl.qubes.entity.EntityType getEntityType() -> do
    370:394:void jumpTo(nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.item.BlockStack,int) -> do
nidefawl.qubes.entity.ai.AIMove -> iJlliJiJIjllIjll:
    nidefawl.qubes.entity.EntityAI entity -> do
    double x -> do
    double y -> if
    double z -> for
    float speed -> do
    boolean needsUpdate -> do
    13:15:void <init>(nidefawl.qubes.entity.EntityAI) -> <init>
    18:23:void moveTowards(double,double,double,float) -> do
    25:46:void update() -> do
    49:51:float clampAngle(float,float,float) -> do
nidefawl.qubes.entity.ai.AINav -> jIlliJ1LJiL11LIj:
    nidefawl.qubes.path.PathFinder finder -> do
    nidefawl.qubes.vec.Vec3D goalPos -> do
    nidefawl.qubes.vec.Vec3D tmp -> if
    nidefawl.qubes.path.Path path -> do
    int ticks -> do
    float speed -> do
    nidefawl.qubes.entity.EntityAI entity -> do
    10:19:void <init>(nidefawl.qubes.entity.EntityAI) -> <init>
    21:27:nidefawl.qubes.path.Path tryMoveTo(int,int,int,float) -> do
    30:47:nidefawl.qubes.path.Path setPath(nidefawl.qubes.path.Path) -> do
    50:77:void update() -> do
    79:79:boolean hasPath() -> do
    82:101:void updatePath() -> if
    103:103:boolean canUpdatePath() -> if
    106:106:nidefawl.qubes.path.Path getPath() -> do
nidefawl.qubes.entity.ai.AITask -> iJjIL11L1Lll:
    nidefawl.qubes.entity.EntityAI entity -> do
    9:11:void <init>(nidefawl.qubes.entity.EntityAI) -> <init>
    14:14:boolean shouldExecute() -> do
    18:18:boolean keepExecuting() -> if
    22:22:void stop() -> do
    25:25:void start() -> if
    28:28:void update() -> for
nidefawl.qubes.entity.ai.AITaskWander -> IjllJijIjI1LJiIj:
    int ticks -> do
    nidefawl.qubes.path.RandomPosGen gen -> do
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.path.Path p -> do
    10:15:void <init>(nidefawl.qubes.entity.EntityAI) -> <init>
    19:25:boolean keepExecuting() -> if
    29:34:boolean shouldExecute() -> do
    38:39:void update() -> for
    42:44:void start() -> if
    47:49:void stop() -> do
nidefawl.qubes.entity.ai.TaskEntry -> Ji1LjIIjL1JiIjjI:
    nidefawl.qubes.entity.ai.AITask task -> do
    int priority -> do
    int mask -> if
    boolean running -> do
    boolean enabled -> if
    11:13:void <init>(nidefawl.qubes.entity.ai.AITask) -> <init>
    16:17:void setPriority(int) -> do
    23:23:int getMask() -> do
    29:30:void setRunning(boolean) -> do
    32:32:int getPriority() -> if
    35:35:boolean isEnabled() -> do
    38:39:void setEnabled(boolean) -> if
    42:42:boolean isExecuting() -> if
    46:46:boolean shouldExecute() -> for
    50:50:boolean keepExecuting() -> int
    54:56:void stop() -> do
    59:61:void start() -> if
    64:65:void update() -> for
nidefawl.qubes.entity.ai.TaskManager -> JillIjjIIjllIj1L:
    nidefawl.qubes.entity.EntityAI entity -> do
    java.util.List tasks -> do
    12:16:void <init>(nidefawl.qubes.entity.EntityAI) -> <init>
    19:22:nidefawl.qubes.entity.ai.TaskEntry add(nidefawl.qubes.entity.ai.AITask) -> do
    26:43:void update() -> do
    46:58:boolean canSchedule(nidefawl.qubes.entity.ai.TaskEntry,java.util.List) -> do
nidefawl.qubes.font.FontRenderer -> JijIiJIjlljIL1ll:
    java.util.HashMap fonts -> do
    nidefawl.qubes.font.TrueTypeFont trueTypeFont -> do
    float size -> for
    int style -> if
    int font -> for
    int maxWidth -> do
    float drawedHeight -> do
    float shadowOffset -> if
    java.lang.String[] fontNames -> do
    15:19:void destroy() -> do
    22:24:void free() -> for
    35:41:nidefawl.qubes.font.FontRenderer get(int,float,int) -> do
    56:56:void init() -> if
    30:68:void <init>(int,float,int) -> <init>
    77:86:void setupFont() -> int
    90:90:float drawString(java.lang.String,float,float,int,boolean,float) -> do
    94:112:float drawString(java.lang.String,float,float,int,boolean,float,int) -> do
    120:120:float getStringWidth(java.lang.String) -> do
    128:128:float getCharHeight() -> do
    137:137:float getLineHeight() -> if
    141:141:boolean isValid(char) -> do
    144:144:int centerY(int) -> do
    13:70:void <clinit>() -> <clinit>
nidefawl.qubes.font.IStringHistory -> L1L1iJjI1L1LIjll:
    void addHistory(java.lang.String) -> do
    int getHistorySize() -> if
    java.lang.String getHistory(int) -> do
    int indexOfHistory(java.lang.String) -> do
    void removeHistory(int) -> do
    void addHistory(int,java.lang.String) -> do
nidefawl.qubes.font.ITextEdit -> jIjIiJIjL1jIJiJi:
    void submit(nidefawl.qubes.font.TextInput) -> submit
    void onEscape(nidefawl.qubes.font.TextInput) -> onEscape
nidefawl.qubes.font.TextInput -> jIjIiJ1LJiL11L1L:
    nidefawl.qubes.font.TrueTypeFont trueType -> do
    java.lang.String editText -> do
    java.lang.String searchPattern -> if
    boolean mouseDown -> do
    boolean rightMouseDown -> if
    boolean did -> for
    int selStart -> do
    int selEnd -> if
    float shiftPX -> do
    int mpos -> for
    int tick -> int
    java.lang.String prevText -> for
    nidefawl.qubes.font.IStringHistory history -> do
    int commandScroll -> new
    boolean focused -> int
    boolean multiline -> new
    nidefawl.qubes.font.FontRenderer font -> do
    int xPos -> try
    int yPos -> byte
    int width -> case
    int height -> char
    nidefawl.qubes.font.ITextEdit itextedit -> do
    boolean use17 -> try
    19:47:void <init>(nidefawl.qubes.font.FontRenderer,nidefawl.qubes.font.ITextEdit) -> <init>
    67:68:void clearPreview() -> do
    71:95:void calculatePreview() -> if
    99:115:void onTextInput(int) -> do
    117:126:void saveHistory() -> for
    128:132:void resetInput() -> int
    134:310:boolean onKeyPress(int,int,int,int) -> do
    314:316:void onSubmit() -> try
    319:334:void makeCursorVisible() -> new
    348:348:boolean hasSelection() -> do
    353:358:java.lang.String getSelection() -> do
    363:377:java.lang.String replaceSelection(java.lang.String) -> do
    381:399:void insertTextAtCursor(java.lang.String) -> do
    401:405:void setEditText(java.lang.String) -> if
    409:603:void drawStringWithCursor(double,double,boolean) -> do
    606:610:void checkCursor() -> byte
    613:614:void onEscape() -> case
    617:617:int getLeft() -> do
    620:620:int getTop() -> if
    623:623:int getWidth() -> for
    626:626:int getHeight() -> int
    629:629:int getRight() -> new
    632:632:int getBottom() -> try
    639:640:void setHistory(nidefawl.qubes.font.IStringHistory) -> do
    49:57:void <clinit>() -> <clinit>
nidefawl.qubes.font.TrueTypeFont -> jI1LL1jIjIjI1Lll:
    int[] colorMap -> do
    int texW -> do
    int correctL -> if
    org.lwjgl.stb.STBTTPackedchar$Buffer chardata -> do
    int font_tex -> new
    org.lwjgl.stb.STBTTAlignedQuad q -> do
    org.lwjgl.stb.STBTTAlignedQuad q2 -> if
    java.nio.FloatBuffer xb -> do
    java.nio.FloatBuffer yb -> if
    java.nio.FloatBuffer xb2 -> for
    java.nio.FloatBuffer yb2 -> int
    int rangeStart -> for
    int numChars -> int
    org.lwjgl.stb.STBTTFontinfo info -> do
    float ascent -> do
    float descent -> if
    float lineGap -> for
    float drawedHeight -> int
    float spaceWidth -> new
    float lineOffset -> try
    float size -> byte
    53:56:int getControlChar(int) -> do
    63:143:void <init>(java.lang.String,float,int,boolean) -> <init>
    147:152:float getCharWidth(int) -> do
    157:186:float getWidthAtLine(java.lang.String) -> do
    189:213:float getWidth(java.lang.String) -> if
    216:218:void start(float,float) -> do
    220:220:float getXPos() -> do
    226:228:void readQuad(int) -> do
    230:234:void renderQuad(nidefawl.qubes.gl.Tess,float,float) -> do
    237:262:int getCharPositionFromXCoord(java.lang.String,double,float) -> do
    271:271:boolean isValid() -> do
    276:287:void release() -> do
    291:291:float getLineHeight() -> if
    296:296:int getTexture() -> do
    301:301:float getCharHeight() -> for
    307:426:float drawString(nidefawl.qubes.gl.Tess,float,float,java.lang.String,int,boolean,float,int,int,float) -> do
    430:433:int getIndex(int) -> if
    448:448:float getLastDrawHeight() -> int
    454:454:boolean hasCharacter(char) -> do
    25:42:void <clinit>() -> <clinit>
nidefawl.qubes.gl.AbstractTesselatorState -> iJIjjIjIiJiJ1L:
    int vertexcount -> do
    boolean useColorPtr -> do
    boolean useTexturePtr -> if
    boolean useNormalPtr -> for
    boolean useUINTPtr -> int
    10:10:void <init>() -> <init>
    19:24:void copyTo(nidefawl.qubes.gl.AbstractTesselatorState) -> do
    nidefawl.qubes.gl.GLVBO getVBO() -> do
    29:29:int getIdx(int) -> do
    33:42:int getVSize() -> do
    80:83:void drawVBO(int) -> do
    86:87:void drawQuads() -> do
    90:94:void bindAndDraw(int) -> if
    96:105:int getSetting() -> if
nidefawl.qubes.gl.BufferedMatrix -> L1JiJijIllllL11L:
    nidefawl.qubes.vec.Matrix4f inv -> do
    boolean needInv -> do
    java.nio.FloatBuffer cur -> do
    java.nio.FloatBuffer curInv -> if
    9:22:void <init>() -> <init>
    29:33:void update() -> do
    36:37:java.nio.FloatBuffer get() -> do
    41:45:java.nio.FloatBuffer getInv() -> if
    48:51:nidefawl.qubes.vec.Matrix4f getInvMat4() -> do
    55:61:void createInv() -> int
    67:71:void free() -> if
nidefawl.qubes.gl.Camera -> iJlljIIjIjJillIj:
    float pitchAngle -> do
    float bearingAngle -> if
    nidefawl.qubes.vec.Vector3f position -> do
    nidefawl.qubes.vec.Vector3f prevposition -> if
    nidefawl.qubes.vec.Vector3f viewDirection -> for
    nidefawl.qubes.vec.Matrix4f viewMatrix -> do
    nidefawl.qubes.vec.Matrix4f thirdPersonMat -> if
    nidefawl.qubes.vec.Vector3f thirdPersonOffset -> int
    boolean changed -> do
    float xshake -> for
    float yshake -> int
    float xshakeRot -> new
    float zshakeRot -> try
    float yshakeRot -> byte
    8:18:void <init>() -> <init>
    38:39:void setPosition(nidefawl.qubes.vec.Vector3f) -> do
    43:47:void setPosition(float,float,float) -> do
    52:56:void setPosition(nidefawl.qubes.vec.Vec3D) -> do
    59:76:void setOrientation(float,float,boolean,float) -> do
    78:84:void calcViewMatrix(nidefawl.qubes.vec.Matrix4f,boolean) -> do
    88:92:void addCameraShake(nidefawl.qubes.vec.Matrix4f) -> do
    98:98:nidefawl.qubes.vec.Vector3f getPosition() -> do
    105:105:nidefawl.qubes.vec.Vector3f getPrevPosition() -> if
    112:112:nidefawl.qubes.vec.Matrix4f getViewMatrix() -> do
    119:119:nidefawl.qubes.vec.Vector3f getCameraOffset() -> for
    123:130:void calcViewShake(float,float,float,float) -> do
    133:135:void updateViewDirection(nidefawl.qubes.vec.Matrix4f) -> if
    137:137:nidefawl.qubes.vec.Vector3f getViewDirection() -> int
nidefawl.qubes.gl.CubeMapCamera -> L1IjjIJiJillJiiJ:
    nidefawl.qubes.gl.BufferedMatrix projection -> do
    nidefawl.qubes.gl.BufferedMatrix view -> if
    nidefawl.qubes.gl.BufferedMatrix viewprojection -> for
    nidefawl.qubes.gl.BufferedMatrix modelviewprojection -> int
    nidefawl.qubes.vec.Matrix4f modelviewprojectionInv -> do
    nidefawl.qubes.gl.BufferedMatrix modelview -> new
    nidefawl.qubes.gl.BufferedMatrix normalMatrix -> try
    nidefawl.qubes.gl.BufferedMatrix identity -> byte
    9:9:void <init>() -> <init>
    20:32:void init() -> do
    35:96:void setupScene(int,nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.gl.Engine -> lljI1LIjIjllL1L1:
    nidefawl.qubes.vec.BlockPos GLOBAL_OFFSET -> do
    nidefawl.qubes.vec.BlockPos LAST_REPOS -> if
    java.util.Map bufferBindingPoints -> do
    int NEXT_BUFFER_BINDING_POINT -> do
    boolean initRenderers -> do
    java.nio.IntBuffer viewportBuf -> do
    java.nio.FloatBuffer position -> do
    java.nio.IntBuffer allocBuffer -> if
    nidefawl.qubes.gl.BufferedMatrix projection -> do
    nidefawl.qubes.gl.BufferedMatrix _projection -> if
    nidefawl.qubes.gl.BufferedMatrix view -> for
    nidefawl.qubes.gl.BufferedMatrix viewInvYZ -> int
    nidefawl.qubes.gl.BufferedMatrix viewprojection -> new
    nidefawl.qubes.gl.BufferedMatrix modelviewprojection -> try
    nidefawl.qubes.vec.Matrix4f modelviewprojectionInv -> if
    nidefawl.qubes.gl.BufferedMatrix modelview -> byte
    nidefawl.qubes.gl.BufferedMatrix modelmatrix -> case
    nidefawl.qubes.gl.BufferedMatrix normalMatrix -> char
    nidefawl.qubes.gl.BufferedMatrix orthoP -> else
    nidefawl.qubes.gl.BufferedMatrix orthoMV -> goto
    nidefawl.qubes.gl.BufferedMatrix orthoMVP -> long
    nidefawl.qubes.gl.BufferedMatrix ortho3DP -> this
    nidefawl.qubes.gl.BufferedMatrix ortho3DMV -> void
    nidefawl.qubes.gl.BufferedMatrix tempMatrix -> break
    nidefawl.qubes.gl.BufferedMatrix tempMatrix2 -> catch
    nidefawl.qubes.gl.BufferedMatrix identity -> class
    nidefawl.qubes.vec.Vector3f pxOffset -> do
    nidefawl.qubes.vec.TransformStack pxStack -> do
    nidefawl.qubes.vec.Matrix4f invertYZ -> do
    nidefawl.qubes.gl.FrameBuffer fbScene -> do
    float znear -> do
    float zfar -> if
    nidefawl.qubes.gl.TesselatorState[] fullscreenquads -> do
    nidefawl.qubes.gl.TesselatorState quad -> do
    nidefawl.qubes.vec.Frustum camFrustum -> do
    nidefawl.qubes.vec.Vector3f lightPosition -> if
    nidefawl.qubes.vec.Vector3f lightDirection -> for
    float sunAngle -> for
    nidefawl.qubes.gl.Camera camera -> do
    nidefawl.qubes.gl.ShadowProjector shadowProj -> do
    nidefawl.qubes.render.WorldRenderer worldRenderer -> do
    nidefawl.qubes.render.SkyRenderer skyRenderer -> do
    nidefawl.qubes.render.ShadowRenderer shadowRenderer -> do
    nidefawl.qubes.render.BlurRenderer blurRenderer -> do
    nidefawl.qubes.render.FinalRenderer outRenderer -> do
    nidefawl.qubes.render.region.RegionRenderer regionRenderer -> do
    nidefawl.qubes.particle.CubeParticleRenderer particleRenderer -> do
    nidefawl.qubes.render.LightCompute lightCompute -> do
    nidefawl.qubes.meshing.MeshThread regionRenderThread -> do
    nidefawl.qubes.models.render.QModelBatchedRender renderBatched -> do
    nidefawl.qubes.util.FastArrayList components -> do
    float aspectRatio -> int
    int fieldOfView -> if
    boolean renderWireFrame -> if
    boolean isDepthMask -> goto
    boolean isScissors -> for
    boolean isBlend -> int
    boolean updateRenderOffset -> new
    nidefawl.qubes.render.gui.SingleBlockRenderer blockRender -> do
    nidefawl.qubes.render.gui.SingleBlockDraw blockDraw -> do
    nidefawl.qubes.item.ItemRenderer itemRender -> do
    nidefawl.qubes.gl.GLVAO active -> do
    int[] viewport -> do
    nidefawl.qubes.shader.ShaderBuffer debugOutput -> do
    nidefawl.qubes.world.SunLightModel sunlightmodel -> do
    nidefawl.qubes.gl.ReallocIntBuffer[] buffers -> do
    boolean userSettingUseBindless -> try
    boolean isVAOSupportingBindless -> byte
    boolean clientStateBindlessElement -> case
    boolean clientStateBindlessAttrib -> char
    boolean isDither -> else
    118:119:void bindVAO(nidefawl.qubes.gl.GLVAO) -> do
    121:132:void bindVAO(nidefawl.qubes.gl.GLVAO,boolean) -> do
    134:142:void enableBindless() -> do
    144:152:void disableBindless() -> if
    155:167:void bindIndexBuffer(nidefawl.qubes.gl.GLVBO) -> do
    170:171:void bindBuffer(nidefawl.qubes.gl.GLVBO) -> if
    173:190:void bindBuffer(nidefawl.qubes.gl.GLVBO,int,int) -> do
    203:203:boolean checkGLError(java.lang.String) -> do
    207:239:void baseInit() -> for
    242:280:void init() -> int
    283:285:void resize(int,int) -> do
    294:369:void resizeProjection(int,int) -> if
    378:390:void resizeRenderers(int,int) -> for
    392:393:void updateOrthoMatrix(float,float) -> do
    395:417:void updateOrthoMatrix(float,float,boolean) -> do
    420:421:void drawFullscreenQuad() -> new
    423:424:void drawFSQuad(int) -> do
    427:428:void drawQuad() -> try
    435:435:nidefawl.qubes.gl.BufferedMatrix getMatSceneP() -> do
    438:438:nidefawl.qubes.gl.BufferedMatrix getMatSceneV() -> if
    441:441:nidefawl.qubes.gl.BufferedMatrix getMatSceneV_YZ_Inv() -> for
    444:444:nidefawl.qubes.gl.BufferedMatrix getMatSceneVP() -> int
    448:448:nidefawl.qubes.gl.BufferedMatrix getMatSceneMV() -> new
    452:452:nidefawl.qubes.gl.BufferedMatrix getMatSceneM() -> try
    456:456:nidefawl.qubes.gl.BufferedMatrix getMatSceneMVP() -> byte
    460:460:nidefawl.qubes.gl.BufferedMatrix getMatSceneNormal() -> case
    470:470:nidefawl.qubes.gl.BufferedMatrix getMatOrthoMVP() -> char
    473:473:nidefawl.qubes.gl.BufferedMatrix getMatOrtho3DMV() -> else
    477:477:nidefawl.qubes.gl.BufferedMatrix getMatOrtho3DP() -> goto
    481:481:nidefawl.qubes.gl.BufferedMatrix getTempMatrix() -> long
    485:485:nidefawl.qubes.gl.BufferedMatrix getTempMatrix2() -> this
    488:488:nidefawl.qubes.gl.BufferedMatrix getIdentityMatrix() -> void
    492:493:void updateCamera() -> byte
    495:498:void updateCamera(nidefawl.qubes.gl.Camera) -> do
    500:502:void updateFrustumFromInternal() -> case
    505:507:void setFrustum(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f) -> do
    509:510:void updateGlobalRenderOffset(nidefawl.qubes.vec.Vector3f) -> do
    556:561:void updateCamera(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f) -> if
    563:579:void _updateInternalMatrices() -> char
    587:593:void setViewMatrixCameraPos(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f) -> do
    595:598:void setModelMatrix(nidefawl.qubes.vec.Matrix4f) -> do
    600:603:void setViewMatrix(nidefawl.qubes.vec.Matrix4f) -> if
    607:629:boolean updateGlobalRenderOffset(float,float,float) -> do
    633:633:nidefawl.qubes.gl.FrameBuffer getSceneFB() -> do
    639:650:void flushRenderTasks() -> else
    670:673:void setLightPosition(nidefawl.qubes.vec.Vector3f) -> if
    676:679:void updateShadowProjections(float) -> do
    682:687:void stop() -> goto
    692:698:void unprojectScreenSpace(float,float,float,float,float,nidefawl.qubes.vec.Vector3f) -> do
    709:742:void registerRenderers() -> long
    745:746:java.lang.Object addComponent(nidefawl.qubes.util.IRenderComponent) -> do
    749:750:void setSceneFB(nidefawl.qubes.gl.FrameBuffer) -> do
    753:762:java.nio.IntBuffer glGenBuffers(int) -> do
    766:770:void deleteBuffers(int[]) -> do
    774:776:void toggleWireFrame() -> this
    807:812:int getBindingPoint(java.lang.String) -> do
    816:818:void enableDepthMask(boolean) -> do
    821:823:void enableScissors() -> void
    825:827:void disableScissors() -> break
    829:834:void setOverrideScissorTest(boolean) -> if
    836:841:void restoreScissorTest() -> catch
    846:846:boolean isBlend() -> do
    849:850:void restoreDepthMask() -> class
    853:854:void setOverrideDepthMask(boolean) -> for
    856:865:void setBlend(boolean) -> int
    868:877:void setViewport(int,int,int,int) -> do
    879:879:int[] getViewport() -> do
    883:884:void setDefaultViewport() -> const
    887:887:nidefawl.qubes.world.SunLightModel getSunLightModel() -> do
    891:902:nidefawl.qubes.gl.ReallocIntBuffer getIntBuffer() -> do
    34:116:void <clinit>() -> <clinit>
nidefawl.qubes.gl.Engine$1 -> L1jIL1iJIjJi1L1L:
    272:272:void <init>() -> <init>
    275:277:void onChange(nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.gl.FrameBuffer -> lliJiJL1L1lliJll:
    int FRAMEBUFFERS -> do
    int renderWidth -> if
    int renderHeight -> for
    int fb -> int
    java.nio.IntBuffer drawBufAtt -> do
    boolean hasDepth -> do
    boolean isShadowDepthBuffer -> if
    int numColorTextures -> new
    int depthTexture -> try
    int[] colorAttTextures -> do
    int[] colorAttFormats -> if
    int[] colorAttMinFilters -> for
    int[] colorAttMagFilters -> int
    boolean[] clearBuffer -> do
    float[][] clearColor -> do
    int colorTexExtFmt -> byte
    int colorTexExtType -> case
    int textureType -> char
    int depthFmt -> else
    int mipmapLevels -> goto
    int anisotropicFilterLevel -> long
    49:50:void setColorTexExtFmt(int) -> do
    55:56:void setColorTexExtType(int) -> if
    33:65:void <init>(int,int) -> <init>
    67:68:void setTextureType(int) -> for
    70:70:nidefawl.qubes.gl.FrameBuffer make(nidefawl.qubes.util.IResourceManager,int,int,int,boolean) -> do
    73:85:nidefawl.qubes.gl.FrameBuffer make(nidefawl.qubes.util.IResourceManager,int,int,int,boolean,boolean) -> do
    88:88:nidefawl.qubes.gl.FrameBuffer make(nidefawl.qubes.util.IResourceManager,int,int,int) -> do
    92:99:void setColorAtt(int,int) -> do
    103:109:void setFilter(int,int,int) -> do
    111:120:void setClearColor(int,float,float,float,float) -> do
    123:124:void setHasDepthAttachment() -> do
    127:129:void setShadowBuffer() -> if
    132:191:void setup(nidefawl.qubes.util.IResourceManager) -> do
    193:194:void bindCubeMapFace(int) -> int
    197:199:void unbindFramebuffer() -> for
    201:203:void unbindReadFramebuffer() -> int
    206:208:void bindAndClear() -> new
    210:213:void bind() -> try
    215:217:void bindRead() -> byte
    220:254:void setupTexture(int,int,int,int) -> do
    257:287:void createDepthTextureAttachment(int) -> char
    290:293:int getTexture(int) -> do
    297:300:int getDepthTex() -> do
    305:308:void clearDepth() -> case
    312:315:void clearColor() -> char
    319:324:void clearColorBlack() -> else
    328:330:void setDrawAll() -> goto
    336:352:void clearFrameBuffer() -> long
    355:374:void release() -> this
    388:388:int getWidth() -> if
    392:392:int getHeight() -> for
    395:400:void generateMipMaps(int) -> new
    405:405:int getFB() -> int
    409:409:nidefawl.qubes.util.EResourceType getType() -> do
    412:413:void setMipmapLevels(int) -> try
    415:416:void setAnisotropicFilterLevel(int) -> byte
    418:419:void setDepthFmt(int) -> case
    24:24:void <clinit>() -> <clinit>
nidefawl.qubes.gl.GL -> llJiL1IjjIiJJi1L:
    boolean directStateAccess -> do
    23:35:void bindTexture(int,int,int) -> do
    38:56:java.util.List validateCaps() -> do
    62:63:void glGetObjectParameterivARB(int,int,java.nio.IntBuffer) -> do
    65:66:void glUniformMatrix4fvARB(int,boolean,java.nio.FloatBuffer) -> do
    78:78:org.lwjgl.opengl.GLCapabilities getCaps() -> do
    81:104:void glTexStorage3D(int,int,int,int,int,int) -> do
    107:116:void glTexStorage2D(int,int,int,int,int) -> do
    119:128:int genStorage(int,int,int,int,int) -> do
    132:135:void deleteTexture(int) -> do
    137:137:boolean isBindlessSuppported() -> do
nidefawl.qubes.gl.GLAttrBuffer -> IjiJL1lliJlliJjI:
    nidefawl.qubes.gl.GLVBO vbo -> do
    int vertexCount -> do
    18:20:void <init>() -> <init>
    22:22:int getGLArrayBuffer() -> do
    27:36:int upload(nidefawl.qubes.gl.VertexBuffer) -> do
    50:50:nidefawl.qubes.gl.GLVBO getVbo() -> do
nidefawl.qubes.gl.GLDebugTextures -> IjiJjIiJIjJiL1L1:
    int format -> do
    java.lang.String name -> do
    java.lang.String pass -> if
    int h -> if
    int w -> for
    int tex -> int
    int d -> new
    int flags -> try
    boolean valid -> do
    boolean show -> if
    java.util.HashMap textures -> do
    java.util.HashMap alltextures -> if
    nidefawl.qubes.gl.GLDebugTextures selTex -> do
    boolean triggered -> for
    29:38:void <init>(java.lang.String,java.lang.String,int,int,int,int,int) -> <init>
    45:46:void readTexture(java.lang.String,java.lang.String,int) -> do
    48:79:int readTexture(java.lang.String,java.lang.String,int,int) -> do
    83:85:void release() -> int
    87:93:void onResize() -> do
    96:203:void drawAll(int,int) -> do
    206:223:void bindShader() -> if
    231:231:nidefawl.qubes.gl.GLDebugTextures getSelected() -> do
    234:234:int get() -> do
    238:244:void drawFullScreen(nidefawl.qubes.gl.GLDebugTextures) -> do
    246:246:boolean isShow() -> do
    249:250:void setShow(boolean) -> do
    253:272:void toggleDebugTex() -> for
    27:40:void <clinit>() -> <clinit>
nidefawl.qubes.gl.GLTriBuffer -> jIllJiIjIj1LL1Ij:
    nidefawl.qubes.gl.GLVBO vbo -> do
    nidefawl.qubes.gl.GLVBO vboIndices -> if
    int triCount -> do
    int vertexCount -> if
    int idxCount -> for
    23:26:void <init>(int) -> <init>
    30:44:int upload(nidefawl.qubes.gl.VertexBuffer) -> do
    51:52:void drawElements() -> do
    54:54:int getTriCount() -> do
    57:64:void draw() -> if
    70:76:void release() -> for
    81:81:int getGLArrayBuffer() -> if
    84:84:int getGLIndexBuffer() -> for
    92:92:nidefawl.qubes.gl.GLVBO getVbo() -> do
    95:95:nidefawl.qubes.gl.GLVBO getVboIndices() -> if
    98:98:int getIdxCount() -> int
nidefawl.qubes.gl.GLVAO -> Ji1LiJllllIjL1:
    int NEXT_VAO_ID -> int
    nidefawl.qubes.gl.GLVAO[] vaoList -> if
    int vaoId -> do
    int vertStride -> if
    java.util.ArrayList list -> do
    boolean useBindless -> do
    int vaoIdBindless -> for
    nidefawl.qubes.gl.GLVAO vaoBlocksShadow -> do
    nidefawl.qubes.gl.GLVAO vaoBlocksShadowTextured -> if
    nidefawl.qubes.gl.GLVAO vaoModel -> for
    nidefawl.qubes.gl.GLVAO vaoStaticModel -> int
    nidefawl.qubes.gl.GLVAO openVRModel -> new
    nidefawl.qubes.gl.GLVAO vaoModelGPUSkinned -> try
    nidefawl.qubes.gl.GLVAO vaoBlocks -> byte
    nidefawl.qubes.gl.GLVAO vaoBlocksBindless -> case
    nidefawl.qubes.gl.GLVAO[] vaoTesselator -> do
    19:25:void <init>() -> <init>
    27:33:void initVAOs() -> do
    60:61:void vertexAttribFormat(int,int,int,boolean,int) -> do
    63:64:void vertexAttribIFormat(int,int,int,int) -> do
    67:67:void init() -> if
    69:106:void setup() -> for
    253:253:boolean isBindless() -> do
    14:250:void <clinit>() -> <clinit>
nidefawl.qubes.gl.GLVAO$1 -> lljIiJjIL1jIjIll:
    108:108:void <init>() -> <init>
    111:112:void init() -> if
nidefawl.qubes.gl.GLVAO$2 -> L1Ji1LJillll1LIj:
    114:114:void <init>() -> <init>
    118:125:void init() -> if
nidefawl.qubes.gl.GLVAO$3 -> iJL1llIjJi1LiJIj:
    127:127:void <init>() -> <init>
    132:141:void init() -> if
nidefawl.qubes.gl.GLVAO$4 -> L11L1LJiJi1LL11L:
    143:143:void <init>() -> <init>
    146:151:void init() -> if
nidefawl.qubes.gl.GLVAO$5 -> lljIIjjIllL1iJll:
    153:153:void <init>() -> <init>
    156:162:void init() -> if
nidefawl.qubes.gl.GLVAO$6 -> jIL1Ji1LlliJIjll:
    164:164:void <init>() -> <init>
    168:183:void init() -> if
nidefawl.qubes.gl.GLVAO$7 -> IjIjIjIj1LjIJiIj:
    185:185:void <init>() -> <init>
    189:200:void init() -> if
nidefawl.qubes.gl.GLVAO$8 -> L1iJJillJiIjjIIj:
    203:203:void <init>() -> <init>
    207:220:void init() -> if
nidefawl.qubes.gl.GLVAO$9 -> iJ1L1LIjiJ:
    boolean val$useNormalPtr -> do
    boolean val$useTexturePtr -> if
    boolean val$useColorPtr -> for
    boolean val$useUINTPtr -> int
    230:230:void <init>(boolean,boolean,boolean,boolean) -> <init>
    233:247:void init() -> if
nidefawl.qubes.gl.GLVAO$VertexAttrib -> jIIjIjjI1LJiL1L1:
    int attribindex -> do
    int size -> if
    int type -> for
    boolean normalized -> do
    int intLen -> int
    boolean isFloat -> if
    long offset -> do
    42:49:void <init>(boolean,int,int,int,boolean,int) -> <init>
    50:56:void <init>(boolean,int,int,int,int) -> <init>
    34:34:boolean access$000(nidefawl.qubes.gl.GLVAO$VertexAttrib) -> do
nidefawl.qubes.gl.GLVBO -> jIjIIjiJjI1LJiiJ:
    int ALLOC_VBOS -> do
    int ALLOC_VBOS_TERRAIN -> if
    int vboId -> for
    long vboSize -> do
    int usage -> int
    long addr -> if
    long size -> for
    boolean canUseBindless -> do
    boolean isTerrain -> if
    17:27:void <init>(int) -> <init>
    29:30:void setTerrain(boolean) -> do
    36:43:int getVboId() -> do
    52:53:void upload(int,java.nio.ByteBuffer,long) -> do
    55:87:void upload(int,java.nio.ByteBuffer,long,boolean) -> do
    89:99:void makeResident(int,boolean,boolean) -> do
    101:112:void release() -> do
    14:15:void <clinit>() -> <clinit>
nidefawl.qubes.gl.GPUVendor -> IjJiIjjIiJIjiJ1L:
    nidefawl.qubes.gl.GPUVendor NVIDIA -> do
    nidefawl.qubes.gl.GPUVendor AMD -> if
    nidefawl.qubes.gl.GPUVendor INTEL -> for
    nidefawl.qubes.gl.GPUVendor OTHER -> int
    nidefawl.qubes.gl.GPUVendor[] $VALUES -> do
    10:10:nidefawl.qubes.gl.GPUVendor[] values() -> values
    10:10:nidefawl.qubes.gl.GPUVendor valueOf(java.lang.String) -> valueOf
    10:10:void <init>(java.lang.String,int) -> <init>
    18:36:nidefawl.qubes.gl.GPUVendor parse(java.lang.String) -> do
    10:11:void <clinit>() -> <clinit>
nidefawl.qubes.gl.Memory -> IjJi1LiJIjL1IjJi:
    int mallocd -> do
    java.util.HashSet ptrs -> do
    25:30:java.nio.FloatBuffer createFloatBuffer(int) -> do
    34:39:java.nio.IntBuffer createIntBuffer(int) -> do
    52:57:java.nio.DoubleBuffer createDoubleBuffer(int) -> do
    61:61:java.nio.FloatBuffer createFloatBufferAligned(int,int) -> do
    70:80:java.nio.ByteBuffer createByteBufferAligned(int,int) -> do
    90:94:java.nio.ByteBuffer reallocByteBufferAligned(java.nio.ByteBuffer,int,int) -> do
    102:104:java.nio.IntBuffer createIntBufferGC(int) -> if
    111:119:void free(java.nio.FloatBuffer) -> do
    125:133:void free(java.nio.ByteBuffer) -> do
    136:137:java.nio.IntBuffer createIntBufferHeap(int) -> for
    145:146:java.nio.FloatBuffer createFloatBufferHeap(int) -> if
    20:22:void <clinit>() -> <clinit>
nidefawl.qubes.gl.MultiDrawIndirectBuffer -> lllllliJIjIjL1ll:
    java.nio.ByteBuffer buffers -> do
    java.nio.IntBuffer intbuffers -> do
    int[] heapBuffer -> do
    int pos -> do
    int drawCount -> if
    int stride -> for
    nidefawl.qubes.gl.GLVAO vao -> do
    22:33:void <init>() -> <init>
    37:52:void reallocBuffer(int) -> do
    84:112:void add(nidefawl.qubes.gl.GLVBO,nidefawl.qubes.gl.GLVBO,int) -> do
    116:118:int putLong(int[],int,long) -> do
    122:127:void preDraw(nidefawl.qubes.gl.GLVAO) -> do
    129:129:int getDrawCount() -> do
    132:149:void render() -> do
nidefawl.qubes.gl.PositionMouseOver -> L1L11LiJIjjIL1Ji:
    nidefawl.qubes.vec.Vector3f vDir -> do
    nidefawl.qubes.vec.Vector3f vOrigin -> if
    nidefawl.qubes.vec.Vector3f vDirTmp -> for
    nidefawl.qubes.vec.Vector3f vTarget -> int
    nidefawl.qubes.vec.Vector3f t -> new
    8:14:void <init>() -> <init>
    17:35:void updateMouseFromScreenPos(float,float,float,float,nidefawl.qubes.vec.Vector3f) -> do
    38:58:void updateFromController(int,float) -> do
    61:62:void reset() -> do
nidefawl.qubes.gl.ReallocIntBuffer -> iJllIjJiJiIjllll:
    java.nio.ByteBuffer buffers -> do
    java.nio.IntBuffer intbuffers -> do
    boolean inUse -> do
    19:20:void setInUse(boolean) -> do
    22:22:boolean isInUse() -> do
    17:32:void <init>(int) -> <init>
    17:38:void <init>() -> <init>
    41:53:void reallocBuffer(int) -> do
    55:60:void release() -> do
    75:80:void put(int[],int,int) -> do
    86:86:java.nio.ByteBuffer getByteBuf() -> do
nidefawl.qubes.gl.ShadowProjector -> llllIjllL1llJiIj:
    nidefawl.qubes.vec.Matrix4f[] shadowSplitProj -> do
    nidefawl.qubes.gl.BufferedMatrix[] shadowSplitMVP -> do
    float[] shadowSplitDepth -> do
    nidefawl.qubes.vec.Frustum[] shadowCamFrustum -> do
    nidefawl.qubes.vec.Matrix4f newMat -> do
    nidefawl.qubes.vec.Matrix4f newMatInv -> if
    nidefawl.qubes.vec.Matrix4f matLookAt -> for
    nidefawl.qubes.vec.Matrix4f matLookAtInv -> int
    nidefawl.qubes.vec.Matrix4f matOrtho -> new
    nidefawl.qubes.vec.Vector3f frustumCenter -> do
    nidefawl.qubes.vec.Vector3f tmp -> if
    nidefawl.qubes.vec.Vector3f eye -> for
    nidefawl.qubes.vec.Vector3f[] furstumCornersIn -> do
    nidefawl.qubes.vec.Vector3f[] furstumCornersOut -> if
    14:41:void <init>() -> <init>
    53:66:void init() -> do
    69:158:void calcShadow(int,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,float) -> do
    161:164:void calcSplits(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,float) -> do
    166:166:int checkFrustum(int,nidefawl.qubes.vec.AABBInt,float) -> do
    175:175:java.nio.FloatBuffer getSMVP(int) -> do
    195:206:void updateProjection(float,float,float,float) -> do
    211:216:void release() -> if
    220:220:void preinit() -> for
    31:31:void <clinit>() -> <clinit>
nidefawl.qubes.gl.Tess -> JijIL1jIL1lllliJ:
    java.lang.String[] attributes -> do
    boolean littleEndian -> new
    nidefawl.qubes.gl.Tess instance -> do
    nidefawl.qubes.gl.Tess tessFont -> if
    int[] rawBuffer -> do
    int rgba -> if
    int uintLSB -> for
    int uintMSB -> int
    float u -> do
    float v -> if
    int normal -> new
    float offsetX -> for
    float offsetY -> int
    float offsetZ -> new
    boolean isSoftTesselator -> try
    nidefawl.qubes.gl.ReallocIntBuffer bufInt -> do
    int vboIdx -> try
    nidefawl.qubes.gl.GLVBO[] vbo -> do
    45:46:void <init>() -> <init>
    25:55:void <init>(boolean) -> <init>
    58:58:boolean isSoftTesselator() -> do
    62:69:void add(float,float,float,float,float) -> do
    81:82:void add(float,float) -> do
    85:93:void setNormals(float,float,float) -> do
    96:126:void add(float,float,float) -> if
    130:134:void resizeBuffer() -> if
    138:153:void setColorRGBAF(float,float,float,float) -> do
    156:161:void setUIntLSB(int) -> for
    170:179:void setColor(int,int) -> do
    182:183:void setColorF(int,float) -> do
    186:207:void draw(int,nidefawl.qubes.gl.AbstractTesselatorState) -> do
    210:210:nidefawl.qubes.gl.GLVBO getVBO() -> do
    214:215:void draw(int) -> int
    219:220:void drawQuads() -> do
    225:232:void resetState() -> for
    235:239:void destroy() -> int
    242:245:void setOffset(float,float,float) -> for
    248:250:void destroyAll() -> new
    252:253:void add(nidefawl.qubes.vec.Vector4f) -> do
    255:256:void add(nidefawl.qubes.vec.Vector3f) -> do
    11:21:void <clinit>() -> <clinit>
nidefawl.qubes.gl.TesselatorState -> JiL1jIIjllL1iJ:
    nidefawl.qubes.gl.GLVBO vbo -> do
    6:8:void <init>(int) -> <init>
    11:11:nidefawl.qubes.gl.GLVBO getVBO() -> do
nidefawl.qubes.gl.VertexBuffer -> llL1L1jIll1LjIiJ:
    int[] buffer -> do
    int[] triIdxBuffer -> if
    int triIdxPos -> do
    int pos -> if
    int left -> for
    int left2 -> int
    int vertexCount -> new
    12:33:void <init>(int) -> <init>
    39:44:void reset() -> do
    51:57:int realloc(int) -> do
    64:70:int reallocTriIdxBuffer(int) -> if
    76:83:void put(int) -> do
    85:93:void putIdx(int) -> if
    98:99:void increaseVert() -> if
    104:104:int getVertexCount() -> do
    110:110:int getPos() -> if
    116:116:int getTriIdxPos() -> for
    122:122:int[] get() -> do
    128:128:int[] getTriIdxBuffer() -> if
    136:137:int storeVertexData(nidefawl.qubes.gl.ReallocIntBuffer) -> do
    144:145:int storeIndexData(nidefawl.qubes.gl.ReallocIntBuffer) -> if
    164:169:void putTriVertIndex(int[],int,int) -> do
nidefawl.qubes.gui.AbstractUI -> jIIjIjjIjIIjL1ll:
    nidefawl.qubes.gui.AbstractUI parent -> parent
    int id -> id
    int width -> width
    int height -> height
    int posX -> posX
    int posY -> posY
    int[] overridebounds -> overridebounds
    boolean hovered -> hovered
    boolean enabled -> enabled
    boolean draw -> draw
    boolean focused -> focused
    int zIndex -> zIndex
    nidefawl.qubes.gui.AbstractUI selectedButton -> selectedButton
    int color -> color
    float alpha -> alpha
    int color2 -> color2
    float alpha2 -> alpha2
    int color3 -> color3
    float alpha3 -> alpha3
    int color4 -> color4
    int color5 -> color5
    int color6 -> color6
    float alpha4 -> alpha4
    float boxSigma -> boxSigma
    float shadowSigma -> shadowSigma
    float round -> round
    int extendx -> extendx
    int extendy -> extendy
    16:103:void <init>() -> <init>
    31:35:void saveBounds() -> saveBounds
    37:41:void restoreBounds() -> restoreBounds
    43:45:void setSize(int,int) -> setSize
    47:49:void setPos(int,int) -> setPos
    52:52:int right() -> right
    56:56:int bottom() -> bottom
    59:59:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> hasElement
    62:62:void add(nidefawl.qubes.gui.AbstractUI) -> add
    65:65:void update() -> update
    68:68:boolean mouseOver(double,double) -> mouseOver
    72:72:boolean handleMouseUp(nidefawl.qubes.gui.Gui,int) -> handleMouseUp
    75:75:boolean handleMouseDown(nidefawl.qubes.gui.Gui,int) -> handleMouseDown
    78:78:boolean onKeyPress(int,int,int,int) -> onKeyPress
    81:81:boolean onTextInput(int) -> onTextInput
    85:86:void setFocus() -> setFocus
    105:110:void resetShape() -> resetShape
    113:140:void renderRoundedBoxShadow(float,float,float,float,float,int,float,boolean) -> renderRoundedBoxShadow
    142:167:void renderRoundedBoxShadowInverse(float,float,float,float,float,int,float,boolean) -> renderRoundedBoxShadowInverse
    169:184:void renderOutlinedBox() -> renderOutlinedBox
    186:193:void renderBox() -> renderBox
    196:196:void renderBox(boolean,boolean,int,int,int) -> renderBox
    198:218:void renderBox(boolean,boolean,int,int) -> renderBox
    220:240:void renderBox2(boolean,boolean,int,int) -> renderBox2
    242:242:int getWindowPosX() -> getWindowPosX
    245:245:int getWindowPosY() -> getWindowPosY
    248:254:nidefawl.qubes.gui.windows.GuiWindow findParentWindow() -> findParentWindow
    258:271:void renderSlotBackground(float,float,float,float,float,int,float,boolean,float) -> renderSlotBackground
    275:328:void renderSlots(nidefawl.qubes.inventory.slots.Slots,float,double,double,float,float) -> renderSlots
    330:336:void renderSlotOverlay(nidefawl.qubes.inventory.slots.Slot,float,float) -> renderSlotOverlay
    339:341:void setDisableDraw(boolean) -> setDisableDraw
nidefawl.qubes.gui.Gui -> jIjIL1IjL1:
    java.util.ArrayList buttons -> buttons
    java.util.ArrayList prebackground -> prebackground
    boolean firstOpen -> firstOpen
    boolean isFullscreen -> isFullscreen
    nidefawl.qubes.gui.AbstractUI popup -> popup
    int slotW -> slotW
    int slotBDist -> slotBDist
    int titleBarHeight -> titleBarHeight
    int titleBarOffset -> titleBarOffset
    boolean RENDER_BACKGROUNDS -> RENDER_BACKGROUNDS
    int FONT_SIZE_WINDOW_TITLE -> FONT_SIZE_WINDOW_TITLE
    int FONT_SIZE_BUTTON -> FONT_SIZE_BUTTON
    nidefawl.qubes.font.FontRenderer titleFont -> titleFont
    nidefawl.qubes.font.FontRenderer font -> font
    25:43:void <init>() -> <init>
    47:47:nidefawl.qubes.gui.AbstractUI getPopup() -> getPopup
    50:50:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> hasElement
    53:56:void add(nidefawl.qubes.gui.AbstractUI) -> add
    58:62:void addBackground(nidefawl.qubes.gui.AbstractUI) -> addBackground
    64:64:nidefawl.qubes.gui.AbstractUI getElement(int) -> getElement
    67:69:void clearElements() -> clearElements
    71:82:void sortElements() -> sortElements
    85:89:void remove(nidefawl.qubes.gui.AbstractUI) -> remove
    92:100:void setPopup(nidefawl.qubes.gui.AbstractUI) -> setPopup
    103:110:void renderBackgroundElements(float,double,double) -> renderBackgroundElements
    112:143:void renderButtons(float,double,double) -> renderButtons
    146:150:void update() -> update
    153:153:void onClose() -> onClose
    156:195:boolean onMouseClick(int,int) -> onMouseClick
    199:199:double mouseOffsetY() -> mouseOffsetY
    203:203:double mouseOffsetX() -> mouseOffsetX
    207:207:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    211:228:boolean onKeyPress(int,int,int,int) -> onKeyPress
    232:233:void close() -> close
    236:244:boolean onTextInput(int) -> onTextInput
    248:248:boolean requiresTextInput() -> requiresTextInput
    254:331:void renderFrame(float,double,double) -> renderFrame
    334:339:void renderBackground(float,double,double,boolean,float) -> renderBackground
    342:342:java.lang.String getTitle() -> getTitle
    346:346:boolean hasFocus() -> hasFocus
    349:349:void updateBounds() -> updateBounds
    352:352:boolean canResize() -> canResize
    356:356:boolean onWheelScroll(double,double) -> onWheelScroll
    359:359:double mouseGetX() -> mouseGetX
    362:362:double mouseGetY() -> mouseGetY
    365:366:void render3D(float,double,double) -> render3D
    368:379:boolean mouseOver(double,double) -> mouseOver
    34:36:void <clinit>() -> <clinit>
nidefawl.qubes.gui.Gui$1 -> JiiJiJ1LjIiJ1LiJ:
    nidefawl.qubes.gui.Gui this$0 -> do
    71:71:void <init>(nidefawl.qubes.gui.Gui) -> <init>
    74:77:int compare(nidefawl.qubes.gui.AbstractUI,nidefawl.qubes.gui.AbstractUI) -> do
    71:71:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.gui.GuiAction -> L1L1lliJjIIjiJIj:
    int mouseAction -> do
    17:17:boolean isAct(int) -> do
    15:15:void <clinit>() -> <clinit>
nidefawl.qubes.gui.GuiBG -> jIllllllL1L1jI1L:
    5:5:void <init>() -> <init>
    9:13:void render(float,double,double) -> render
    17:17:void initGui(boolean) -> initGui
nidefawl.qubes.gui.GuiCached -> Jill1LJijIIjiJll:
    nidefawl.qubes.gui.Gui gui -> do
    nidefawl.qubes.gl.FrameBuffer fbDbg -> do
    boolean refresh -> do
    18:20:void <init>(nidefawl.qubes.gui.Gui) -> <init>
    23:25:void setPos(int,int) -> setPos
    29:40:void setSize(int,int) -> setSize
    43:58:void render(float,double,double) -> render
    60:62:void refresh() -> do
    65:65:void initGui(boolean) -> initGui
nidefawl.qubes.gui.GuiChatInput -> ll1L1LjI1LJiiJll:
    nidefawl.qubes.gui.controls.TextField field -> do
    nidefawl.qubes.gui.GuiOverlayChat overlay -> do
    int mouseResize -> do
    26:28:void <init>() -> <init>
    34:37:void setSize(int,int) -> setSize
    41:65:void initGui(boolean) -> initGui
    69:69:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    74:76:boolean onKeyPress(int,int,int,int) -> onKeyPress
    81:89:boolean onMouseClick(int,int) -> onMouseClick
    93:98:boolean over(double,double) -> do
    108:129:void render(float,double,double) -> render
    133:142:void submit(nidefawl.qubes.font.TextInput) -> submit
    146:147:void onEscape(nidefawl.qubes.font.TextInput) -> onEscape
    150:150:boolean requiresTextInput() -> requiresTextInput
nidefawl.qubes.gui.GuiConnecting -> JijIjIIjIjiJJi:
    java.lang.String stateStr -> do
    nidefawl.qubes.network.client.ThreadConnect thread -> do
    10:14:void <init>() -> <init>
    17:19:void <init>(nidefawl.qubes.network.client.ThreadConnect) -> <init>
    23:31:void initGui(boolean) -> initGui
    34:39:void update() -> update
    42:48:void render(float,double,double) -> render
    51:55:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
nidefawl.qubes.gui.GuiControls -> IjiJiJ1LL1iJIjL1:
    nidefawl.qubes.gui.GuiControls$Control selected -> do
    nidefawl.qubes.gui.controls.Button back -> do
    java.util.List list -> do
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
    nidefawl.qubes.gui.controls.Button clear -> if
    nidefawl.qubes.gui.controls.Button cancel -> for
    nidefawl.qubes.gui.controls.Button defaultSet -> int
    nidefawl.qubes.input.Keybinding inUseKey -> do
    98:183:void <init>(nidefawl.qubes.gui.Gui) -> <init>
    113:169:void initGui(boolean) -> initGui
    172:175:boolean onMouseClick(int,int) -> onMouseClick
    179:181:void update() -> update
    185:185:java.lang.String getTitle() -> getTitle
    188:244:void render(float,double,double) -> render
    247:271:boolean onKeyPress(int,int,int,int) -> onKeyPress
    277:314:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    317:321:boolean onWheelScroll(double,double) -> onWheelScroll
nidefawl.qubes.gui.GuiControls$Control -> IjJiIjll1LllJiJi:
    nidefawl.qubes.input.Keybinding b -> do
    30:32:void <init>(nidefawl.qubes.input.Keybinding) -> <init>
    36:92:void render(float,double,double) -> render
    96:96:void initGui(boolean) -> initGui
    22:22:nidefawl.qubes.input.Keybinding access$000(nidefawl.qubes.gui.GuiControls$Control) -> do
nidefawl.qubes.gui.GuiDisconnected -> JiiJjIllIjiJ1L:
    java.lang.String reason -> do
    10:12:void <init>() -> <init>
    15:17:void <init>(java.lang.String) -> <init>
    21:29:void initGui(boolean) -> initGui
    32:38:void render(float,double,double) -> render
    41:44:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
nidefawl.qubes.gui.GuiGameMenu -> L1IjlliJ1L1L1LiJ:
    nidefawl.qubes.gui.controls.Button resume -> do
    nidefawl.qubes.gui.controls.Button settings -> if
    nidefawl.qubes.gui.controls.Button controls -> for
    nidefawl.qubes.gui.controls.Button back -> int
    nidefawl.qubes.gui.controls.Button quit -> new
    21:22:void <init>() -> <init>
    24:40:void renderBackground(float,double,double,boolean,float) -> renderBackground
    44:122:void initGui(boolean) -> initGui
    124:126:void render(float,double,double) -> render
    128:164:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    168:168:boolean requiresTextInput() -> requiresTextInput
nidefawl.qubes.gui.GuiLoadingServer -> JijIiJL11LiJ1L1L:
    9:11:void <init>() -> <init>
    15:16:void initGui(boolean) -> initGui
    19:25:void render(float,double,double) -> render
    29:33:void update() -> update
nidefawl.qubes.gui.GuiMainMenu -> iJJiiJ1L1LjIIjiJ:
    nidefawl.qubes.gui.controls.TextField fieldN -> do
    nidefawl.qubes.gui.controls.Button singleplayer -> do
    nidefawl.qubes.gui.controls.Button multiplayer -> if
    nidefawl.qubes.gui.controls.Button settings -> for
    nidefawl.qubes.gui.controls.Button controls -> int
    nidefawl.qubes.gui.controls.Button quit -> new
    24:26:void <init>() -> <init>
    29:29:java.lang.String getTitle() -> getTitle
    33:111:void initGui(boolean) -> initGui
    114:125:void render(float,double,double) -> render
    127:147:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    151:152:void submit(nidefawl.qubes.font.TextInput) -> submit
    157:164:void startSinglePlayer() -> do
    167:171:void onEscape(nidefawl.qubes.font.TextInput) -> onEscape
    174:174:boolean requiresTextInput() -> requiresTextInput
nidefawl.qubes.gui.GuiMultiplayer -> jIjIjIIjL1L11L:
    nidefawl.qubes.font.FontRenderer font -> do
    nidefawl.qubes.gui.controls.TextField field -> do
    nidefawl.qubes.gui.controls.Button connect -> do
    nidefawl.qubes.gui.controls.Button back -> if
    17:21:void <init>(nidefawl.qubes.gui.GuiMainMenu) -> <init>
    25:52:void initGui(boolean) -> initGui
    55:57:void render(float,double,double) -> render
    59:65:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    69:70:void submit(nidefawl.qubes.font.TextInput) -> submit
    75:81:void connect() -> do
    84:88:void onEscape(nidefawl.qubes.font.TextInput) -> onEscape
    91:91:boolean requiresTextInput() -> requiresTextInput
nidefawl.qubes.gui.GuiOverlayChat -> jIL1JiL1iJllJijI:
    boolean mouseRes -> do
    19:20:void <init>() -> <init>
    24:41:void render(float,double,double) -> render
    45:45:void initGui(boolean) -> initGui
    54:106:void renderAt(int,int,boolean) -> do
nidefawl.qubes.gui.GuiOverlayStats -> L1JiiJJijIJill:
    nidefawl.qubes.font.FontRenderer statsFontBig -> do
    nidefawl.qubes.font.FontRenderer statsFontSmall -> if
    java.util.ArrayList info1 -> do
    java.util.ArrayList info -> if
    java.lang.String stats -> if
    java.lang.String statsRight -> for
    long messageTime -> do
    java.lang.String message -> do
    boolean render -> do
    java.lang.String stats5 -> int
    nidefawl.qubes.util.SysInfo sysInfo -> do
    29:42:void <init>() -> <init>
    45:145:void refresh() -> do
    148:220:void render(float,double,double) -> render
    223:225:void setMessage(java.lang.String) -> do
    229:229:void initGui(boolean) -> initGui
    236:243:void blockClicked(nidefawl.qubes.util.RayTrace$RayTraceIntersection) -> do
nidefawl.qubes.gui.GuiSelectBlock -> IjllIjIjllIj1LiJ:
    java.util.List blocks -> do
    nidefawl.qubes.gui.controls.Button fakeButton -> do
    nidefawl.qubes.item.BlockStack sel -> do
    float dir -> do
    float rot -> if
    float lastRot -> for
    33:84:void <init>() -> <init>
    38:80:void initGui(boolean) -> initGui
    86:93:void update() -> update
    97:257:void render(float,double,double) -> render
    260:267:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
nidefawl.qubes.gui.GuiSelectWorld -> L11LL1llL11L1LJi:
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
    java.util.ArrayList list -> do
    nidefawl.qubes.gui.controls.Button back -> do
    int REQ_ID -> do
    56:61:void <init>() -> <init>
    65:65:java.lang.String getTitle() -> getTitle
    69:89:void initGui(boolean) -> initGui
    92:107:void fillList(java.util.ArrayList) -> do
    109:109:boolean onMouseClick(int,int) -> onMouseClick
    113:123:void render(float,double,double) -> render
    126:135:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    139:142:boolean onKeyPress(int,int,int,int) -> onKeyPress
    145:146:boolean onWheelScroll(double,double) -> onWheelScroll
    149:151:void update() -> update
    58:58:void <clinit>() -> <clinit>
nidefawl.qubes.gui.GuiSelectWorld$WorldListControl -> llIjIjjIjIiJlljI:
    nidefawl.qubes.io.network.WorldInfo info -> do
    25:27:void <init>(int,nidefawl.qubes.io.network.WorldInfo) -> <init>
    31:48:void render(float,double,double) -> render
    52:52:void initGui(boolean) -> initGui
    20:20:nidefawl.qubes.io.network.WorldInfo access$000(nidefawl.qubes.gui.GuiSelectWorld$WorldListControl) -> do
nidefawl.qubes.gui.GuiSettings -> iJJiIjL1IjjI1LiJ:
    int nextID -> do
    nidefawl.qubes.gui.controls.Button back -> do
    java.util.List list -> do
    nidefawl.qubes.gui.GuiSettings$Setting gui3dSetting -> do
    nidefawl.qubes.gui.GuiSettings$Setting distanceSetting -> if
    nidefawl.qubes.gui.GuiSettings$Setting shadowSetting -> for
    nidefawl.qubes.gui.GuiSettings$Setting reflectionSetting -> int
    nidefawl.qubes.gui.GuiSettings$Setting smaaSetting -> new
    nidefawl.qubes.gui.GuiSettings$Setting smaaQSetting -> try
    nidefawl.qubes.gui.GuiSettings$Setting aoSetting -> byte
    nidefawl.qubes.gui.GuiSettings$Setting normalMappingSetting -> case
    nidefawl.qubes.gui.GuiSettings$Setting anisotropySetting -> char
    44:57:void <init>(nidefawl.qubes.gui.Gui) -> <init>
    61:183:void initGui(boolean) -> initGui
    186:186:java.lang.String getTitle() -> getTitle
    189:200:void render(float,double,double) -> render
    203:224:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    21:21:void <clinit>() -> <clinit>
nidefawl.qubes.gui.GuiSettings$1 -> jIjI1L1Lll1LL1ll:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    67:67:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    69:73:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$10 -> JiL1iJJiJiL1IjJi:
    nidefawl.qubes.gui.GuiSettings$Setting val$s -> do
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    207:207:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.GuiSettings$Setting) -> <init>
    211:216:void call(nidefawl.qubes.gui.controls.ComboBox$ComboBoxList,int) -> call
nidefawl.qubes.gui.GuiSettings$2 -> IjL11LIjJillL1iJ:
    java.lang.Integer[] val$values -> do
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    82:82:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[],java.lang.Integer[]) -> <init>
    84:87:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$3 -> ll1LIjL11LJiiJIj:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    90:90:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    92:96:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$4 -> lliJL11LJijIjI1L:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    99:99:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    101:105:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$5 -> jIjIiJIjIjJiJiL1:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    108:108:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    110:114:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$6 -> IjIjL11LjI1L1LjI:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    116:116:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    118:120:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$7 -> llJijIJijIllll:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    123:123:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    125:128:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$8 -> L11LIjllIjIjL1jI:
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    132:132:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    134:137:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$9 -> jIjIllIjJi1L1LIj:
    float val$f -> do
    nidefawl.qubes.gui.GuiSettings this$0 -> do
    149:149:void <init>(nidefawl.qubes.gui.GuiSettings,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[],float) -> <init>
    151:162:void callback(int) -> do
nidefawl.qubes.gui.GuiSettings$Setting -> IjlllllljIiJL1L1:
    java.lang.Object[] vals -> do
    nidefawl.qubes.gui.controls.ComboBox box -> do
    32:37:void <init>(nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    40:40:void callback(int) -> do
nidefawl.qubes.gui.GuiShutdownServer -> llL11LjIIjIjIjIj:
    9:11:void <init>() -> <init>
    15:16:void initGui(boolean) -> initGui
    19:25:void render(float,double,double) -> render
    29:33:void update() -> update
nidefawl.qubes.gui.LoadingScreen -> IjiJjIiJjIiJJi1L:
    float[] loadProgress -> do
    19:22:void <init>() -> <init>
    25:25:boolean render(int,float) -> do
    29:108:boolean setProgress(int,float,java.lang.String) -> do
nidefawl.qubes.gui.Tooltip -> L1jIjIL11L1LiJll:
    nidefawl.qubes.gui.windows.GuiWindow window -> do
    nidefawl.qubes.gui.Tooltip$ItemToolTip item -> do
    10:10:void <init>() -> <init>
    63:63:nidefawl.qubes.gui.windows.GuiWindow getTooltipOwner() -> do
    60:60:void <clinit>() -> <clinit>
nidefawl.qubes.gui.Tooltip$1 -> JijI1LjIlljIJiIj:
    60:60:void <init>() -> <init>
nidefawl.qubes.gui.Tooltip$ItemToolTip -> L1jIiJIjjIiJllll:
    nidefawl.qubes.item.BaseStack stack -> do
    nidefawl.qubes.inventory.slots.Slot slot -> do
    java.lang.String title -> do
    nidefawl.qubes.font.FontRenderer fr -> do
    nidefawl.qubes.font.FontRenderer fr2 -> if
    12:12:void <init>() -> <init>
    20:38:nidefawl.qubes.gui.Tooltip$ItemToolTip set(nidefawl.qubes.item.BaseStack,nidefawl.qubes.inventory.slots.Slot,nidefawl.qubes.gui.windows.GuiWindow) -> do
    42:53:void render(float,double,double) -> render
    57:57:void initGui(boolean) -> initGui
nidefawl.qubes.gui.controls.Button -> jIIjIjllL11LiJiJ:
    java.lang.String text -> do
    nidefawl.qubes.font.FontRenderer font -> do
    16:20:void <init>(int,java.lang.String) -> <init>
    24:52:void render(float,double,double) -> render
    57:57:void initGui(boolean) -> initGui
nidefawl.qubes.gui.controls.CheckBox -> JiIjiJIjjIIjIj:
    boolean checked -> do
    java.lang.String text -> do
    nidefawl.qubes.font.FontRenderer font -> do
    float stringWidth -> do
    float titleWidth -> if
    boolean drawTitle -> if
    boolean titleLeft -> for
    int colorDisabled -> do
    int textColorDisabled -> if
    18:33:void <init>(int,java.lang.String) -> <init>
    37:104:void render(float,double,double) -> render
    109:109:void initGui(boolean) -> initGui
nidefawl.qubes.gui.controls.ColorPicker -> llL1llL1iJ1LllJi:
    nidefawl.qubes.gui.controls.Button[] colorPick -> do
    float valH -> do
    float valS -> if
    float valL -> for
    int rgb -> do
    12:18:void <init>(nidefawl.qubes.gui.Gui) -> <init>
    22:74:void render(float,double,double) -> render
    void onColorChange(int) -> do
    80:97:void initGui(boolean) -> initGui
    101:106:boolean hasElement(nidefawl.qubes.gui.AbstractUI) -> hasElement
nidefawl.qubes.gui.controls.ComboBox -> L11LL1iJIjJiIj1L:
    nidefawl.qubes.font.FontRenderer font -> do
    int textColorDisabled -> do
    int textColorHover -> if
    int textColor -> for
    float r -> do
    float g -> if
    float b -> for
    float a -> int
    java.lang.Object value -> do
    float stringWidth -> new
    boolean isOpen -> do
    int sel -> int
    int id -> new
    java.lang.String string -> do
    boolean drawTitle -> if
    boolean titleLeft -> for
    boolean canexpandHorizontally -> int
    int maxWidthClosed -> try
    int titleWidth -> byte
    nidefawl.qubes.gui.controls.ComboBox$ComboBoxList comboBoxList -> do
    nidefawl.qubes.gui.Gui gui -> do
    int scrollbarwidth -> case
    24:55:void <init>(nidefawl.qubes.gui.Gui,int,java.lang.String) -> <init>
    57:58:void setValue(java.lang.Object) -> do
    73:73:void initGui(boolean) -> initGui
    367:368:void setWatchPopup(nidefawl.qubes.gui.controls.ComboBox$ComboBoxList) -> do
    389:458:void render(float,double,double) -> render
    464:478:boolean onClick(nidefawl.qubes.gui.controls.PopupHolder) -> do
    21:21:nidefawl.qubes.font.FontRenderer access$000(nidefawl.qubes.gui.controls.ComboBox) -> do
    46:46:void <clinit>() -> <clinit>
nidefawl.qubes.gui.controls.ComboBox$CallBack -> jI1LIj1LL11LiJjI:
    void call(nidefawl.qubes.gui.controls.ComboBox$ComboBoxList,int) -> call
nidefawl.qubes.gui.controls.ComboBox$ComboBoxList -> IjjIJiiJL1iJllJi:
    nidefawl.qubes.gui.controls.PopupHolder parentScreen -> do
    nidefawl.qubes.gui.controls.ComboBox$CallBack callBack -> do
    nidefawl.qubes.gui.controls.ComboBox box -> do
    java.lang.Object[] values -> do
    int size -> if
    int heightPerEntry -> for
    boolean showScrollBar -> if
    int scrollOffset -> int
    int showMax -> do
    boolean isScrolling -> do
    int scrollBeginY -> new
    85:109:void <init>(nidefawl.qubes.gui.controls.ComboBox$CallBack,nidefawl.qubes.gui.controls.PopupHolder,nidefawl.qubes.gui.controls.ComboBox,java.lang.Object[]) -> <init>
    113:114:void initGui(boolean) -> initGui
    117:150:boolean onKeyPress(int,int,int,int) -> onKeyPress
    158:174:boolean mouseOver(double,double) -> mouseOver
    181:186:boolean handleMouseDown(nidefawl.qubes.gui.Gui,int) -> handleMouseDown
    195:363:void render(float,double,double) -> render
nidefawl.qubes.gui.controls.PopupHolder -> jIjIIjL1JiJiJiIj:
    void setPopup(nidefawl.qubes.gui.AbstractUI) -> setPopup
    nidefawl.qubes.gui.AbstractUI getPopup() -> getPopup
nidefawl.qubes.gui.controls.ProgressBar -> jIjI1LL1iJIjL11L:
    float progress -> do
    float lastProgress -> if
    nidefawl.qubes.font.FontRenderer fr -> do
    java.lang.String s -> do
    9:17:void <init>() -> <init>
    21:23:void update() -> update
    27:55:void render(float,double,double) -> render
    59:59:void initGui(boolean) -> initGui
    62:64:void setProgress(float) -> do
    75:76:void setText(java.lang.String) -> do
nidefawl.qubes.gui.controls.ScrollList -> L1jIjIiJJiJi:
    float scrollOffset -> do
    nidefawl.qubes.gui.controls.Button scrollbarbutton -> do
    float scrollY -> if
    19:21:void <init>(nidefawl.qubes.gui.Gui) -> <init>
    14:24:void <init>() -> <init>
    42:50:float getContentHeight() -> do
    55:141:void render(float,double,double) -> render
    145:145:void initGui(boolean) -> initGui
    148:154:boolean onMouseClick(int,int) -> onMouseClick
    158:161:boolean onWheelScroll(double,double) -> onWheelScroll
    165:170:double mouseOffsetY() -> mouseOffsetY
    174:174:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
nidefawl.qubes.gui.controls.TextField -> IjIjJiJiIjjIlljI:
    nidefawl.qubes.font.TextInput inputRenderer -> do
    25:30:void <init>(nidefawl.qubes.font.ITextEdit,int,java.lang.String) -> <init>
    34:37:void setPos(int,int) -> setPos
    41:44:void setSize(int,int) -> setSize
    47:63:void render(float,double,double) -> render
    66:66:boolean mouseOver(double,double) -> mouseOver
    72:72:void initGui(boolean) -> initGui
    75:75:boolean handleMouseUp(nidefawl.qubes.gui.Gui,int) -> handleMouseUp
    79:87:boolean handleMouseDown(nidefawl.qubes.gui.Gui,int) -> handleMouseDown
    91:95:boolean onKeyPress(int,int,int,int) -> onKeyPress
    99:103:boolean onTextInput(int) -> onTextInput
    107:107:java.lang.String getText() -> do
    114:114:nidefawl.qubes.font.TextInput getTextInput() -> do
    118:131:boolean isFocusedAndContext() -> do
nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry -> jIiJL1jIJiiJiJL1:
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    nidefawl.qubes.gui.crafting.GuiRecipeOutPreviewItemSlot slotPreview -> do
    nidefawl.qubes.gui.controls.ProgressBar progress -> do
    int n -> do
    nidefawl.qubes.crafting.CraftingManagerClient mgr -> do
    20:29:void <init>(nidefawl.qubes.crafting.CraftingManagerClient) -> <init>
    34:78:void render(float,double,double) -> render
    82:103:void initGui(boolean) -> initGui
    106:106:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    110:112:void updateState() -> do
    115:117:void update() -> update
    120:131:void updateProgress() -> if
    134:134:nidefawl.qubes.item.BaseStack getStack() -> do
    138:138:long getEndTime() -> do
    142:142:nidefawl.qubes.crafting.CraftingManagerClient getMgr() -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect -> L1L1L11LjIJi1L:
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$RecipeSlot selected -> do
    nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry selected2 -> do
    nidefawl.qubes.gui.GuiBG bg -> do
    nidefawl.qubes.gui.controls.ScrollList scr2 -> do
    java.util.List catButtons -> do
    nidefawl.qubes.gui.controls.TextField txtAmount -> do
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat cat -> do
    nidefawl.qubes.gui.controls.Button btnCraft -> do
    nidefawl.qubes.gui.controls.Button btnIncr -> if
    nidefawl.qubes.gui.controls.Button btnDecr -> for
    nidefawl.qubes.gui.controls.Button btnMax -> int
    float entryw -> do
    int cols -> do
    38:45:void <init>() -> <init>
    348:348:java.lang.String getTitle() -> getTitle
    356:424:void initGui(boolean) -> initGui
    427:454:void setCat(nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat) -> do
    457:492:void initLists(boolean,int) -> do
    495:497:boolean onMouseClick(int,int) -> onMouseClick
    501:508:void update() -> update
    529:530:void renderFrame(float,double,double) -> renderFrame
    532:583:void render(float,double,double) -> render
    586:589:boolean onKeyPress(int,int,int,int) -> onKeyPress
    595:670:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    673:680:void startcraft(nidefawl.qubes.gui.crafting.GuiCraftingSelect$RecipeSlot,int) -> do
    682:696:void updateProgress() -> do
    698:719:void layoutList() -> if
    721:722:void onRemoteUpdate(nidefawl.qubes.crafting.CraftingManagerClient,int) -> do
    743:760:void renderSlotOverlay(nidefawl.qubes.inventory.slots.Slot,float,float) -> renderSlotOverlay
    800:811:void setRecipe(nidefawl.qubes.gui.crafting.GuiCraftingSelect$RecipeSlot) -> do
    813:818:void showButtons(boolean) -> do
    820:823:boolean onWheelScroll(double,double) -> onWheelScroll
    827:827:void submit(nidefawl.qubes.font.TextInput) -> submit
    830:830:void onEscape(nidefawl.qubes.font.TextInput) -> onEscape
    38:38:nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat access$000(nidefawl.qubes.gui.crafting.GuiCraftingSelect) -> do
    57:58:void <clinit>() -> <clinit>
nidefawl.qubes.gui.crafting.GuiCraftingSelect$1 -> jIJiiJ1LjIiJ1LL1:
    nidefawl.qubes.gui.crafting.GuiCraftingSelect this$0 -> do
    701:701:void <init>(nidefawl.qubes.gui.crafting.GuiCraftingSelect) -> <init>
    705:707:int compare(nidefawl.qubes.gui.AbstractUI,nidefawl.qubes.gui.AbstractUI) -> do
    701:701:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat -> L1L1jIIj1LjIll:
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat category -> do
    int catid -> do
    82:85:void <init>(int,nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat,nidefawl.qubes.crafting.CraftingCategory) -> <init>
    87:87:nidefawl.qubes.gui.controls.ScrollList getScrollList() -> do
    90:90:nidefawl.qubes.gui.controls.Button getScrollbarButton() -> do
    95:160:void render(float,double,double) -> render
    163:163:nidefawl.qubes.crafting.CraftingManagerClient getCraftingManager() -> do
    76:76:int access$300(nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiButtonCat) -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat -> IjL1IjiJ1LllL1ll:
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
    java.util.List list -> do
    nidefawl.qubes.crafting.CraftingCategory craftingCategory -> do
    nidefawl.qubes.crafting.CraftingManagerClient craftingClient -> do
    61:74:void <init>(nidefawl.qubes.crafting.CraftingCategory) -> <init>
    59:59:nidefawl.qubes.crafting.CraftingManagerClient access$100(nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat) -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlSubCat -> lljIL1llIjL1JiIj:
    java.lang.String string -> do
    java.util.List list -> if
    boolean expanded -> do
    int rows -> do
    java.util.List slots -> do
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat parentCat -> do
    255:267:void <init>(nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat,java.lang.String,java.util.List) -> <init>
    271:307:void render(float,double,double) -> render
    311:327:void initGui(boolean) -> initGui
    330:342:int layout() -> do
    252:252:nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlCat access$200(nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlSubCat) -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect$PreviewSlots -> IjjIL11LllL1jI1L:
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    nidefawl.qubes.inventory.BaseInventory baseInv -> do
    nidefawl.qubes.inventory.BaseInventory playerInv -> if
    768:784:void <init>(int,nidefawl.qubes.gui.GuiBG,nidefawl.qubes.crafting.recipes.CraftingRecipe,nidefawl.qubes.inventory.PlayerInventory,nidefawl.qubes.inventory.BaseInventory) -> <init>
    786:791:void update() -> do
    795:795:nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
nidefawl.qubes.gui.crafting.GuiCraftingSelect$RecipeSlot -> JiL11LJi1LL1JijI:
    nidefawl.qubes.crafting.recipes.CraftingRecipe recipe -> do
    int maxAmount -> do
    nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlSubCat guiControlSubCat -> do
    170:175:void <init>(nidefawl.qubes.gui.crafting.GuiCraftingSelect$GuiControlSubCat,nidefawl.qubes.crafting.recipes.CraftingRecipe) -> <init>
    179:179:void initGui(boolean) -> initGui
    182:192:void update() -> update
    196:249:void render(float,double,double) -> render
nidefawl.qubes.gui.crafting.GuiRecipeOutPreviewItemSlot -> llL1jI1LL1Jillll:
    nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry ctrl -> do
    17:20:void <init>(nidefawl.qubes.gui.crafting.GuiCraftingProgressEntry) -> <init>
    24:24:void initGui(boolean) -> initGui
    28:92:void render(float,double,double) -> render
nidefawl.qubes.gui.windows.GuiColor -> ll1LjIiJiJJijIL1:
    nidefawl.qubes.gui.controls.ColorPicker colorPick -> do
    19:20:void <init>() -> <init>
    22:22:java.lang.String getTitle() -> getTitle
    26:78:void initGui(boolean) -> initGui
    80:80:boolean canResize() -> canResize
    84:90:void render(float,double,double) -> render
    96:99:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
nidefawl.qubes.gui.windows.GuiColor$1 -> Ij1LjIiJjIlliJ1L:
    nidefawl.qubes.gui.windows.GuiColor this$0 -> do
    27:27:void <init>(nidefawl.qubes.gui.windows.GuiColor,nidefawl.qubes.gui.Gui) -> <init>
    30:60:void onColorChange(int) -> do
nidefawl.qubes.gui.windows.GuiContext -> iJ1LIjIjL11LIjL1:
    nidefawl.qubes.gui.controls.TextField input -> do
    nidefawl.qubes.gui.controls.ScrollList scrolllist -> do
    double mouseX -> do
    double mouseY -> if
    boolean hasOverride -> do
    nidefawl.qubes.gui.windows.GuiWindow mouseOverOverride -> do
    boolean canDragWindows -> if
    boolean canWindowsFocusChange -> for
    8:15:void <clinit>() -> <clinit>
nidefawl.qubes.gui.windows.GuiInventory -> L1L1JijIjIjIjIJi:
    10:11:void <init>() -> <init>
    13:13:java.lang.String getTitle() -> getTitle
    17:36:void initGui(boolean) -> initGui
    39:42:void render(float,double,double) -> render
nidefawl.qubes.gui.windows.GuiInventoryResult -> jIllllL1jI1LjIjI:
    nidefawl.qubes.inventory.slots.Slots slots -> do
    42:52:java.lang.Class getWindowClass(int) -> do
    57:58:void <init>() -> <init>
    int getInventory() -> do
    61:61:java.lang.String getTitle() -> getTitle
    65:93:void initGui(boolean) -> initGui
    96:104:void render(float,double,double) -> render
    108:112:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    117:133:boolean onMouseClick(int,int) -> onMouseClick
nidefawl.qubes.gui.windows.GuiInventoryResult$GuiInventoryResult1 -> JilljIIjiJL11L1L:
    17:17:void <init>() -> <init>
    20:20:int getInventory() -> do
nidefawl.qubes.gui.windows.GuiInventoryResult$GuiInventoryResult2 -> IjlliJjIJiL11LjI:
    23:23:void <init>() -> <init>
    26:26:int getInventory() -> do
nidefawl.qubes.gui.windows.GuiInventoryResult$GuiInventoryResult3 -> iJiJIjiJIjjIJijI:
    29:29:void <init>() -> <init>
    32:32:int getInventory() -> do
nidefawl.qubes.gui.windows.GuiInventoryResult$GuiInventoryResult4 -> iJIjIjJiiJL1jIll:
    35:35:void <init>() -> <init>
    38:38:int getInventory() -> do
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract -> JiIjjIjIJiL1Ijll:
    int nextID -> do
    java.util.List list -> do
    java.util.List listDyn -> if
    nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$Setting testSetting -> do
    nidefawl.qubes.models.EntityModel entityModel -> do
    int modelidx -> if
    nidefawl.qubes.models.qmodel.QModelProperties properties -> do
    boolean isPlayerAdjust() -> do
    160:170:void <init>() -> <init>
    175:179:void reloadModel() -> do
    182:223:void setModel(nidefawl.qubes.models.EntityModel,nidefawl.qubes.models.qmodel.QModelProperties) -> do
    227:283:void initGui(boolean) -> initGui
    286:324:int layout() -> do
    329:337:void render(float,double,double) -> render
    414:414:java.lang.String getTitle() -> getTitle
    418:459:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    464:476:boolean onKeyPress(int,int,int,int) -> onKeyPress
    480:489:void setModel(int) -> do
    35:35:void <clinit>() -> <clinit>
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$1 -> Ij1LiJIjiJL1iJJi:
    java.util.List val$l -> do
    nidefawl.qubes.gui.windows.GuiModelAdjustAbstract this$0 -> do
    244:244:void <init>(nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,java.lang.String,java.lang.Object,java.lang.Object[],java.util.List) -> <init>
    246:257:void callback(int) -> do
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$2 -> iJjIJi1LJiJiiJll:
    java.util.List val$l -> do
    nidefawl.qubes.gui.windows.GuiModelAdjustAbstract this$0 -> do
    267:267:void <init>(nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,java.lang.String,java.lang.Object,java.lang.Object[],java.util.List) -> <init>
    269:274:void callback(int) -> do
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$3 -> L1llJi1LiJlliJjI:
    nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$Setting val$s -> do
    nidefawl.qubes.gui.windows.GuiModelAdjustAbstract this$0 -> do
    442:442:void <init>(nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$Setting) -> <init>
    446:451:void call(nidefawl.qubes.gui.controls.ComboBox$ComboBoxList,int) -> call
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$GuiModelView -> L1L1jIjIjIL1IjJi:
    36:36:void <init>() -> <init>
    39:39:boolean isPlayerAdjust() -> do
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$GuiPlayerAdjust -> llll1LJiL11LJiiJ:
    42:42:void <init>() -> <init>
    45:45:boolean isPlayerAdjust() -> do
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$ModelActionList -> L1iJL1IjjIllL1Ij:
    nidefawl.qubes.models.EntityModel entityModel -> do
    int idx -> if
    124:142:void <init>(nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,nidefawl.qubes.models.EntityModel,int) -> <init>
    145:156:void callback(int) -> do
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$ModelSettingControl -> IjJiJiIjIjL1jIIj:
    nidefawl.qubes.models.ModelOption option -> do
    84:85:void <init>(nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,nidefawl.qubes.models.ModelOption) -> <init>
    86:97:void <init>(nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,nidefawl.qubes.models.ModelOption,java.lang.String) -> <init>
    100:111:void callback(int) -> do
    74:74:nidefawl.qubes.models.ModelOption access$000(nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$ModelSettingControl) -> do
nidefawl.qubes.gui.windows.GuiModelAdjustAbstract$Setting -> JiJijI1LL1jIIj1L:
    java.lang.Object[] vals -> do
    nidefawl.qubes.gui.controls.ComboBox box -> do
    nidefawl.qubes.gui.controls.Button button1 -> do
    nidefawl.qubes.gui.controls.Button button2 -> if
    int curVal -> do
    nidefawl.qubes.gui.windows.GuiModelAdjustAbstract gui -> if
    50:58:void <init>() -> <init>
    50:68:void <init>(nidefawl.qubes.gui.windows.GuiModelAdjustAbstract,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    71:71:void callback(int) -> do
nidefawl.qubes.gui.windows.GuiWindow -> L1Ji1Lllll1LL1iJ:
    boolean allwaysVisible -> allwaysVisible
    boolean visible -> visible
    boolean mouseOverResize -> mouseOverResize
    int[] bounds -> bounds
    13:14:void <init>() -> <init>
    17:23:void initGui(boolean) -> initGui
    25:25:java.lang.String getTitle() -> getTitle
    29:32:void onDefocus() -> onDefocus
    35:35:void onFocus() -> onFocus
    39:40:void setFocus() -> setFocus
    43:43:boolean hasFocus() -> hasFocus
    46:50:void open() -> open
    53:56:void close() -> close
    59:61:void onClose() -> onClose
    64:74:boolean mouseOver(double,double) -> mouseOver
    77:77:boolean mouseOverResize(double,double) -> mouseOverResize
    81:81:boolean removeOnClose() -> removeOnClose
    86:86:boolean doesPopupHandleClick(double,double) -> doesPopupHandleClick
    90:90:void updateBounds() -> updateBounds
    93:93:boolean canResize() -> canResize
    98:123:void onDrag(double,double) -> onDrag
    125:138:void onResize(double,double) -> onResize
    140:170:boolean onMouseClick(int,int) -> onMouseClick
    173:173:int getWindowPosX() -> getWindowPosX
    176:176:int getWindowPosY() -> getWindowPosY
    179:181:void render3D(float,double,double) -> render3D
nidefawl.qubes.gui.windows.GuiWindowInventoryBase -> L1IjjIIjL1JijIjI:
    nidefawl.qubes.inventory.slots.Slots slots -> do
    9:9:void <init>() -> <init>
    15:18:void renderSlots(float,double,double) -> do
    20:32:boolean onMouseClick(int,int) -> onMouseClick
    35:35:boolean canResize() -> canResize
nidefawl.qubes.gui.windows.GuiWindowManager -> IjJiIjiJIjllJijI:
    nidefawl.qubes.gui.windows.GuiWindowManager singleton -> do
    java.util.Map windowList -> do
    nidefawl.qubes.gui.windows.GuiWindow windowFocus -> for
    nidefawl.qubes.gui.windows.GuiWindow dragged -> do
    nidefawl.qubes.gui.windows.GuiWindow resized -> if
    nidefawl.qubes.gui.Tooltip tooltip -> do
    19:19:void <init>() -> <init>
    24:24:nidefawl.qubes.gui.windows.GuiWindowManager getInstance() -> do
    28:59:void setWindowFocus(nidefawl.qubes.gui.windows.GuiWindow) -> do
    62:90:void do_setWindowFocus(nidefawl.qubes.gui.windows.GuiWindow) -> if
    92:97:int getHighestIndex() -> do
    123:142:nidefawl.qubes.gui.windows.GuiWindow openWindow(java.lang.Class,boolean) -> do
    146:146:nidefawl.qubes.gui.windows.GuiWindow openWindow(java.lang.Class) -> do
    150:155:java.lang.Object getWindow(java.lang.Class) -> do
    159:163:boolean anyWindowVisible() -> do
    167:171:void closeAll() -> do
    175:179:nidefawl.qubes.gui.windows.GuiWindow addWindow(nidefawl.qubes.gui.windows.GuiWindow,boolean) -> do
    252:253:void render(float,double,double) -> render
    256:316:void drawWindows(float,double,double) -> do
    318:322:void renderTooltip(float,double,double) -> if
    326:331:void setTooltip(nidefawl.qubes.gui.Tooltip) -> do
    333:333:nidefawl.qubes.gui.Tooltip getTooltip() -> do
    338:338:void initGui(boolean) -> initGui
    355:355:nidefawl.qubes.gui.windows.GuiWindow getWindowFocus() -> do
    358:369:boolean onMouseClick(int,int) -> do
    372:389:nidefawl.qubes.gui.windows.GuiWindow getMouseOver(double,double) -> do
    392:400:void mouseMove(double,double) -> do
    403:407:boolean onKeyPress(int,int,int,int) -> do
    411:415:boolean onWheelScroll(double,double) -> do
    419:443:void onWindowClosed(nidefawl.qubes.gui.windows.GuiWindow) -> for
    447:447:void onWindowManagerClose() -> if
    454:457:void onWindowOpened(nidefawl.qubes.gui.windows.GuiWindow) -> int
    459:464:void update() -> for
    20:198:void <clinit>() -> <clinit>
nidefawl.qubes.hex.HexCell -> lliJIjll1LIjJiJi:
    int x -> do
    int z -> if
    nidefawl.qubes.hex.HexagonGridStorage grid -> do
    20:24:void <init>(nidefawl.qubes.hex.HexagonGridStorage,int,int) -> <init>
    26:30:double getDistanceCenter(double,double) -> do
    34:34:double getCenterX() -> do
    38:38:double getCenterY() -> if
    60:80:int getClosesCorner(double,double) -> do
    87:87:nidefawl.qubes.hex.HexagonGridStorage getGrid() -> do
    91:199:java.util.Collection getChunks() -> do
nidefawl.qubes.hex.HexagonGrid -> iJllL1IjIjllllll:
    double radius -> do
    double height -> if
    double width -> for
    double hwidth -> int
    double ttheight -> new
    double[] sinCos -> do
    int[] offset -> do
    21:38:void <init>(double) -> <init>
    41:41:long blockToGrid(int,int) -> do
    45:53:long toHex(double,double) -> do
    57:57:double getCenterX(int,int) -> do
    61:61:double getCenterY(int,int) -> if
    65:65:double getPointX(int,int,int) -> do
    68:68:double getPointY(int,int,int) -> if
    111:111:long offset(int,int,int) -> do
    22:22:void <clinit>() -> <clinit>
nidefawl.qubes.hex.HexagonGridStorage -> L1L1jIjIllL1Ijll:
    int max -> do
    java.util.HashMap map -> do
    java.util.HashMap oobmap -> if
    26:31:void <init>(double,int) -> <init>
    39:40:void putPos(long,java.lang.Object) -> do
    43:60:java.lang.Object getPos(long) -> do
    64:66:boolean outOfBounds(long) -> do
    70:71:java.lang.Object blockToHex(int,int) -> do
    java.lang.Object loadCell(int,int) -> if
    java.lang.Object oobCell(int,int) -> for
    80:80:java.util.Collection getLoaded() -> do
    84:84:void flag(int,int) -> do
nidefawl.qubes.hex.Point2F -> JiiJjIlliJL1Ij1L:
    float x -> do
    float y -> if
    25:28:void <init>(double,double) -> <init>
nidefawl.qubes.input.CameraController -> llL1JijIJiL1iJjI:
    nidefawl.qubes.vec.Vec3D pos -> do
    nidefawl.qubes.vec.Vec3D lastPos -> if
    nidefawl.qubes.vec.Vec3D mot -> for
    nidefawl.qubes.vec.Vec3D lastMot -> int
    float yaw -> do
    float lastYaw -> if
    float pitch -> for
    float lastPitch -> int
    float forward -> new
    float strafe -> try
    float maxSpeed -> byte
    float jump -> case
    boolean sneak -> do
    15:25:void <init>() -> <init>
    34:42:void update(nidefawl.qubes.input.KeybindManager) -> do
    44:51:void updateVR() -> do
    54:64:void update(float,float,float,float,float,boolean) -> do
    67:113:void tickUpdate() -> if
    117:126:void move() -> for
    129:133:void set(float,float,float,float,float) -> do
    135:137:nidefawl.qubes.vec.Vector3f getRenderPos(float) -> do
nidefawl.qubes.input.DigController -> lljIIjjIL1iJjIL1:
    int stage -> do
    boolean digging -> do
    int speed -> if
    int tick -> for
    nidefawl.qubes.vec.BlockPos mouseOver -> do
    nidefawl.qubes.vec.BlockPos lastMouseOver -> if
    nidefawl.qubes.util.RayTrace$RayTraceIntersection intersect -> do
    int transaction -> int
    int[] stageTex -> do
    24:159:void <init>() -> <init>
    64:64:boolean isDigAnimation() -> do
    71:73:void onGrabChange(boolean) -> do
    81:85:void endDigging() -> new
    91:91:void preRenderUpdate() -> do
    94:111:void update() -> if
    114:120:boolean equalMouseOver() -> if
    125:135:void sendDigState(int) -> if
    138:147:void setBlock(nidefawl.qubes.util.RayTrace$RayTraceIntersection,nidefawl.qubes.vec.BlockPos) -> do
    156:156:void init() -> for
    161:165:void reloadTextures() -> int
    235:235:void renderDigging(nidefawl.qubes.world.World,float) -> do
    239:243:float getSwingProgress(float) -> do
    247:253:void handleServerState(int) -> do
nidefawl.qubes.input.GameMode -> jIJiIj1L1LiJllll:
    nidefawl.qubes.input.GameMode PLAY -> do
    nidefawl.qubes.input.GameMode BUILD -> if
    nidefawl.qubes.input.GameMode EDIT -> for
    nidefawl.qubes.input.GameMode SELECT -> int
    nidefawl.qubes.input.GameMode[] $VALUES -> do
    6:6:nidefawl.qubes.input.GameMode[] values() -> values
    6:6:nidefawl.qubes.input.GameMode valueOf(java.lang.String) -> valueOf
    6:6:void <init>(java.lang.String,int) -> <init>
    6:7:void <clinit>() -> <clinit>
nidefawl.qubes.input.KeybindManager -> iJjIjI1LL1iJIjJi:
    nidefawl.qubes.config.AbstractYMLConfig settings -> do
    nidefawl.qubes.input.Keybinding kb_forward -> do
    nidefawl.qubes.input.Keybinding kb_backward -> if
    nidefawl.qubes.input.Keybinding kb_left -> for
    nidefawl.qubes.input.Keybinding kb_right -> int
    nidefawl.qubes.input.Keybinding kb_sneak -> new
    nidefawl.qubes.input.Keybinding kb_jump -> try
    float strafe -> do
    float forward -> if
    boolean grabbed -> do
    int mX -> do
    int mY -> if
    boolean jump -> if
    boolean sneak -> for
    java.util.Map keyToKeyBinding -> do
    java.util.ArrayList keybindings -> do
    java.util.concurrent.ConcurrentMap keybindingsStr -> do
    float SPEED_MODIFIER -> for
    42:78:void <init>() -> <init>
    107:109:void addKeyBinding(nidefawl.qubes.input.Keybinding) -> do
    111:111:nidefawl.qubes.input.Keybinding getKeyBindingByName(java.lang.String) -> do
    114:119:void updateKeybindMap() -> do
    122:122:nidefawl.qubes.input.Keybinding getKeyBinding(int) -> do
    126:160:void update(double,double) -> do
    163:163:boolean isKeyDown(int) -> do
    167:176:void setGrabbed(boolean) -> do
    179:179:boolean grabbed() -> do
    183:375:void initKeybinds() -> if
    379:387:void load() -> for
    389:397:void saveBindings() -> int
    399:399:java.util.Collection getBindings() -> do
    44:102:void <clinit>() -> <clinit>
nidefawl.qubes.input.KeybindManager$1 -> IjllIjllllIjIjIj:
    44:44:void <init>(boolean) -> <init>
    48:48:void setDefaults() -> do
    52:55:void save() -> for
    59:69:void load() -> if
nidefawl.qubes.input.KeybindManager$10 -> iJjIJiL1iJllIjIj:
    233:233:void <init>(java.lang.String,int) -> <init>
    235:236:void onDown() -> do
nidefawl.qubes.input.KeybindManager$11 -> Ji1LllIjjIiJjI:
    238:238:void <init>(java.lang.String,int) -> <init>
    240:241:void onDown() -> do
nidefawl.qubes.input.KeybindManager$12 -> llL1iJiJlljIL1:
    nidefawl.qubes.Game val$game -> do
    243:243:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    249:253:void onDown() -> do
nidefawl.qubes.input.KeybindManager$13 -> L1JiJi1LIjllL1Ji:
    nidefawl.qubes.Game val$game -> do
    255:255:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    257:264:void onDown() -> do
nidefawl.qubes.input.KeybindManager$14 -> llIjllIj1LiJiJll:
    266:266:void <init>(java.lang.String,int) -> <init>
    268:269:void onDown() -> do
nidefawl.qubes.input.KeybindManager$15 -> L1jIllJiiJiJllll:
    271:271:void <init>(java.lang.String,int) -> <init>
    273:274:void onDown() -> do
nidefawl.qubes.input.KeybindManager$16 -> iJllL1JiiJIjJill:
    276:276:void <init>(java.lang.String,int) -> <init>
    278:279:void onDown() -> do
nidefawl.qubes.input.KeybindManager$17 -> llIjL1iJjIjIJill:
    281:281:void <init>(java.lang.String,int) -> <init>
    283:284:void onDown() -> do
nidefawl.qubes.input.KeybindManager$18 -> JiL1L11LL11LIj1L:
    nidefawl.qubes.Game val$game -> do
    286:286:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    288:290:void onDown() -> do
nidefawl.qubes.input.KeybindManager$19 -> JiIjjI1LJijIjIjI:
    nidefawl.qubes.Game val$game -> do
    292:292:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    294:295:void onDown() -> do
nidefawl.qubes.input.KeybindManager$2 -> IjllJiL1JijI1LL1:
    nidefawl.qubes.Game val$game -> do
    185:185:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    187:189:void onDown() -> do
nidefawl.qubes.input.KeybindManager$20 -> jIL1Ijll1LiJJiIj:
    297:297:void <init>(java.lang.String,int) -> <init>
    300:302:void onDown() -> do
nidefawl.qubes.input.KeybindManager$21 -> iJIjjIjI1LL1IjL1:
    nidefawl.qubes.Game val$game -> do
    304:304:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    306:307:void onDown() -> do
nidefawl.qubes.input.KeybindManager$22 -> llJiiJiJ1LllJi1L:
    309:309:void <init>(java.lang.String,int) -> <init>
    311:312:void onDown() -> do
nidefawl.qubes.input.KeybindManager$23 -> jIllL1llIjJiiJL1:
    314:314:void <init>(java.lang.String,int) -> <init>
    319:323:void onDown() -> do
nidefawl.qubes.input.KeybindManager$24 -> llIjL11LiJIj1LjI:
    325:325:void <init>(java.lang.String,int) -> <init>
    328:329:void onDown() -> do
nidefawl.qubes.input.KeybindManager$25 -> IjJiJijIL1IjiJL1:
    nidefawl.qubes.Game val$game -> do
    331:331:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    333:335:void onDown() -> do
nidefawl.qubes.input.KeybindManager$26 -> iJjI1LjIL11LjIIj:
    339:339:void <init>(java.lang.String,int) -> <init>
    341:342:void onDown() -> do
nidefawl.qubes.input.KeybindManager$27 -> IjIjllll1LL11L1L:
    345:345:void <init>(java.lang.String,int) -> <init>
    347:349:void onDown() -> do
nidefawl.qubes.input.KeybindManager$28 -> Ji1L1LJi1LL1Jill:
    351:351:void <init>(java.lang.String,int) -> <init>
    353:354:void onDown() -> do
nidefawl.qubes.input.KeybindManager$29 -> IjllJilliJL1jIIj:
    nidefawl.qubes.Game val$game -> do
    356:356:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    358:363:void onDown() -> do
nidefawl.qubes.input.KeybindManager$3 -> llL1iJL1L11LL1Ji:
    nidefawl.qubes.Game val$game -> do
    191:191:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    193:194:void onDown() -> do
nidefawl.qubes.input.KeybindManager$30 -> iJ1LllL1L1lljIL1:
    365:365:void <init>(java.lang.String,int) -> <init>
    367:368:void onRepeat() -> if
nidefawl.qubes.input.KeybindManager$31 -> JiL1L1JiiJjIIj:
    370:370:void <init>(java.lang.String,int) -> <init>
    372:373:void onRepeat() -> if
nidefawl.qubes.input.KeybindManager$4 -> L1IjiJIjJiJill1L:
    nidefawl.qubes.Game val$game -> do
    196:196:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    198:200:void onDown() -> do
nidefawl.qubes.input.KeybindManager$5 -> llllJiJiL1iJllL1:
    nidefawl.qubes.Game val$game -> do
    202:202:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    204:209:void onDown() -> do
nidefawl.qubes.input.KeybindManager$6 -> iJiJIjL1llllIjll:
    nidefawl.qubes.Game val$game -> do
    211:211:void <init>(java.lang.String,int,nidefawl.qubes.Game) -> <init>
    213:214:void onDown() -> do
nidefawl.qubes.input.KeybindManager$7 -> iJiJiJIjIjJiIjll:
    216:216:void <init>(java.lang.String,int) -> <init>
    218:219:void onDown() -> do
nidefawl.qubes.input.KeybindManager$8 -> llllIjllllIjllJi:
    222:222:void <init>(java.lang.String,int) -> <init>
    224:225:void onDown() -> do
nidefawl.qubes.input.KeybindManager$9 -> IjjIL1Ji1LJijI1L:
    228:228:void <init>(java.lang.String,int) -> <init>
    230:231:void onDown() -> do
nidefawl.qubes.input.Keybinding -> jIIjiJjI1LIjIjiJ:
    boolean enabled -> do
    int key -> do
    boolean isPressed -> if
    java.lang.String name -> do
    boolean hasCallback -> for
    boolean staticBinding -> int
    int defaultkey -> if
    16:26:void <init>(java.lang.String,int) -> <init>
    28:28:int getDefaultkey() -> do
    31:32:nidefawl.qubes.input.Keybinding setNoCallBack() -> do
    36:37:nidefawl.qubes.input.Keybinding setStatic() -> if
    40:40:boolean isStaticBinding() -> do
    43:43:boolean hasCallback() -> if
    46:51:void fire() -> for
    54:54:java.lang.String getName() -> do
    61:61:boolean isEnabled() -> for
    68:68:boolean isPressed() -> int
    75:75:int getKey() -> if
    83:84:void setEnabled(boolean) -> do
    91:92:void setKey(int) -> do
    102:102:void onDown() -> do
    103:103:void onUp() -> int
    104:104:void onRepeat() -> if
    110:122:void update(int) -> if
nidefawl.qubes.input.Keyboard -> IjllJiL1iJjIJill:
    java.util.HashMap keyNames -> do
    136:136:boolean isKeyDown(int) -> do
    140:140:boolean getState(int) -> if
    144:145:java.lang.String getKeyName(int) -> do
    11:134:void <clinit>() -> <clinit>
nidefawl.qubes.input.Mouse -> L1IjL1jIjIllL1Ij:
    double dy -> do
    double dx -> if
    double x -> for
    double y -> int
    double scrollDX -> new
    double scrollDY -> try
    double lastX -> byte
    double lastY -> case
    java.nio.DoubleBuffer bx -> do
    java.nio.DoubleBuffer by -> if
    boolean isGrabbed -> do
    28:32:void init() -> do
    34:36:double getDX() -> do
    40:42:double getDY() -> if
    46:46:boolean getState(int) -> do
    50:50:double getX() -> for
    54:54:double getY() -> int
    58:59:void setCursorPosition(int,int) -> do
    63:63:boolean isGrabbed() -> do
    67:72:void setGrabbed(boolean) -> do
    75:84:void setLastPos() -> if
    86:86:boolean isButtonDown(int) -> if
    92:105:void update(double,double) -> do
nidefawl.qubes.input.Selection -> L11LL1IjjIL1jIll:
    nidefawl.qubes.gl.TesselatorState highlightSelection -> do
    nidefawl.qubes.gl.TesselatorState fullBlock -> if
    nidefawl.qubes.gl.TesselatorState customBB -> for
    nidefawl.qubes.vec.AABBFloat lastCustomBB -> do
    boolean quarterMode -> do
    boolean mouseDown -> if
    int buttonDown -> do
    boolean mouseStateChanged -> for
    nidefawl.qubes.gl.TesselatorState renderBB -> int
    nidefawl.qubes.util.RayTrace rayTrace -> do
    nidefawl.qubes.vec.BlockPos[] pos -> do
    boolean updateBB -> int
    nidefawl.qubes.vec.BlockPos mouseOver -> do
    nidefawl.qubes.vec.AABBFloat selBB -> if
    int timer -> if
    25:67:void <init>() -> <init>
    29:29:nidefawl.qubes.input.GameMode getMode() -> do
    45:50:void init() -> do
    55:56:void resetSelection() -> if
    59:62:boolean hasSelection() -> do
    71:105:void renderBlockHighlight(nidefawl.qubes.world.World,float) -> do
    111:121:void renderMouseOver() -> try
    125:253:void renderBlockOver(nidefawl.qubes.gl.TesselatorState,nidefawl.qubes.vec.AABBFloat) -> do
    257:306:void renderBB() -> for
    308:324:void update(nidefawl.qubes.world.World) -> do
    327:379:void update(nidefawl.qubes.world.World,nidefawl.qubes.gl.PositionMouseOver,nidefawl.qubes.vec.Vector3f) -> do
    385:422:void setMouseOver(nidefawl.qubes.util.RayTrace$RayTraceIntersection) -> do
    425:433:void set(int,nidefawl.qubes.vec.BlockPos) -> do
    435:468:void clicked(int,boolean) -> do
    471:483:void onRelease(int) -> do
    486:486:boolean extendReach() -> if
    490:490:nidefawl.qubes.vec.BlockPos getMin() -> do
    494:494:nidefawl.qubes.vec.BlockPos getMax() -> if
    498:500:int getNumBlocks() -> do
    504:510:void reset() -> int
    516:519:nidefawl.qubes.util.RayTrace$RayTraceIntersection getHit() -> do
    544:545:void toggleQuarterMode() -> new
nidefawl.qubes.input.WorldPlayerController -> IjIjIjjIllL1jIjI:
    17:18:void <init>() -> <init>
    27:49:void blockClicked(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,int,boolean) -> do
    52:59:void jumpTo(nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.util.RayTrace$RayTraceIntersection) -> do
    62:78:void pickBlock(nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.util.RayTrace$RayTraceIntersection) -> if
    82:87:void setMultiple(nidefawl.qubes.world.World,nidefawl.qubes.util.RayTrace$RayTraceIntersection,int,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos) -> do
nidefawl.qubes.inventory.BaseInventory -> JilllliJiJJiJiL1:
    int id -> do
    int inventorySize -> if
    nidefawl.qubes.item.BaseStack[] stacks -> do
    byte[] flagged -> do
    boolean dirty -> do
    boolean needSorting -> if
    java.util.HashMap amounts -> do
    24:35:void <init>(int,int) -> <init>
    37:37:boolean isDirty() -> do
    41:41:nidefawl.qubes.item.BaseStack getItem(int) -> do
    45:50:nidefawl.qubes.item.BaseStack setItem(int,nidefawl.qubes.item.BaseStack) -> do
    54:54:int getId() -> do
    58:58:int getSize() -> if
    62:69:java.util.List copySlotStacks() -> do
    73:79:void addStack(nidefawl.qubes.item.BaseStack) -> do
    82:83:void setIncr(java.util.Collection) -> do
    85:86:void set(java.util.Collection) -> if
    89:103:void _set(java.util.Collection,boolean) -> do
    106:116:java.util.HashSet getUpdate() -> do
    119:121:void flag(int) -> do
    123:138:java.util.HashMap getSortedStacks() -> do
nidefawl.qubes.inventory.InventoryUtil -> iJjIL1IjIjJilljI:
    27:36:nidefawl.qubes.nbt.Tag writeToTag(java.util.List) -> do
    45:60:java.util.List readFromTag(nidefawl.qubes.nbt.Tag) -> do
    87:100:boolean copy(nidefawl.qubes.item.BaseStack[],nidefawl.qubes.item.BaseStack[]) -> do
nidefawl.qubes.inventory.PlayerInventory -> iJL1IjJiJiL1jIJi:
    nidefawl.qubes.item.BaseStack carried -> do
    21:22:void <init>() -> <init>
    33:38:java.util.List copySlotStacks() -> do
    41:52:void set(java.util.List) -> do
    57:59:nidefawl.qubes.item.BaseStack setCarried(nidefawl.qubes.item.BaseStack) -> do
    63:63:nidefawl.qubes.item.BaseStack getCarried() -> do
nidefawl.qubes.inventory.PlayerInventoryCrafting -> jIiJL1JiJijIiJjI:
    int inputSlots -> for
    int outputSlots -> int
    15:18:void <init>(int,int,int) -> <init>
nidefawl.qubes.inventory.slots.Slot -> IjIjJiIjL1jIIjL1:
    int idx -> do
    float x -> do
    float y -> if
    float w -> for
    nidefawl.qubes.inventory.slots.Slots slots -> do
    13:19:void <init>(nidefawl.qubes.inventory.slots.Slots,int,float,float,float) -> <init>
    nidefawl.qubes.item.BaseStack getItem() -> do
    29:29:boolean isAt(double,double) -> do
    boolean transferTo(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    boolean isEmpty() -> do
    nidefawl.qubes.item.BaseStack drain() -> if
    nidefawl.qubes.item.BaseStack put(nidefawl.qubes.inventory.slots.SlotInventory) -> do
    nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    boolean canTake() -> if
    boolean canPut(nidefawl.qubes.item.BaseStack) -> do
    47:47:void flag() -> do
nidefawl.qubes.inventory.slots.SlotInventory -> IjL11LL1iJ1LiJll:
    nidefawl.qubes.inventory.BaseInventory inv -> do
    17:19:void <init>(nidefawl.qubes.inventory.slots.Slots,nidefawl.qubes.inventory.BaseInventory,int,float,float,float) -> <init>
    23:23:nidefawl.qubes.item.BaseStack getItem() -> do
    28:35:boolean transferTo(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    40:40:boolean isEmpty() -> do
    45:45:nidefawl.qubes.item.BaseStack drain() -> if
    50:50:nidefawl.qubes.item.BaseStack put(nidefawl.qubes.inventory.slots.SlotInventory) -> do
    55:58:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    63:63:boolean canTake() -> if
    68:68:boolean canPut(nidefawl.qubes.item.BaseStack) -> do
    72:73:void flag() -> do
nidefawl.qubes.inventory.slots.SlotPreview -> jIjIllllL1IjL1L1:
    nidefawl.qubes.item.BaseStack stack -> do
    10:12:void <init>(nidefawl.qubes.inventory.slots.Slots,nidefawl.qubes.item.BaseStack,int,float,float,float) -> <init>
    16:16:nidefawl.qubes.item.BaseStack getItem() -> do
    21:21:boolean transferTo(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    26:26:boolean isEmpty() -> do
    31:31:nidefawl.qubes.item.BaseStack drain() -> if
    36:36:nidefawl.qubes.item.BaseStack put(nidefawl.qubes.inventory.slots.SlotInventory) -> do
    41:41:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    46:46:boolean canTake() -> if
    51:51:boolean canPut(nidefawl.qubes.item.BaseStack) -> do
nidefawl.qubes.inventory.slots.SlotStack -> jIjIllJijIIj1LIj:
    int slot -> do
    nidefawl.qubes.item.BaseStack stack -> do
    12:14:void <init>() -> <init>
    15:18:void <init>(int,nidefawl.qubes.item.BaseStack) -> <init>
    23:25:void read(java.io.DataInput) -> do
    28:30:void write(java.io.DataOutput) -> do
nidefawl.qubes.inventory.slots.SlotStock -> L1jIlllliJJiJiJi:
    nidefawl.qubes.item.BaseStack stack -> do
    nidefawl.qubes.inventory.PlayerInventory inv -> do
    nidefawl.qubes.item.BaseStack stackReq -> if
    13:18:void <init>(nidefawl.qubes.inventory.slots.Slots,nidefawl.qubes.item.BaseStack,nidefawl.qubes.inventory.PlayerInventory,int,float,float,float) -> <init>
    22:22:nidefawl.qubes.item.BaseStack getItem() -> do
    27:27:boolean transferTo(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
    32:32:boolean isEmpty() -> do
    37:37:nidefawl.qubes.item.BaseStack drain() -> if
    42:42:nidefawl.qubes.item.BaseStack put(nidefawl.qubes.inventory.slots.SlotInventory) -> do
    47:47:nidefawl.qubes.item.BaseStack putStack(nidefawl.qubes.item.BaseStack) -> do
    52:52:boolean canTake() -> if
    57:57:boolean canPut(nidefawl.qubes.item.BaseStack) -> do
    61:67:void update() -> if
nidefawl.qubes.inventory.slots.Slots -> iJL1lliJjIllIj1L:
    java.util.List slots -> do
    int id -> do
    10:15:void <init>(int) -> <init>
    18:18:int getId() -> do
    21:22:void addSlot(nidefawl.qubes.inventory.slots.Slot) -> do
    30:35:nidefawl.qubes.inventory.slots.Slot getSlotAt(double,double) -> do
    42:42:java.util.List getSlots() -> do
    nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
    54:54:nidefawl.qubes.inventory.slots.Slot getSlot(int) -> do
    58:58:boolean canModify() -> do
nidefawl.qubes.inventory.slots.SlotsCrafting -> iJiJIjiJiJll1L1L:
    boolean locked -> do
    10:11:void <init>(nidefawl.qubes.entity.Player,int) -> <init>
    8:18:void <init>(nidefawl.qubes.entity.Player,int,int,int,int,int) -> <init>
    25:25:int getInputSize() -> if
    29:30:void unlock() -> do
    33:34:void lock() -> if
    37:37:boolean canModify() -> do
    41:47:int getNumItems() -> for
    50:59:int transferSlots(nidefawl.qubes.inventory.slots.SlotsInventoryBase) -> do
nidefawl.qubes.inventory.slots.SlotsInventory -> iJ1LjIIjjIL1JiiJ:
    17:21:void <init>(nidefawl.qubes.entity.Player,int,int,int,int) -> <init>
    24:25:void <init>(nidefawl.qubes.entity.PlayerServer) -> <init>
    28:28:boolean canModify() -> do
nidefawl.qubes.inventory.slots.SlotsInventoryBase -> iJ1LJiL1iJjIIj1L:
    nidefawl.qubes.inventory.BaseInventory baseInv -> do
    nidefawl.qubes.inventory.PlayerInventory playerInv -> do
    13:16:void <init>(int,nidefawl.qubes.inventory.PlayerInventory,nidefawl.qubes.inventory.BaseInventory) -> <init>
    18:32:nidefawl.qubes.item.BaseStack slotClicked(nidefawl.qubes.inventory.slots.Slot,int,int) -> do
    39:39:nidefawl.qubes.inventory.BaseInventory getInv() -> do
    43:50:nidefawl.qubes.inventory.slots.Slot getFirstEmpty(nidefawl.qubes.item.BaseStack) -> do
    54:63:nidefawl.qubes.item.BaseStack addStack(nidefawl.qubes.item.BaseStack) -> do
nidefawl.qubes.io.BinaryStreamReader -> Ij1L1LJijIlljIJi:
    int offset -> do
    nidefawl.qubes.assets.AssetBinary asset -> do
    10:11:void <init>() -> <init>
    15:21:byte[] readBytes(int) -> do
    33:34:float readFloat() -> do
    45:45:nidefawl.qubes.vec.Vector3f readVec3() -> do
    53:53:nidefawl.qubes.vec.Vector4f readVec4() -> do
    57:64:int readInt() -> do
    67:72:int readUShort() -> if
    75:78:int readUByte() -> for
    87:90:java.lang.String readString(int) -> do
    94:95:void resetOffset() -> do
nidefawl.qubes.io.ByteArrIO -> lllliJJijIllJijI:
    17:21:int writeInt(byte[],int,int) -> do
    24:26:int writeShort(byte[],int,int) -> if
    36:37:void write(byte[],int,int) -> if
    40:42:int readShort(byte[],int) -> do
    46:47:int readUnsignedByte(byte[],int) -> if
    56:60:int readInt(byte[],int) -> for
    69:70:void writeByte(byte[],int,int) -> do
    72:75:void byteToShortArray(byte[],short[]) -> do
    77:78:byte[] shortToByteArray(short[]) -> do
    81:85:byte[] shortToByteArray(short[],byte[]) -> do
nidefawl.qubes.io.network.DataListType -> JiIj1LL1Ij1LJiiJ:
    nidefawl.qubes.io.network.DataListType WORLDS -> do
    int id -> do
    java.lang.Class clazz -> do
    nidefawl.qubes.io.network.DataListType[] $VALUES -> do
    6:6:nidefawl.qubes.io.network.DataListType[] values() -> values
    6:6:nidefawl.qubes.io.network.DataListType valueOf(java.lang.String) -> valueOf
    10:13:void <init>(java.lang.String,int,int,java.lang.Class) -> <init>
    15:16:nidefawl.qubes.io.network.DataListType byId(int) -> do
    20:22:nidefawl.qubes.network.StreamIO makeNew() -> do
    26:26:int getId() -> do
    6:7:void <clinit>() -> <clinit>
nidefawl.qubes.io.network.WorldInfo -> IjL1llL1L1L11Lll:
    int id -> do
    java.lang.String name -> do
    java.util.UUID uuid -> do
    15:16:void <init>() -> <init>
    19:22:void read(java.io.DataInput) -> do
    25:29:void write(java.io.DataOutput) -> do
nidefawl.qubes.item.BaseStack -> IjiJllL1iJiJiJll:
    int id -> do
    int data -> if
    int size -> for
    nidefawl.qubes.item.ItemStack tmpStackItem -> do
    nidefawl.qubes.item.BlockStack tmpStackBlock -> do
    15:15:void <init>() -> <init>
    boolean isItem() -> do
    23:23:boolean isBlock() -> if
    nidefawl.qubes.item.BaseStack copy() -> do
    nidefawl.qubes.nbt.Tag save() -> do
    boolean isFullyEqual(nidefawl.qubes.item.BaseStack) -> do
    boolean isEqualId(nidefawl.qubes.item.BaseStack) -> if
    33:43:nidefawl.qubes.item.BaseStack load(nidefawl.qubes.nbt.Tag) -> do
    46:50:boolean equalStacks(nidefawl.qubes.item.BaseStack,nidefawl.qubes.item.BaseStack) -> do
    nidefawl.qubes.item.Item getItem() -> do
    nidefawl.qubes.block.Block getBlock() -> do
    int getTypeHash() -> do
    62:62:java.lang.String getName() -> do
    69:77:nidefawl.qubes.item.BaseStack getTemp(java.lang.Object) -> do
    80:81:void setSize(int) -> do
    83:83:int getSize() -> if
    86:86:int getId() -> for
    65:66:void <clinit>() -> <clinit>
nidefawl.qubes.item.BlockStack -> JiIjL1llL1jIJiL1:
    nidefawl.qubes.item.StackData stackdata -> do
    29:30:void setStackdata(nidefawl.qubes.item.StackData) -> do
    35:35:nidefawl.qubes.item.StackData getStackdata() -> do
    38:39:void <init>(int) -> <init>
    41:42:void <init>(nidefawl.qubes.block.Block,int) -> <init>
    44:45:void <init>(nidefawl.qubes.block.Block) -> <init>
    46:50:void <init>(int,int,int) -> <init>
    52:53:void <init>(int,int) -> <init>
    58:59:void <init>() -> <init>
    64:78:void <init>(nidefawl.qubes.nbt.Tag$Compound) -> <init>
    82:96:nidefawl.qubes.nbt.Tag save() -> do
    99:102:nidefawl.qubes.item.BlockStack copy() -> do
    105:105:nidefawl.qubes.block.Block getBlock() -> do
    109:118:void read(java.io.DataInput) -> do
    121:130:void write(java.io.DataOutput) -> do
    133:136:boolean isEqualId(nidefawl.qubes.item.BaseStack) -> if
    139:142:boolean isFullyEqual(nidefawl.qubes.item.BaseStack) -> do
    147:147:boolean isItem() -> do
    151:151:nidefawl.qubes.item.Item getItem() -> do
    156:156:java.lang.String toString() -> toString
    162:162:int getTypeHash() -> do
    21:21:nidefawl.qubes.item.BaseStack copy() -> do
nidefawl.qubes.item.IDMappingItems -> llll1LjIll1L1LiJ:
    boolean CHANGED -> do
    boolean LOADED -> if
    int HIGHEST_ITEM_ID -> do
    com.google.common.collect.ImmutableBiMap map -> do
    java.lang.Object sync -> do
    33:72:void load() -> do
    74:115:void save() -> if
    117:149:int get(java.lang.String) -> do
    25:30:void <clinit>() -> <clinit>
nidefawl.qubes.item.Item -> L1jIL1L1jIiJll1L:
    nidefawl.qubes.item.Item[] registereditems -> if
    short[] registereditemIds -> do
    nidefawl.qubes.item.Item[] item -> do
    nidefawl.qubes.item.Item pickaxe -> do
    nidefawl.qubes.item.Item axe -> if
    nidefawl.qubes.item.ItemGroupLog log -> do
    nidefawl.qubes.item.ItemGroupPlank plank -> do
    nidefawl.qubes.item.ItemGroupStones stones -> do
    int id -> do
    java.lang.String name -> do
    boolean transparent -> do
    java.lang.String[] textures -> do
    nidefawl.qubes.vec.AABBFloat blockBounds -> do
    nidefawl.qubes.models.ItemModel itemModel -> do
    nidefawl.qubes.item.ItemGroup itemGroup -> do
    46:47:void <init>(java.lang.String) -> <init>
    60:61:void setItemGroup(nidefawl.qubes.item.ItemGroup) -> do
    53:72:void <init>(java.lang.String,boolean) -> <init>
    75:75:void init() -> do
    79:80:nidefawl.qubes.item.Item setModel(nidefawl.qubes.models.ItemModel) -> do
    84:84:java.lang.String[] getTextures() -> do
    88:92:nidefawl.qubes.item.Item setTextures(java.lang.String[]) -> do
    101:101:java.lang.String getName() -> do
    108:130:void preInit() -> if
    133:133:void postInit() -> for
    145:145:nidefawl.qubes.item.Item get(int) -> do
    152:152:int getTexture(nidefawl.qubes.item.ItemStack) -> do
    159:159:nidefawl.qubes.models.ItemModel getItemModel() -> do
    163:173:boolean canMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.block.Block,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
    33:38:void <clinit>() -> <clinit>
nidefawl.qubes.item.ItemGroup -> JiIj1LjIJiJi:
    int NEXT_GROUP_ID -> do
    int id -> if
    java.util.List items -> do
    8:16:void <init>() -> <init>
    19:21:void addItem(nidefawl.qubes.item.Item) -> do
    26:26:java.util.List getItems() -> do
    29:29:nidefawl.qubes.item.Item getItem(int) -> do
    10:10:void <clinit>() -> <clinit>
nidefawl.qubes.item.ItemGroupLog -> llllllL11LL1L1ll:
    9:18:void <init>() -> <init>
nidefawl.qubes.item.ItemGroupPlank -> jIJilliJIjIjiJJi:
    9:18:void <init>() -> <init>
nidefawl.qubes.item.ItemGroupStones -> L1lliJL11LJiiJll:
    java.util.List names -> do
    9:17:void <init>() -> <init>
    8:8:void <clinit>() -> <clinit>
nidefawl.qubes.item.ItemLog -> jIjIIj1LiJ1LiJ:
    int index -> if
    8:10:void <init>(java.lang.String,int) -> <init>
nidefawl.qubes.item.ItemRenderer -> JiIjIjJi1LiJll1L:
    nidefawl.qubes.font.FontRenderer font -> do
    26:27:void <init>() -> <init>
    33:34:void init() -> do
    37:59:void drawItem(nidefawl.qubes.item.BaseStack,float,float,float,float) -> do
    69:79:void drawItemOverlay(nidefawl.qubes.item.BaseStack,float,float,float,float) -> if
nidefawl.qubes.item.ItemStack -> IjIjIjiJL1L11L:
    19:23:void <init>(nidefawl.qubes.item.Item) -> <init>
    25:29:void <init>(nidefawl.qubes.nbt.Tag$Compound) -> <init>
    30:31:void <init>() -> <init>
    40:43:void read(java.io.DataInput) -> do
    47:50:void write(java.io.DataOutput) -> do
    54:54:boolean isItem() -> do
    61:61:int getItemTexture() -> int
    68:68:nidefawl.qubes.item.Item getItem() -> do
    73:77:nidefawl.qubes.item.BaseStack copy() -> do
    82:87:nidefawl.qubes.nbt.Tag save() -> do
    92:95:boolean isEqualId(nidefawl.qubes.item.BaseStack) -> if
    98:101:boolean isFullyEqual(nidefawl.qubes.item.BaseStack) -> do
    105:105:nidefawl.qubes.block.Block getBlock() -> do
    109:109:java.lang.String toString() -> toString
    114:114:int getTypeHash() -> do
nidefawl.qubes.item.ItemStone -> IjIjL1JiJiL1L1ll:
    int index -> if
    8:10:void <init>(java.lang.String,int) -> <init>
nidefawl.qubes.item.StackData -> L11LL1L1jIiJJiL1:
    nidefawl.qubes.chunk.blockdata.BlockData data -> do
    20:21:void <init>() -> <init>
    22:25:void <init>(nidefawl.qubes.item.StackData) -> <init>
    27:28:void setBlockData(nidefawl.qubes.chunk.blockdata.BlockData) -> do
    30:30:nidefawl.qubes.chunk.blockdata.BlockData getBlockData() -> do
    35:48:void read(java.io.DataInput) -> do
    52:63:void write(java.io.DataOutput) -> do
    66:66:nidefawl.qubes.item.StackData copy() -> do
    70:70:boolean isEqual(nidefawl.qubes.item.StackData,nidefawl.qubes.item.StackData) -> do
nidefawl.qubes.lighting.DynamicLight -> iJjI1LiJ1LjIL1Ji:
    nidefawl.qubes.vec.Vector3f pos -> do
    nidefawl.qubes.vec.Vector3f lastPos -> if
    nidefawl.qubes.vec.Vector3f mot -> for
    nidefawl.qubes.vec.Vector3f lastMot -> int
    nidefawl.qubes.vec.Vector3f renderPos -> new
    nidefawl.qubes.vec.Vector3f color -> try
    float intensity -> do
    float quadratic -> if
    float lightThreshold -> for
    float radius -> int
    int ticks -> do
    11:27:void <init>(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,float) -> <init>
    29:31:void setPos(nidefawl.qubes.vec.Vector3f) -> do
    33:38:void tickUpdate(nidefawl.qubes.world.WorldClient) -> do
    41:55:void updatePreRender(nidefawl.qubes.world.WorldClient,float) -> do
    58:66:void store(java.nio.FloatBuffer) -> do
nidefawl.qubes.logging.ErrorHandler -> jIJill1LiJjIlliJ:
    nidefawl.qubes.logging.IErrorHandler handler -> do
    8:11:void setException(nidefawl.qubes.util.GameError) -> do
    13:14:void setHandler(nidefawl.qubes.logging.IErrorHandler) -> do
nidefawl.qubes.logging.IErrorHandler -> IjIjJiIjjIL1jIL1:
    void setException(nidefawl.qubes.util.GameError) -> setException
nidefawl.qubes.logging.LogBufferStream -> jIL1IjIjlliJlljI:
    java.io.ByteArrayOutputStream baos -> do
    java.io.PrintStream ps -> do
    6:12:void <init>(java.io.PrintStream) -> <init>
    17:21:void write(byte[],int,int) -> write
    25:26:void write(byte[]) -> write
    30:36:void flush() -> flush
    40:46:void close() -> close
    50:52:void write(int) -> write
    56:60:java.lang.String getLogString() -> do
nidefawl.qubes.meshing.BlockFace -> IjIjllL1llL1Ij:
    nidefawl.qubes.meshing.BlockSurface bs -> do
    float[] v0 -> do
    float[] v1 -> if
    float[] v2 -> for
    float[] v3 -> int
    int[] du -> do
    int[] dv -> if
    byte[] normal -> do
    int faceDir -> do
    int[] pos -> for
    int w -> if
    int h -> for
    int[][] faceVDirections -> do
    int[][] faceVDirectionsNeg -> if
    27:30:int encNormal(int,int,int) -> do
    34:41:int encNegNormal(int,int,int) -> if
    47:123:void initDir() -> do
    129:230:void <init>(nidefawl.qubes.meshing.BlockSurface,int[],int[],int[],int,int,int,int) -> <init>
    241:247:int drawBasic(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> do
    259:275:int drawShadowTextured(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> if
    279:351:int draw(nidefawl.qubes.meshing.BlockFaceAttr,nidefawl.qubes.gl.VertexBuffer) -> for
    355:390:void setUV(nidefawl.qubes.meshing.BlockFaceVert,int) -> do
    44:126:void <clinit>() -> <clinit>
nidefawl.qubes.meshing.BlockFaceAttr -> Ji1LL1lljIL11LJi:
    java.lang.String[] attributes -> do
    nidefawl.qubes.meshing.BlockFaceVert v0 -> do
    nidefawl.qubes.meshing.BlockFaceVert v1 -> if
    nidefawl.qubes.meshing.BlockFaceVert v2 -> for
    nidefawl.qubes.meshing.BlockFaceVert v3 -> int
    nidefawl.qubes.meshing.BlockFaceVert[] v -> do
    boolean useGlobalRenderOffset -> do
    int tex -> do
    float xOff -> do
    float yOff -> if
    float zOff -> for
    int aoMask -> if
    int lightMaskSky -> for
    int lightMaskBlock -> int
    int type -> new
    boolean reverse -> if
    int faceDir -> try
    int normalMap -> byte
    int roughness -> case
    11:45:void <init>() -> <init>
    54:55:void setUseGlobalRenderOffset(boolean) -> do
    58:59:void setTex(int) -> do
    62:63:void setNormalMap(int) -> if
    66:73:void setOffset(float,float,float) -> do
    75:78:void addOffset(float,float,float) -> if
    81:88:void setNormal(int,int,int) -> do
    91:93:void setLight(int,int) -> do
    98:135:void rotateUV(int) -> for
    138:152:void putSingleVert(int,nidefawl.qubes.gl.VertexBuffer) -> do
    154:161:void putShadowTexturedSingleVert(int,nidefawl.qubes.gl.VertexBuffer) -> if
    164:169:void putBasicSingleVert(int,nidefawl.qubes.gl.VertexBuffer) -> for
    172:191:void putVertAttr(nidefawl.qubes.gl.VertexBuffer) -> do
    194:205:void putFaceAttr(nidefawl.qubes.gl.VertexBuffer) -> if
    208:233:void put(nidefawl.qubes.gl.VertexBuffer) -> for
    237:261:void putFormat2(nidefawl.qubes.gl.VertexBuffer) -> int
    264:280:void putBasic(nidefawl.qubes.gl.VertexBuffer) -> new
    284:302:void putShadowTextured(nidefawl.qubes.gl.VertexBuffer) -> try
    305:306:void setAO(int) -> int
    308:309:void setRoughness(float) -> do
    312:316:void setType(int) -> new
    318:321:void setPass(int) -> try
    323:326:void flipNormal() -> do
    332:333:void setReverse(boolean) -> if
    339:340:void setFaceDir(int) -> byte
    345:345:int getFaceDir() -> do
    352:367:void calcNormal(nidefawl.qubes.vec.Vector3f) -> do
    404:411:int packNormal(nidefawl.qubes.vec.Vector3f) -> do
    419:419:boolean getReverse() -> do
    424:441:void maskLight(int,int,int,int,int) -> do
    444:444:int maskAO(int,int,int,int) -> do
    449:453:int mix_light(int,int,int,int) -> if
    27:27:void <clinit>() -> <clinit>
nidefawl.qubes.meshing.BlockFaceVert -> JiiJJi1LllJiiJjI:
    int rgba -> do
    float u -> do
    float v -> if
    float x -> for
    float y -> int
    float z -> new
    int dirOffset -> if
    int normal -> for
    int direction -> int
    int pass -> new
    5:5:void <init>() -> <init>
    20:26:void setColorRGBAF(float,float,float,float) -> do
    29:31:void setColorRGBA(int,float) -> do
    34:35:void setColorRGB(int) -> do
    38:40:void setUV(float,float) -> do
    43:46:void setPos(float,float,float) -> do
    49:50:void setFaceVertDir(int) -> if
    52:56:void setDirection(int,int,boolean) -> do
    58:59:void setNoDirection() -> do
    63:75:void setNormal(float,float,float) -> if
    81:82:void setPass(int) -> for
    88:92:void flipNormal() -> if
nidefawl.qubes.meshing.BlockRenderer -> JillllJiJiIj1L:
    int[][] offsets -> do
    nidefawl.qubes.meshing.BlockSurface bs -> do
    nidefawl.qubes.vec.AABBFloat bb -> do
    int shadowDrawMode -> do
    boolean extendFaces -> do
    nidefawl.qubes.world.IBlockWorld w -> do
    nidefawl.qubes.meshing.BlockFaceAttr attr -> do
    nidefawl.qubes.gl.VertexBuffer[] vbuffer -> do
    boolean[] wallDir -> do
    boolean[] fenceDir -> if
    int[] paneDir -> do
    int[] quarters -> if
    int[] quarters2 -> for
    nidefawl.qubes.vec.AABBFloat[] boxes -> do
    nidefawl.qubes.meshing.BlockSurface[] qSurfacesS -> do
    nidefawl.qubes.meshing.BlockSurface[] qSurfaces -> if
    int[] vPos_model -> int
    int[] vIdx_model -> new
    nidefawl.qubes.vec.Vector3f plantNormal -> do
    26:1435:void <init>() -> <init>
    80:81:void setDefaultBounds() -> do
    88:91:void preRender(nidefawl.qubes.world.World,nidefawl.qubes.meshing.ChunkRenderCache,nidefawl.qubes.meshing.BlockFaceAttr) -> do
    97:99:void setBuffers(nidefawl.qubes.gl.VertexBuffer[],int) -> do
    107:187:int render(int,int,int) -> do
    200:214:int renderWaterLily(nidefawl.qubes.block.Block,int,int,int,int) -> try
    218:218:int setPaneConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,int[]) -> do
    221:347:int renderPane(nidefawl.qubes.block.Block,int,int,int,int) -> byte
    351:467:int renderTorch(nidefawl.qubes.block.Block,int,int,int) -> do
    471:471:int setWallConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> do
    474:550:int renderWall(nidefawl.qubes.block.Block,int,int,int,int) -> do
    553:553:int setFenceConnections(nidefawl.qubes.world.IBlockWorld,int,int,int,boolean[]) -> if
    564:618:int renderFence(nidefawl.qubes.block.Block,int,int,int,int) -> if
    630:692:int renderVines(nidefawl.qubes.block.Block,int,int,int,int) -> for
    696:705:void renderXNeg(nidefawl.qubes.block.Block,float,float,float) -> do
    708:717:void renderXPos(nidefawl.qubes.block.Block,float,float,float) -> if
    719:728:void renderZNeg(nidefawl.qubes.block.Block,float,float,float) -> for
    730:739:void renderZPos(nidefawl.qubes.block.Block,float,float,float) -> int
    741:752:void renderYPos(nidefawl.qubes.block.Block,float,float,float) -> new
    756:765:void renderYNeg(nidefawl.qubes.block.Block,float,float,float) -> try
    768:789:int renderFace(nidefawl.qubes.block.Block,int,float,float,float,int) -> do
    799:807:void putSingleVert(nidefawl.qubes.block.Block,int,int) -> do
    810:814:void putTriIndex(nidefawl.qubes.block.Block,int,int[],int,int) -> do
    816:824:void putBuffer(nidefawl.qubes.block.Block,int) -> do
    827:910:int renderSlicedFaces(nidefawl.qubes.block.BlockSliced,int,int,int) -> do
    913:954:int renderPlantFlat(nidefawl.qubes.block.Block,int,int,int,int) -> case
    958:962:int renderBlock(nidefawl.qubes.block.Block,int,int,int,int,int) -> do
    967:1013:int renderBlockModel(nidefawl.qubes.block.Block,int,int,int,int,int) -> if
    1035:1046:void flipFace() -> if
    1050:1074:void setFaceColorTexture(nidefawl.qubes.block.Block,int,int,int,int,nidefawl.qubes.meshing.BlockSurface,int,int) -> do
    1076:1078:void setFaceColor(nidefawl.qubes.block.Block,int,int,int,int,nidefawl.qubes.meshing.BlockSurface,int) -> do
    1087:1091:void setBlockBounds(nidefawl.qubes.block.Block,int,int,int) -> do
    1094:1100:int getAndRenderBlockFace(nidefawl.qubes.block.Block,int,int,int,int,int,int,int) -> do
    1105:1137:nidefawl.qubes.meshing.BlockSurface getSingleBlockSurface(nidefawl.qubes.block.Block,int,int,int,int,int,boolean,nidefawl.qubes.meshing.BlockSurface,int) -> do
    1141:1153:boolean hasAnyOpenNeighbour(nidefawl.qubes.block.Block,int,int,int,int) -> do
    1156:1398:int renderLeaves(nidefawl.qubes.block.Block,int,int,int,int) -> int
    1432:1432:int renderDoublePlant(nidefawl.qubes.block.Block,int,int,int,int) -> char
    1437:1656:int renderPlant(nidefawl.qubes.block.Block,int,int,int,int) -> new
    1660:1660:boolean isInventoryBlockRender() -> do
    28:40:void <clinit>() -> <clinit>
nidefawl.qubes.meshing.BlockSurface -> JiL1IjJiIjL1iJll:
    boolean transparent -> do
    int type -> do
    int face -> if
    int axis -> for
    int x -> int
    int y -> new
    int z -> try
    int pass -> byte
    boolean extraFace -> if
    boolean resolved -> for
    boolean calcLight -> int
    int maskedLightSky -> case
    int maskedLightBlock -> char
    int maskedAO -> else
    boolean isAirAbove -> new
    int texture -> goto
    boolean renderTypeTransition -> try
    int faceColor -> long
    int[][] offset -> do
    8:23:void <init>() -> <init>
    31:31:int maskAO(int,int,int,int) -> do
    35:39:int mix_light(int,int,int,int) -> if
    42:61:void maskLight(int,int,int,int,nidefawl.qubes.block.Block) -> do
    87:108:void calcAO(nidefawl.qubes.world.IBlockWorld) -> do
    111:118:int vertexAO(boolean,boolean,boolean) -> do
    130:137:boolean isOccludingAt(nidefawl.qubes.world.IBlockWorld,int,int,int) -> do
    141:191:void calcPosZ(nidefawl.qubes.world.IBlockWorld) -> if
    194:245:void calcNegZ(nidefawl.qubes.world.IBlockWorld) -> for
    248:297:void calcPosX(nidefawl.qubes.world.IBlockWorld) -> int
    299:348:void calcNegX(nidefawl.qubes.world.IBlockWorld) -> new
    351:402:void calcPosY(nidefawl.qubes.world.IBlockWorld) -> try
    404:454:void calcNegY(nidefawl.qubes.world.IBlockWorld) -> byte
    458:489:boolean mergeWith(nidefawl.qubes.meshing.ChunkRenderCache,nidefawl.qubes.meshing.BlockSurface) -> do
    493:520:void resolve(nidefawl.qubes.meshing.ChunkRenderCache) -> do
    523:540:void reset() -> do
    542:561:nidefawl.qubes.meshing.BlockSurface copy() -> do
    65:65:void <clinit>() -> <clinit>
nidefawl.qubes.meshing.BlockSurfaceAir -> ll1LJi1LJijIjI1L:
    5:8:void <init>() -> <init>
    11:11:nidefawl.qubes.meshing.BlockSurface copy() -> do
nidefawl.qubes.meshing.BlockSurfaceHidden -> jIiJL1jIIjiJJijI:
    11:14:void <init>() -> <init>
    17:17:nidefawl.qubes.meshing.BlockSurface copy() -> do
nidefawl.qubes.meshing.ChunkRenderCache -> L1ll1LiJJiiJllL1:
    nidefawl.qubes.chunk.Chunk[] chunks -> do
    nidefawl.qubes.world.WorldClient world -> do
    int baseX -> do
    int baseZ -> if
    22:26:void <init>() -> <init>
    32:33:void set(int,int,nidefawl.qubes.chunk.Chunk) -> do
    36:36:nidefawl.qubes.chunk.Chunk get(int,int) -> do
    40:41:void flush() -> do
    44:48:int getData(int,int,int) -> do
    53:57:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    63:67:int getType(int,int,int) -> if
    72:76:int getWater(int,int,int) -> for
    81:85:int getLight(int,int,int) -> int
    95:133:boolean cache(nidefawl.qubes.world.WorldClient,nidefawl.qubes.render.region.MeshedRegion,int,int) -> do
    137:137:nidefawl.qubes.chunk.Chunk getWest() -> do
    140:140:nidefawl.qubes.chunk.Chunk getEast() -> if
    143:143:nidefawl.qubes.chunk.Chunk getNorth() -> for
    146:146:nidefawl.qubes.chunk.Chunk getSouth() -> int
    166:169:boolean isNormalBlock(int,int,int,int) -> do
    174:174:boolean setTypeData(int,int,int,int,int,int) -> do
    183:183:int getBiomeFaceColor(int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
nidefawl.qubes.meshing.MeshThread -> iJiJIjjI1LIjiJIj:
    long sleepTime -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    java.util.LinkedList results -> do
    java.util.LinkedList finish -> if
    boolean hasResults -> do
    boolean isRunning -> if
    boolean finished -> for
    nidefawl.qubes.meshing.MeshUpdateTask[] tasks -> do
    java.lang.Thread[] threads -> do
    int tasksRunning -> do
    int id -> if
    14:142:void <init>(int) -> <init>
    37:48:void init() -> do
    53:85:void run() -> run
    91:108:nidefawl.qubes.render.region.MeshedRegion finishTask() -> do
    113:122:boolean offer(nidefawl.qubes.world.WorldClient,nidefawl.qubes.render.region.MeshedRegion,int,int) -> do
    126:126:boolean busy() -> do
    130:130:boolean hasTasks() -> if
    134:139:nidefawl.qubes.meshing.MeshUpdateTask getNextTask() -> do
    145:146:void flush() -> if
    149:175:void stopThread() -> for
    178:178:boolean isRunning() -> for
    182:189:void cleanup() -> int
    13:13:void <clinit>() -> <clinit>
nidefawl.qubes.meshing.MeshUpdateTask -> IjiJllJiJiL1Ij:
    nidefawl.qubes.meshing.Mesher mesher -> do
    nidefawl.qubes.meshing.BlockRenderer blockRenderer -> do
    nidefawl.qubes.meshing.ChunkRenderCache ccache -> do
    nidefawl.qubes.meshing.BlockFaceAttr attr -> do
    int worldInstance -> do
    boolean meshed -> do
    nidefawl.qubes.render.region.MeshedRegion mr -> do
    nidefawl.qubes.gl.VertexBuffer[] vbuffer -> do
    int shadowDrawMode -> if
    24:43:void <init>() -> <init>
    46:54:boolean prepare(nidefawl.qubes.world.WorldClient,nidefawl.qubes.render.region.MeshedRegion,int,int) -> do
    58:100:boolean finish(int) -> do
    104:104:boolean isValid(int) -> if
    108:174:boolean updateFromThread() -> do
    179:179:nidefawl.qubes.render.region.MeshedRegion getRegion() -> do
    183:183:void destroy() -> do
nidefawl.qubes.meshing.Mesher -> jIllllL1jIiJIjll:
    int[] dims -> do
    nidefawl.qubes.meshing.BlockSurface[] mask2 -> do
    nidefawl.qubes.meshing.BlockSurfaceAir air -> do
    nidefawl.qubes.meshing.BlockSurfaceHidden hidden -> do
    short[] renderTypeBlocks -> do
    int nextBlockIDX -> for
    nidefawl.qubes.meshing.BlockSurface[] scratchPad -> if
    int scratchpadidx -> do
    java.util.List[] meshes -> do
    nidefawl.qubes.meshing.BlockSurface bs1 -> do
    nidefawl.qubes.meshing.BlockSurface bs2 -> if
    nidefawl.qubes.vec.AABBFloat fullBB -> do
    nidefawl.qubes.meshing.BlockSurface[] extraWaterFaces -> for
    int extraIdx -> int
    nidefawl.qubes.meshing.ChunkRenderCache cache -> do
    int strategy -> new
    int yPos -> try
    int ySlice -> byte
    int avgUsage -> if
    21:61:void <init>() -> <init>
    45:55:int computeHeight(int,int,int,int,int,int,nidefawl.qubes.meshing.BlockSurface) -> do
    65:172:void setMask2(int,int[],int[],int) -> do
    181:202:void mesh(nidefawl.qubes.meshing.ChunkRenderCache,int) -> do
    205:309:void meshRound(nidefawl.qubes.meshing.ChunkRenderCache) -> do
    314:389:nidefawl.qubes.meshing.BlockSurface getBlockSurface(int,int,int,int,int) -> do
    394:396:nidefawl.qubes.meshing.BlockSurface next() -> do
    402:402:java.util.List getMeshes(int) -> do
    411:411:int getRenderType1Blocks() -> do
    421:421:short getBlockPos(int) -> do
    179:179:void <clinit>() -> <clinit>
nidefawl.qubes.models.BlockModelManager -> jIiJL1lljIjIIjIj:
    nidefawl.qubes.models.BlockModelManager instance -> do
    java.util.HashMap models -> do
    java.util.HashMap textures -> if
    17:23:void <init>() -> <init>
    20:20:nidefawl.qubes.models.BlockModelManager getInstance() -> do
    28:28:void init() -> do
    33:87:void reload() -> if
    18:18:void <clinit>() -> <clinit>
nidefawl.qubes.models.EntityModel -> Jill1LJiL1IjJiJi:
    int HIGHEST_MODEL_ID -> do
    nidefawl.qubes.models.EntityModel[] registeredmodels -> if
    short[] registeredmodelIds -> do
    nidefawl.qubes.models.EntityModel[] models -> do
    nidefawl.qubes.models.EntityModel modelPlayerMale -> do
    nidefawl.qubes.models.EntityModel modelPlayerFemale -> if
    nidefawl.qubes.models.EntityModel modelArcher -> for
    nidefawl.qubes.models.EntityModel modelWarrior -> int
    nidefawl.qubes.models.EntityModel modelSkeleton -> new
    nidefawl.qubes.models.EntityModel modelZombie -> try
    nidefawl.qubes.models.EntityModel modelDemon -> byte
    nidefawl.qubes.models.EntityModel modelCat -> case
    nidefawl.qubes.models.EntityModel modelCow -> char
    nidefawl.qubes.models.EntityModel modelChicken -> else
    nidefawl.qubes.models.EntityModel modelDog -> goto
    nidefawl.qubes.models.EntityModel modelDuck -> long
    nidefawl.qubes.models.EntityModel modelGoat -> this
    nidefawl.qubes.models.EntityModel modelPig -> void
    nidefawl.qubes.models.EntityModel modelPony -> break
    nidefawl.qubes.models.EntityModel modelPuppy -> catch
    nidefawl.qubes.models.EntityModel modelSheep -> class
    nidefawl.qubes.models.EntityModel modelTest -> const
    int id -> if
    java.lang.String modelPath -> do
    java.lang.String name -> if
    nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel loader -> do
    nidefawl.qubes.models.qmodel.ModelQModel model -> do
    java.util.List modelOptions -> do
    java.util.ArrayList actions -> do
    56:69:void preInit() -> do
    72:72:void postInit() -> if
    80:88:void <init>(java.lang.String) -> <init>
    90:92:int addOption(nidefawl.qubes.models.ModelOption) -> do
    96:97:nidefawl.qubes.models.EntityModel setModelPath(java.lang.String) -> do
    101:101:java.lang.String getModelFile() -> do
    void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    117:120:void setModel(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    123:123:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    126:126:java.lang.String getName() -> if
    131:136:nidefawl.qubes.models.qmodel.QModelObject getObject(java.util.List,java.lang.String) -> do
    139:139:java.util.List getModelOptions() -> do
    143:143:java.util.List getActions() -> if
    147:147:void setActions(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    149:149:nidefawl.qubes.models.qmodel.animation.QModelAction getIdle() -> do
    25:52:void <clinit>() -> <clinit>
nidefawl.qubes.models.EntityModelAnimal -> IjiJjIjIiJJiIjll:
    nidefawl.qubes.models.qmodel.QModelObject main -> do
    nidefawl.qubes.models.ModelOption texSkin -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> if
    nidefawl.qubes.vec.Matrix4f rotation -> do
    15:20:void <init>(java.lang.String) -> <init>
    24:30:void setActions(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    34:65:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    68:103:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
nidefawl.qubes.models.EntityModelArcher -> L11LiJIjL1JiIjll:
    nidefawl.qubes.models.ModelOption texSkin -> do
    nidefawl.qubes.models.ModelOption modelHelmet -> if
    nidefawl.qubes.models.ModelOption texHelmet -> for
    nidefawl.qubes.models.ModelOption modelShoulders -> int
    nidefawl.qubes.models.ModelOption texShoulders -> new
    nidefawl.qubes.models.ModelOption modelBracers -> try
    nidefawl.qubes.models.ModelOption texBracers -> byte
    nidefawl.qubes.models.ModelOption modelShield -> case
    nidefawl.qubes.models.ModelOption texShield -> char
    nidefawl.qubes.models.ModelOption modelWeapon -> else
    boolean isMale -> do
    java.util.List listBracers -> if
    java.util.List listShoulders -> for
    java.util.List listShields -> int
    java.util.List listHelmets -> new
    java.util.List listWeapon -> try
    java.util.Map optNameToMat -> do
    java.util.Map optNameToOptTexMap -> if
    java.util.Map defaultSettings -> for
    nidefawl.qubes.models.qmodel.QModelObject main_0 -> do
    boolean isArcher -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction idle1 -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction walk -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction idle2 -> for
    20:52:void <init>(java.lang.String,boolean) -> <init>
    56:109:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    113:134:void setActions(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    137:174:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    176:183:void attach(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,java.util.List,nidefawl.qubes.models.ModelOption,nidefawl.qubes.models.ModelOption) -> do
    185:194:void attach2(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,java.util.List,nidefawl.qubes.models.ModelOption,nidefawl.qubes.models.ModelOption) -> if
nidefawl.qubes.models.EntityModelDemon -> jIllJiIjL11LL1jI:
    boolean isMale -> do
    nidefawl.qubes.models.ModelOption modelArmor -> do
    nidefawl.qubes.models.ModelOption texSkin -> if
    java.util.ArrayList armors -> if
    nidefawl.qubes.models.qmodel.QModelObject main -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction walk -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction run -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction idle1 -> for
    17:27:void <init>(java.lang.String) -> <init>
    32:76:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    80:101:void setActions(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    104:135:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
nidefawl.qubes.models.EntityModelManager -> iJjIjIJijIIjJijI:
    nidefawl.qubes.models.EntityModelManager instance -> do
    java.util.HashMap models -> do
    16:21:void <init>() -> <init>
    19:19:nidefawl.qubes.models.EntityModelManager getInstance() -> do
    29:68:void reload() -> do
    17:17:void <clinit>() -> <clinit>
nidefawl.qubes.models.EntityModelPlayer -> JiIjL11LL11LL1L1:
    nidefawl.qubes.vec.Matrix4f modelMat -> do
    nidefawl.qubes.vec.Matrix4f normalMat -> if
    boolean isMale -> do
    java.util.ArrayList hats -> if
    java.util.ArrayList beards -> for
    java.util.ArrayList hairs -> int
    java.util.ArrayList bags -> new
    nidefawl.qubes.models.ModelOption modelSize -> do
    nidefawl.qubes.models.ModelOption texSkin -> if
    nidefawl.qubes.models.ModelOption texFace -> for
    nidefawl.qubes.models.ModelOption modelHair -> int
    nidefawl.qubes.models.ModelOption texHair -> new
    nidefawl.qubes.models.ModelOption modelBeard -> try
    nidefawl.qubes.models.ModelOption texBeard -> byte
    nidefawl.qubes.models.ModelOption modelHat -> case
    nidefawl.qubes.models.ModelOption texHat -> char
    nidefawl.qubes.models.ModelOption modelBag -> else
    nidefawl.qubes.models.ModelOption texBag -> goto
    nidefawl.qubes.models.qmodel.QModelObject main_0 -> do
    nidefawl.qubes.models.qmodel.QModelObject main_1 -> if
    nidefawl.qubes.models.qmodel.QModelObject main_2 -> for
    nidefawl.qubes.models.qmodel.QModelObject[] body -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction run -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction jump -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction hit1 -> for
    nidefawl.qubes.models.qmodel.animation.QModelAction idle -> int
    50:50:nidefawl.qubes.models.qmodel.animation.QModelAction getIdle() -> do
    22:63:void <init>(java.lang.String,boolean) -> <init>
    66:71:nidefawl.qubes.models.qmodel.QModelObject getObject(java.util.List,java.lang.String) -> do
    75:174:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    178:200:void setActions(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    205:268:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    273:280:void attach(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,java.util.ArrayList,nidefawl.qubes.models.ModelOption,nidefawl.qubes.models.ModelOption) -> do
nidefawl.qubes.models.EntityModelSkeleton -> IjJillllL1IjIjJi:
    boolean isMale -> do
    nidefawl.qubes.models.ModelOption modelSel -> do
    nidefawl.qubes.models.ModelOption texSkin -> if
    java.util.List modelList -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction walk -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction idle1 -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction idle2 -> for
    nidefawl.qubes.models.qmodel.animation.QModelAction attack1 -> int
    17:27:void <init>(java.lang.String) -> <init>
    30:73:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    77:87:void setActions(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    91:119:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
nidefawl.qubes.models.EntityModelTest -> iJL1iJL1ll1LiJ1L:
    nidefawl.qubes.vec.Matrix4f modelMat -> do
    nidefawl.qubes.vec.Matrix4f normalMat -> if
    boolean isMale -> do
    java.util.ArrayList headThings -> if
    nidefawl.qubes.models.ModelOption modelHeadThing -> do
    nidefawl.qubes.models.qmodel.QModelObject main_0 -> do
    nidefawl.qubes.models.qmodel.QModelObject test1 -> if
    16:25:void <init>(java.lang.String) -> <init>
    28:33:nidefawl.qubes.models.qmodel.QModelObject getObject(java.util.List,java.lang.String) -> do
    37:53:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    58:85:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    88:96:void attach(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,java.util.ArrayList,nidefawl.qubes.models.ModelOption,nidefawl.qubes.models.ModelOption) -> do
nidefawl.qubes.models.EntityModelZombie -> jIiJ1LjI1L1LIjL1:
    boolean isMale -> do
    nidefawl.qubes.models.ModelOption modelSel -> do
    nidefawl.qubes.models.ModelOption texSkin -> if
    java.util.List modelList -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction walk -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction walk2 -> if
    nidefawl.qubes.models.qmodel.animation.QModelAction idle1 -> for
    nidefawl.qubes.models.qmodel.animation.QModelAction idle2 -> int
    17:27:void <init>(java.lang.String) -> <init>
    34:66:void onLoad(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    69:79:void setActions(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    84:112:void setPose(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
nidefawl.qubes.models.ItemModel -> jIIj1LIjllJillJi:
    int HIGHEST_MODEL_ID -> do
    nidefawl.qubes.models.ItemModel[] registeredmodels -> if
    short[] registeredmodelIds -> do
    nidefawl.qubes.models.ItemModel[] model -> do
    nidefawl.qubes.models.ItemModel modelPickaxe -> do
    nidefawl.qubes.models.ItemModel modelAxe -> if
    int id -> if
    java.lang.String[] models -> do
    java.lang.String[] textures -> if
    nidefawl.qubes.models.qmodel.ModelQModel[] loadedModels -> do
    java.lang.String name -> do
    33:54:void preInit() -> do
    57:57:void postInit() -> if
    67:71:void <init>(java.lang.String) -> <init>
    74:75:nidefawl.qubes.models.ItemModel setModels(java.lang.String[]) -> do
    79:79:java.lang.String[] getModels() -> do
    22:29:void <clinit>() -> <clinit>
nidefawl.qubes.models.ItemModelManager -> L1L1iJjIL1L11Lll:
    nidefawl.qubes.models.ItemModelManager instance -> do
    java.util.HashMap models -> do
    19:24:void <init>() -> <init>
    22:22:nidefawl.qubes.models.ItemModelManager getInstance() -> do
    29:29:void init() -> do
    34:74:void reload() -> if
    20:20:void <clinit>() -> <clinit>
nidefawl.qubes.models.ModelOption -> iJjIlljIllL1Jill:
    java.lang.String name -> do
    java.lang.String[] options -> do
    nidefawl.qubes.models.EntityModel eModel -> do
    int id -> do
    int defaultVal -> if
    9:13:void <init>(nidefawl.qubes.models.EntityModel,java.lang.String) -> <init>
    15:16:nidefawl.qubes.models.ModelOption setOptions(java.lang.String[]) -> do
    22:35:nidefawl.qubes.models.ModelOption setOptionCount(java.lang.String,int) -> do
    38:38:java.lang.String getTextVal(int) -> do
    41:41:java.lang.String[] getOptions() -> do
    44:44:int getId() -> do
    47:47:java.lang.String getName() -> do
    50:51:void setDefaultVal(int) -> do
    53:53:int getDefaultVal() -> if
nidefawl.qubes.models.qmodel.ModelBlock -> L1IjjIJiiJjIJiiJ:
    nidefawl.qubes.models.qmodel.QModelGroup[] faceGroups -> do
    nidefawl.qubes.gl.VertexBuffer vBuf -> do
    boolean needsDraw -> do
    long reRender -> do
    nidefawl.qubes.vec.Vector3f tmpVec -> do
    17:65:void <init>(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    67:117:void render(int,int,float) -> do
nidefawl.qubes.models.qmodel.ModelQModel -> L1JiiJlljIll1Lll:
    nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel loader -> do
    nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderObject[] objects -> do
    nidefawl.qubes.gl.VertexBuffer vbuf -> if
    nidefawl.qubes.vec.Vector3f tmpVec -> if
    nidefawl.qubes.vec.Vector3f tmpVec2 -> for
    nidefawl.qubes.vec.Matrix4f tmpMat1 -> do
    nidefawl.qubes.vec.Matrix4f tmpMat2 -> if
    boolean needsDraw -> if
    34:76:void <init>(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    79:89:void release() -> do
    100:100:void animate(nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    106:106:void animateNodes(nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    114:114:void setHeadOrientation(float,float) -> do
    void render(int,int,float) -> do
    122:188:void renderRestModel(nidefawl.qubes.models.qmodel.QModelObject,nidefawl.qubes.models.qmodel.QModelGroup,int) -> do
    191:206:void bindTextures(int) -> do
    210:214:nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderObject getGroup(int) -> do
    218:218:java.util.List getObjects() -> do
nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderGroup -> L1JiL11LJiJi:
    nidefawl.qubes.gl.GLTriBuffer gpuBufRest -> do
    nidefawl.qubes.gl.GLTriBuffer gpuBuf -> if
    long reRender -> do
    40:43:void <init>() -> <init>
    45:53:void release() -> do
nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderObject -> iJJiL1iJlljIL1L1:
    java.util.List list -> do
    55:56:void <init>() -> <init>
    58:62:void release() -> do
    64:67:nidefawl.qubes.models.qmodel.ModelQModel$ModelRenderGroup getGroup(int) -> do
nidefawl.qubes.models.qmodel.ModelRigged -> jIIj1LIjJijIIj1L:
    nidefawl.qubes.models.qmodel.QModelPoseBone rootJoint -> do
    java.util.ArrayList poseBones -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone head -> if
    nidefawl.qubes.models.qmodel.QModelPoseBone neck -> for
    nidefawl.qubes.models.qmodel.QModelNode weaponSlot -> do
    34:58:void <init>(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    66:70:nidefawl.qubes.models.qmodel.QModelPoseBone getPoseBone(nidefawl.qubes.models.qmodel.QModelBone) -> do
    78:90:void animate(nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> do
    96:113:void animateNodes(nidefawl.qubes.models.qmodel.QModelProperties,float,float) -> if
    120:129:nidefawl.qubes.vec.Matrix4f buildFinalPose(nidefawl.qubes.models.qmodel.QModelObject,nidefawl.qubes.models.qmodel.QModelVertex) -> do
    149:240:void render(int,int,float) -> do
    246:352:void setHeadOrientation(float,float) -> do
nidefawl.qubes.models.qmodel.ModelStatic -> L1JiJi1LIjL1Ji1L:
    24:25:void <init>(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    27:76:void render(int,int,float) -> do
nidefawl.qubes.models.qmodel.QModelAbstractNode -> JiL11L1LjI1LiJjI:
    8:8:void <init>() -> <init>
    12:20:int readParentType(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    nidefawl.qubes.vec.Matrix4f getMatDeform() -> do
    nidefawl.qubes.vec.Matrix4f getMatDeformNormal() -> if
nidefawl.qubes.models.qmodel.QModelBone -> iJjIllL11LiJJi1L:
    int idx -> do
    int flags -> if
    java.lang.String name -> do
    java.lang.String parentName -> if
    nidefawl.qubes.vec.Matrix4f matRest -> do
    nidefawl.qubes.vec.Matrix4f matRestInv -> if
    java.util.List children -> do
    nidefawl.qubes.vec.Vector3f tailLocal -> do
    nidefawl.qubes.models.qmodel.QModelBone parent -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone posebone -> do
    float boneLength -> do
    26:52:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    57:58:void addChild(nidefawl.qubes.models.qmodel.QModelBone) -> do
    69:69:boolean isDeform() -> do
    75:75:boolean isConnected() -> if
    79:79:java.lang.String stringInfo() -> do
    83:83:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelGroup -> iJjIllIj1LIjL1ll:
    int idx -> do
    int flags -> if
    java.lang.String name -> do
    int[] triIdx -> do
    int materialIdx -> for
    nidefawl.qubes.models.qmodel.QModelMaterial material -> do
    java.util.List listTri -> do
    boolean isSkinned -> do
    31:41:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    46:46:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelMaterial -> iJjIiJJijIiJ1LIj:
    java.lang.String name -> do
    nidefawl.qubes.vec.Vector4f ambient -> do
    nidefawl.qubes.vec.Vector4f diffuse -> if
    nidefawl.qubes.vec.Vector4f specular -> for
    nidefawl.qubes.vec.Vector4f emissive -> int
    float specular_hardness -> do
    float transparency -> if
    int mode -> do
    int idx -> if
    int[] textureIdxs -> do
    nidefawl.qubes.models.qmodel.QModelTexture[] qTextures -> do
    nidefawl.qubes.models.qmodel.QModelTexture bound -> do
    30:50:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    53:60:void resolveTextures(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    63:64:void setBoundTexture(nidefawl.qubes.models.qmodel.QModelTexture) -> do
    68:74:nidefawl.qubes.models.qmodel.QModelTexture getBoundTexture() -> do
nidefawl.qubes.models.qmodel.QModelNode -> L1jI1L1L1LjIjIL1:
    int idx -> do
    java.lang.String name -> do
    java.lang.String parent_name -> if
    int parent_type -> if
    nidefawl.qubes.models.qmodel.QModelBone attachmentBone -> do
    nidefawl.qubes.models.qmodel.QModelAbstractNode attachmentEmpty -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> do
    nidefawl.qubes.vec.Matrix4f matDeformNormal -> if
    nidefawl.qubes.vec.Matrix4f localMat -> for
    12:31:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    36:36:java.lang.String toString() -> toString
    41:47:void resolveParent(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    52:60:void updateNormalMat() -> do
    71:71:nidefawl.qubes.models.qmodel.QModelBone getAttachmentBone() -> do
    77:77:nidefawl.qubes.vec.Matrix4f getMatDeform() -> do
    83:83:nidefawl.qubes.vec.Matrix4f getMatDeformNormal() -> if
nidefawl.qubes.models.qmodel.QModelObject -> IjiJjIIjjIIjjIL1:
    int idx -> do
    int type -> if
    java.lang.String name -> do
    java.lang.String parent_name -> if
    int parent_type -> for
    nidefawl.qubes.models.qmodel.QModelBone attachmentBone -> do
    nidefawl.qubes.models.qmodel.QModelAbstractNode attachmentEmpty -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> do
    nidefawl.qubes.vec.Matrix4f matDeformNormal -> if
    java.util.List listVertex -> do
    java.util.List listTri -> if
    java.util.List listGroups -> for
    java.util.List listBones -> int
    boolean isSkinned -> do
    17:68:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    73:73:java.lang.String toString() -> toString
    77:111:void flattenBoneList(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> do
    114:132:void normalizeWeights(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> if
    135:146:int getMinBone(nidefawl.qubes.models.qmodel.QModelTriangle) -> do
    151:162:int getMaxBone(nidefawl.qubes.models.qmodel.QModelTriangle) -> if
    167:195:void sortVertices(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> for
    199:205:void resolveParent(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> int
    209:215:void resolveGroupMaterials(nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> new
    219:223:void bindTextureIdx(int,int) -> do
    226:234:void updateNormalMat() -> do
    239:239:nidefawl.qubes.models.qmodel.QModelAbstractNode getAttachementNode() -> do
    245:245:nidefawl.qubes.models.qmodel.QModelBone getAttachmentBone() -> do
    249:249:nidefawl.qubes.vec.Matrix4f getMatDeform() -> do
    255:255:nidefawl.qubes.vec.Matrix4f getMatDeformNormal() -> if
    259:260:void setAttachmentEmpty(nidefawl.qubes.models.qmodel.QModelAbstractNode) -> do
nidefawl.qubes.models.qmodel.QModelObject$1 -> JiiJL1IjlliJ:
    nidefawl.qubes.models.qmodel.QModelObject this$0 -> do
    167:167:void <init>(nidefawl.qubes.models.qmodel.QModelObject) -> <init>
    170:192:int compare(nidefawl.qubes.models.qmodel.QModelTriangle,nidefawl.qubes.models.qmodel.QModelTriangle) -> do
    167:167:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.models.qmodel.QModelPoseBone -> IjJijI1LjIIjL1Ji:
    java.util.List children -> do
    nidefawl.qubes.vec.Matrix4f matDeform -> do
    nidefawl.qubes.vec.Matrix4f matDeformNormal -> if
    nidefawl.qubes.models.qmodel.QModelBone restbone -> do
    nidefawl.qubes.models.qmodel.QModelPoseBone parent -> do
    boolean animate -> do
    18:33:void <init>(nidefawl.qubes.models.qmodel.QModelBone) -> <init>
    35:43:void updateNormalMat() -> do
    48:49:void addChild(nidefawl.qubes.models.qmodel.QModelPoseBone) -> do
    54:54:java.util.List getChildren() -> do
    60:60:boolean isDeform() -> do
    66:66:nidefawl.qubes.vec.Matrix4f getMatRest() -> do
    72:72:nidefawl.qubes.vec.Matrix4f getMatDeform() -> if
    78:78:nidefawl.qubes.vec.Vector3f getTailLocal() -> do
    84:84:boolean isConnected() -> if
    89:89:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelProperties -> IjL1IjiJJi1LjIJi:
    int[] properties -> do
    nidefawl.qubes.models.qmodel.animation.QModelAction[] actions -> do
    float[] actionOffsets -> do
    float[] actionSpeed -> if
    nidefawl.qubes.vec.Vector3f pos -> do
    nidefawl.qubes.vec.Vector3f rot -> if
    nidefawl.qubes.entity.Entity entity -> do
    nidefawl.qubes.models.qmodel.ModelQModel modelAtt -> do
    14:23:void <init>() -> <init>
    25:25:int getOption(int) -> do
    30:31:void clear() -> do
    34:35:void setRot(nidefawl.qubes.vec.Vector3f) -> do
    38:39:void setPos(nidefawl.qubes.vec.Vector3f) -> if
    41:42:void setEntity(nidefawl.qubes.entity.Entity) -> do
    45:46:void setActionOffset(int,float) -> do
    48:49:void setActionSpeed(int,float) -> if
    51:54:void setAction(int,nidefawl.qubes.models.qmodel.animation.QModelAction) -> do
    56:69:int getChannelIdx(java.lang.String) -> do
    72:72:nidefawl.qubes.models.qmodel.animation.QAnimationChannel getActionChannel(int,java.lang.String) -> do
    75:75:nidefawl.qubes.models.qmodel.animation.QModelAction getAction(int) -> do
    78:78:float getActionOffset(int) -> do
    81:81:float getActionSpeed(int) -> if
    84:85:void setModelAtt(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    87:87:nidefawl.qubes.models.qmodel.ModelQModel getModelAtt() -> do
    90:91:void setOption(int,int) -> do
    93:94:void setProperties(int[]) -> do
nidefawl.qubes.models.qmodel.QModelTexture -> jIJi1LlljIlliJIj:
    int idx -> do
    java.lang.String name -> do
    java.lang.String path -> if
    int glid -> if
    18:23:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    27:33:int get() -> do
    37:39:void release() -> do
nidefawl.qubes.models.qmodel.QModelTriangle -> JijIJiL1iJlllljI:
    int idx -> do
    int[] vertIdx -> do
    nidefawl.qubes.vec.Vector3f[] normal -> do
    float[][] texCoord -> do
    int smoothing -> if
    int group -> for
    int flags -> int
    17:50:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    54:54:java.lang.String toString() -> toString
nidefawl.qubes.models.qmodel.QModelType -> llL1ll1LllJill1L:
    nidefawl.qubes.models.qmodel.QModelType STATIC -> do
    nidefawl.qubes.models.qmodel.QModelType RIGGED -> if
    nidefawl.qubes.models.qmodel.QModelType BLOCK -> for
    nidefawl.qubes.models.qmodel.QModelType[] $VALUES -> do
    10:10:nidefawl.qubes.models.qmodel.QModelType[] values() -> values
    10:10:nidefawl.qubes.models.qmodel.QModelType valueOf(java.lang.String) -> valueOf
    10:10:void <init>(java.lang.String,int) -> <init>
    18:26:nidefawl.qubes.models.qmodel.QModelType get(int) -> do
    10:11:void <clinit>() -> <clinit>
nidefawl.qubes.models.qmodel.QModelVertex -> JiiJllL1IjlljIll:
    int idx -> do
    int flags -> if
    int refCount -> for
    int[] bones -> do
    float[] weights -> do
    int numBones -> int
    21:51:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
nidefawl.qubes.models.qmodel.animation.KeyFrame -> iJ1LlliJ1LL1IjjI:
    float time -> do
    int idx -> do
    nidefawl.qubes.models.qmodel.animation.KeyFrame next -> do
    14:17:void <init>(int,float) -> <init>
    26:26:int getIdx() -> do
    32:32:nidefawl.qubes.models.qmodel.animation.KeyFrame getNext() -> do
    35:35:nidefawl.qubes.models.qmodel.animation.KeyFrame copy() -> if
nidefawl.qubes.models.qmodel.animation.QAnimationChannel -> L1Ij1LIjiJIj1L1L:
    nidefawl.qubes.models.qmodel.animation.KeyFrame[] frames -> do
    float animLength -> do
    float frameLength -> if
    float startOffset -> for
    int priority -> do
    21:30:void <init>(int,float) -> <init>
    40:57:nidefawl.qubes.models.qmodel.animation.KeyFrame getFrameAt(int,float) -> do
    63:72:void addFrame(nidefawl.qubes.models.qmodel.animation.KeyFrame) -> do
    74:84:nidefawl.qubes.models.qmodel.animation.QAnimationChannel split(int,int) -> do
    87:118:boolean setDeform(int,float,nidefawl.qubes.vec.Matrix4f) -> do
nidefawl.qubes.models.qmodel.animation.QModelAction -> L1JiIjiJiJ1LL1:
    int idx -> do
    int flags -> if
    java.lang.String name -> do
    float fps -> do
    int startFrame -> for
    int endFrame -> int
    java.util.Map map -> do
    nidefawl.qubes.models.qmodel.animation.QAnimationChannel armatureAnim -> do
    float lenTime -> if
    27:31:void <init>() -> <init>
    27:68:void <init>(int,nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel) -> <init>
    71:87:nidefawl.qubes.models.qmodel.animation.QModelAction split(java.lang.String,int,int) -> do
nidefawl.qubes.models.qmodel.animation.QModelKeyFrameMatrix -> jI1LIjL1iJL1L1iJ:
    nidefawl.qubes.vec.Matrix4f mat -> do
    22:24:void <init>(int,float,nidefawl.qubes.vec.Matrix4f) -> <init>
    32:33:nidefawl.qubes.models.qmodel.animation.KeyFrame copy() -> if
nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel -> iJlliJjIiJllL1L1:
    java.util.List listObjects -> do
    java.util.List listMaterials -> if
    java.util.List listTextures -> for
    java.util.List listBones -> int
    java.util.List listActions -> new
    java.util.List listEmpties -> try
    java.lang.String path -> do
    nidefawl.qubes.models.qmodel.QModelType modelType -> do
    30:31:void <init>() -> <init>
    50:143:void loadModel(nidefawl.qubes.assets.AssetBinary) -> do
    177:183:nidefawl.qubes.models.qmodel.QModelBone findJoint(java.lang.String) -> do
    186:192:nidefawl.qubes.models.qmodel.QModelNode findEmpty(java.lang.String) -> do
    207:207:nidefawl.qubes.models.qmodel.ModelBlock buildBlockModel() -> do
    211:216:nidefawl.qubes.models.qmodel.ModelQModel buildModel() -> do
    221:227:java.lang.String getModelName() -> do
nidefawl.qubes.models.qmodel.loader.ModelLoaderQModel$1 -> IjiJL1L1llJi1Lll:
    int[] $SwitchMap$nidefawl$qubes$models$qmodel$QModelType -> do
    211:211:void <clinit>() -> <clinit>
nidefawl.qubes.models.render.QModelBatchedRender -> L11LjIlllliJIjJi:
    nidefawl.qubes.shader.ShaderBuffer ssbo_model_modelmat -> do
    nidefawl.qubes.shader.ShaderBuffer ssbo_model_normalmat -> if
    nidefawl.qubes.shader.ShaderBuffer ssbo_model_bonemat -> for
    nidefawl.qubes.shader.Shader[] shaderSkinned -> do
    nidefawl.qubes.shader.Shader[] shader -> if
    boolean startup -> for
    java.nio.FloatBuffer bufBoneMat -> do
    java.nio.FloatBuffer bufNormalMat -> if
    java.nio.FloatBuffer bufModelMat -> for
    nidefawl.qubes.models.render.QModelBatchedRender$QModelRenderSubList[] tmpLists -> do
    java.util.List subLists -> do
    nidefawl.qubes.vec.Matrix4f tmpMat1 -> do
    int nxtIdx -> do
    boolean isModelViewer -> do
    int pass -> if
    int shadowVP -> for
    int renderer -> byte
    nidefawl.qubes.vec.Matrix4f tmpMatrix1 -> if
    nidefawl.qubes.vec.Matrix4f tmpMatrix2 -> for
    20:66:void <init>() -> <init>
    42:42:void preinit() -> for
    70:76:void setPass(int,int) -> a_
    78:79:void setRenderer(int) -> do
    86:120:void render(float) -> do
    124:172:void initShaders() -> int
    175:189:void begin() -> new
    192:197:void end() -> try
    200:205:void sync() -> byte
    209:209:java.nio.FloatBuffer getBufModelMat() -> do
    213:213:java.nio.FloatBuffer getBufNormalMat() -> if
    217:217:java.nio.FloatBuffer getBufBoneMat() -> for
    336:341:void reset() -> case
    345:349:void addObject(nidefawl.qubes.models.qmodel.QModelObject) -> do
    352:366:nidefawl.qubes.models.render.QModelBatchedRender$QModelRenderSubList getSubList(nidefawl.qubes.models.qmodel.QModelObject,nidefawl.qubes.models.qmodel.QModelGroup) -> do
    375:376:void init() -> do
    31:250:void <clinit>() -> <clinit>
nidefawl.qubes.models.render.QModelBatchedRender$1 -> iJJiiJJiJiIjJiL1:
    int val$iRENDER -> do
    nidefawl.qubes.models.render.QModelBatchedRender this$0 -> do
    130:130:void <init>(nidefawl.qubes.models.render.QModelBatchedRender,int) -> <init>
    133:135:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.models.render.QModelBatchedRender$2 -> JillL1iJIjIj1LjI:
    int val$iRENDER -> do
    nidefawl.qubes.models.render.QModelBatchedRender this$0 -> do
    138:138:void <init>(nidefawl.qubes.models.render.QModelBatchedRender,int) -> <init>
    141:149:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.models.render.QModelBatchedRender$QModelRenderSubList -> iJiJiJlliJ1LIj1L:
    boolean isSkinned -> do
    nidefawl.qubes.models.qmodel.ModelQModel model -> do
    nidefawl.qubes.models.qmodel.QModelObject object -> do
    nidefawl.qubes.models.qmodel.QModelGroup group -> do
    nidefawl.qubes.models.qmodel.QModelMaterial material -> do
    nidefawl.qubes.models.qmodel.QModelTexture tex -> do
    nidefawl.qubes.models.render.QModelBatchedRender$ReallocFloatBuf buf1 -> do
    nidefawl.qubes.models.render.QModelBatchedRender$ReallocFloatBuf buf2 -> if
    nidefawl.qubes.models.render.QModelBatchedRender$ReallocFloatBuf buf3 -> for
    int instances -> do
    251:260:void <init>() -> <init>
    264:268:boolean matches(nidefawl.qubes.models.qmodel.ModelQModel,nidefawl.qubes.models.qmodel.QModelObject,nidefawl.qubes.models.qmodel.QModelGroup) -> do
    272:278:void set(nidefawl.qubes.models.qmodel.ModelQModel,nidefawl.qubes.models.qmodel.QModelObject,nidefawl.qubes.models.qmodel.QModelGroup) -> do
    281:312:void add(nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelObject,nidefawl.qubes.models.qmodel.QModelGroup) -> do
    316:318:void put(java.nio.FloatBuffer,java.nio.FloatBuffer) -> do
    320:323:void putSkinned(java.nio.FloatBuffer,java.nio.FloatBuffer,java.nio.FloatBuffer) -> do
    325:332:void reset() -> do
nidefawl.qubes.models.render.QModelBatchedRender$ReallocFloatBuf -> iJ1LiJJiL1JiJi1L:
    int pos -> do
    float[] matBuf -> do
    221:223:void <init>() -> <init>
    225:230:int realloc(int) -> do
    234:234:int left() -> do
    241:246:void store(nidefawl.qubes.vec.Matrix4f) -> do
nidefawl.qubes.models.render.QModelDirectRender -> jI1LIjjIIjL1jI1L:
    java.util.List subLists -> do
    nidefawl.qubes.shader.Shader shaderModel -> do
    boolean startup -> do
    17:22:void <init>() -> <init>
    27:42:void initShaders() -> int
    44:45:void reset() -> case
    50:69:void render(float) -> do
    73:74:void addObject(nidefawl.qubes.models.qmodel.QModelObject) -> do
    77:78:void init() -> do
nidefawl.qubes.models.render.QModelRender -> JiIjJiJi1LllL1Ij:
    java.util.ArrayList rendered -> do
    nidefawl.qubes.models.qmodel.ModelQModel model -> do
    nidefawl.qubes.gl.BufferedMatrix normalMat -> do
    nidefawl.qubes.gl.BufferedMatrix modelMat -> if
    13:20:void <init>() -> <init>
    22:23:void setModel(nidefawl.qubes.models.qmodel.ModelQModel) -> do
    void initShaders() -> int
    void reset() -> case
    void render(float) -> do
    void addObject(nidefawl.qubes.models.qmodel.QModelObject) -> do
    30:31:void renderGroup(nidefawl.qubes.models.qmodel.ModelQModel,nidefawl.qubes.models.qmodel.QModelObject,nidefawl.qubes.models.qmodel.QModelGroup,float) -> do
nidefawl.qubes.nbt.Tag -> ll1LIjiJll1LL1Ji:
    java.lang.String name -> do
    15:33:void <init>() -> <init>
    814:814:java.lang.String getName() -> do
    nidefawl.qubes.nbt.Tag$TagType getType() -> do
    void writeData(java.io.DataOutput) -> do
    void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    826:829:void write(nidefawl.qubes.nbt.Tag,java.io.DataOutput) -> do
    832:840:nidefawl.qubes.nbt.Tag read(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    844:878:nidefawl.qubes.nbt.Tag newFromType(nidefawl.qubes.nbt.Tag$TagType) -> if
    883:889:java.lang.String readString(java.io.DataInput) -> do
    893:900:void writeString(java.lang.String,java.io.DataOutput) -> do
    903:904:void setName(java.lang.String) -> do
    911:915:nidefawl.qubes.nbt.Tag$TagList wrapStringList(java.util.Collection) -> do
    923:927:java.util.ArrayList unwrapStringList(java.util.Collection) -> do
    15:15:nidefawl.qubes.nbt.Tag access$000(nidefawl.qubes.nbt.Tag$TagType) -> do
nidefawl.qubes.nbt.Tag$1 -> lljI1L1LjIjI1LiJ:
    int[] $SwitchMap$nidefawl$qubes$nbt$Tag$TagType -> do
    844:844:void <clinit>() -> <clinit>
nidefawl.qubes.nbt.Tag$BlockPos3 -> llIjjI1LiJllJiL1:
    nidefawl.qubes.vec.BlockPos data -> do
    619:621:void <init>(nidefawl.qubes.vec.BlockPos) -> <init>
    623:624:void <init>() -> <init>
    628:631:void writeData(java.io.DataOutput) -> do
    634:639:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    643:643:nidefawl.qubes.nbt.Tag$TagType getType() -> do
nidefawl.qubes.nbt.Tag$Byte -> L1iJiJIjjIllJiJi:
    byte byteVal -> do
    61:63:void <init>(int) -> <init>
    65:66:void <init>() -> <init>
    70:71:void writeData(java.io.DataOutput) -> do
    75:75:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    85:87:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    90:90:byte getByte() -> do
nidefawl.qubes.nbt.Tag$ByteArray -> llIjJiiJiJIjIjjI:
    byte[] data -> do
    102:104:void <init>(byte[]) -> <init>
    106:107:void <init>() -> <init>
    111:113:void writeData(java.io.DataOutput) -> do
    117:117:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    127:135:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    138:139:void setArray(byte[]) -> do
    142:142:byte[] getArray() -> do
nidefawl.qubes.nbt.Tag$Compound -> iJIjIjllL1IjJi:
    java.util.Map data -> do
    362:364:void <init>() -> <init>
    368:368:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    378:393:void writeData(java.io.DataOutput) -> do
    397:416:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    419:419:java.util.Map getMap() -> do
    423:425:void set(java.lang.String,nidefawl.qubes.nbt.Tag) -> do
    428:429:void setInt(java.lang.String,int) -> do
    432:433:void setLong(java.lang.String,long) -> do
    436:437:void setByteArray(java.lang.String,byte[]) -> do
    440:441:nidefawl.qubes.nbt.Tag$ByteArray getByteArray(java.lang.String) -> do
    445:445:nidefawl.qubes.nbt.Tag get(java.lang.String) -> do
    454:455:nidefawl.qubes.vec.Vector3f getVec3(java.lang.String) -> do
    459:460:void setVec3(java.lang.String,nidefawl.qubes.vec.Vector3f) -> do
    463:464:java.util.UUID getUUID(java.lang.String) -> do
    468:469:void setUUID(java.lang.String,java.util.UUID) -> do
    472:473:int getByte(java.lang.String) -> do
    477:478:void setByte(java.lang.String,int) -> if
    482:483:void setBoolean(java.lang.String,boolean) -> do
    486:487:int getInt(java.lang.String) -> if
    491:492:long getLong(java.lang.String) -> do
    496:496:boolean getBoolean(java.lang.String) -> do
    501:502:java.util.List getList(java.lang.String) -> do
    511:512:void setList(java.lang.String,nidefawl.qubes.nbt.Tag$TagList) -> do
    519:520:void setString(java.lang.String,java.lang.String) -> do
    527:528:java.lang.String getString(java.lang.String) -> do
    532:533:void setBlockPos(java.lang.String,nidefawl.qubes.vec.BlockPos) -> do
    535:536:nidefawl.qubes.vec.BlockPos getBlockPos(java.lang.String) -> do
nidefawl.qubes.nbt.Tag$Double -> iJJi1LiJIjJi1LIj:
    double doubleVal -> do
    152:153:void <init>() -> <init>
    159:160:void writeData(java.io.DataOutput) -> do
    164:164:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    174:176:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$End -> L1iJJiL1jIjIJiIj:
    35:35:void <init>() -> <init>
    44:44:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    49:49:void writeData(java.io.DataOutput) -> do
    53:53:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Float -> L1L1L1JiL1jIL1Ji:
    float floatVal -> do
    540:540:void <init>() -> <init>
    546:547:void writeData(java.io.DataOutput) -> do
    551:551:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    561:563:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Int -> L1L1JiJiiJiJiJiJ:
    int data -> do
    578:580:void <init>(int) -> <init>
    582:583:void <init>() -> <init>
    587:588:void writeData(java.io.DataOutput) -> do
    592:592:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    602:604:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    607:607:int getInt() -> do
nidefawl.qubes.nbt.Tag$IntMap -> jIiJL1iJIjIjlljI:
    java.util.Map data -> do
    316:319:void <init>() -> <init>
    322:322:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    332:339:void writeData(java.io.DataOutput) -> do
    343:352:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$Long -> ll1LL1JiL1JiiJJi:
    long data -> do
    702:704:void <init>(long) -> <init>
    705:706:void <init>() -> <init>
    710:711:void writeData(java.io.DataOutput) -> do
    715:715:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    725:727:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    730:730:long getLong() -> do
nidefawl.qubes.nbt.Tag$Short -> JiL1L11LL1jIL1:
    short data -> do
    779:779:void <init>() -> <init>
    785:786:void writeData(java.io.DataOutput) -> do
    790:790:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    800:802:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
nidefawl.qubes.nbt.Tag$StringTag -> L1iJ1LL1llJi1L1L:
    java.lang.String data -> if
    661:663:void <init>(java.lang.String) -> <init>
    665:666:void <init>() -> <init>
    670:670:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    680:682:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    686:687:void writeData(java.io.DataOutput) -> do
    694:694:java.lang.String getString() -> if
nidefawl.qubes.nbt.Tag$TagList -> ll1L1L1LjIjIJi1L:
    java.util.List data -> do
    nidefawl.qubes.nbt.Tag$TagType tagType -> do
    237:239:void <init>() -> <init>
    244:257:void writeData(java.io.DataOutput) -> do
    261:261:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    269:269:int getSize() -> do
    274:295:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    298:298:java.util.List getList() -> do
    302:308:void add(nidefawl.qubes.nbt.Tag) -> do
    311:311:nidefawl.qubes.nbt.Tag$TagType getListTagType() -> if
nidefawl.qubes.nbt.Tag$TagType -> iJJiJiiJL1L1llJi:
    nidefawl.qubes.nbt.Tag$TagType END -> do
    nidefawl.qubes.nbt.Tag$TagType BYTE -> if
    nidefawl.qubes.nbt.Tag$TagType SHORT -> for
    nidefawl.qubes.nbt.Tag$TagType INT -> int
    nidefawl.qubes.nbt.Tag$TagType LONG -> new
    nidefawl.qubes.nbt.Tag$TagType FLOAT -> try
    nidefawl.qubes.nbt.Tag$TagType DOUBLE -> byte
    nidefawl.qubes.nbt.Tag$TagType BYTEARRAY -> case
    nidefawl.qubes.nbt.Tag$TagType STRING -> char
    nidefawl.qubes.nbt.Tag$TagType LIST -> else
    nidefawl.qubes.nbt.Tag$TagType COMPOUND -> goto
    nidefawl.qubes.nbt.Tag$TagType VEC3 -> long
    nidefawl.qubes.nbt.Tag$TagType UUID -> this
    nidefawl.qubes.nbt.Tag$TagType INT_MAP -> void
    nidefawl.qubes.nbt.Tag$TagType BLOCK_POS -> break
    nidefawl.qubes.nbt.Tag$TagType[] $VALUES -> do
    17:17:nidefawl.qubes.nbt.Tag$TagType[] values() -> values
    17:17:nidefawl.qubes.nbt.Tag$TagType valueOf(java.lang.String) -> valueOf
    17:17:void <init>(java.lang.String,int) -> <init>
    20:20:int getID() -> do
    24:24:nidefawl.qubes.nbt.Tag$TagType fromID(int) -> do
    17:18:void <clinit>() -> <clinit>
nidefawl.qubes.nbt.Tag$UUIDTag -> lljIlllllliJjIL1:
    java.util.UUID data -> do
    742:744:void <init>(java.util.UUID) -> <init>
    746:747:void <init>() -> <init>
    751:753:void writeData(java.io.DataOutput) -> do
    757:757:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    767:769:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    772:772:java.util.UUID getUUID() -> do
nidefawl.qubes.nbt.Tag$Vec3Tag -> jIL1L1iJIjJillll:
    nidefawl.qubes.vec.Vector3f vec3 -> do
    190:192:void <init>(nidefawl.qubes.vec.Vector3f) -> <init>
    195:196:void <init>() -> <init>
    202:205:void writeData(java.io.DataOutput) -> do
    209:209:nidefawl.qubes.nbt.Tag$TagType getType() -> do
    219:221:void readData(java.io.DataInput,nidefawl.qubes.nbt.TagReadLimiter) -> do
    232:232:nidefawl.qubes.vec.Vector3f getVec3() -> do
nidefawl.qubes.nbt.TagReadLimiter -> iJJiL1IjiJJijIL1:
    nidefawl.qubes.nbt.TagReadLimiter UNLIMITED -> do
    int totalReadBytes -> do
    int limit -> if
    int maxStackDepth -> for
    int stackDepth -> int
    12:16:void <init>() -> <init>
    25:29:void add(int) -> do
    31:35:void push() -> do
    37:38:void pop() -> if
    6:6:void <clinit>() -> <clinit>
nidefawl.qubes.nbt.TagReadLimiter$1 -> iJJillIjiJllL1Ij:
    6:6:void <init>() -> <init>
    7:7:void add(int) -> do
    8:8:void push() -> do
    9:9:void pop() -> if
nidefawl.qubes.nbt.TagReader -> llL1L1IjJiiJJill:
    29:30:nidefawl.qubes.nbt.Tag readTagFromCompressedBytes(byte[]) -> do
    34:39:byte[] writeTagToCompresedBytes(nidefawl.qubes.nbt.Tag) -> do
    43:45:nidefawl.qubes.nbt.Tag readTagFromFile(java.io.File) -> do
    49:52:void writeTagToFile(nidefawl.qubes.nbt.Tag,java.io.File) -> do
nidefawl.qubes.network.Connection -> lljIJiiJllllL1Ji:
    boolean isConnected -> do
    boolean cleanUp -> if
    java.util.concurrent.LinkedBlockingQueue incoming -> do
    java.util.concurrent.LinkedBlockingQueue outgoing -> if
    java.lang.Throwable readWriteException -> do
    int disconnectFrom -> do
    java.lang.String disconnectReason -> do
    16:25:void <init>() -> <init>
    28:28:boolean isConnected() -> do
    boolean readPackets() -> if
    boolean writePackets() -> for
    38:41:void onError(java.lang.Exception) -> do
    44:47:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    50:70:void validateConnection() -> do
    73:80:void onDisconnect() -> new
    83:83:void closeSocket() -> if
    86:86:void interruptThreads() -> for
    89:110:void disconnect(int,java.lang.String) -> do
    113:113:void immediateDisconnect(java.lang.String) -> do
    116:116:boolean finished() -> int
    120:120:nidefawl.qubes.network.packet.Packet pollPacket() -> do
    124:124:java.util.concurrent.LinkedBlockingQueue getIncoming() -> do
    128:128:int getDisconnectFrom() -> do
    132:132:java.lang.String getDisconnectReason() -> do
    136:136:java.net.InetSocketAddress getAddr() -> do
    java.lang.String getHostnameString() -> if
    142:142:void startThreads() -> int
    int getCompression() -> if
nidefawl.qubes.network.Handler -> JiJiiJllL1iJIjjI:
    7:7:void <init>() -> <init>
    boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    void onDisconnect(int,java.lang.String) -> do
    27:27:void handleHandshake(nidefawl.qubes.network.packet.PacketHandshake) -> do
    30:30:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    34:34:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    37:37:void handleSpawnInWorld(nidefawl.qubes.network.packet.PacketSSpawnInWorld) -> do
    40:40:void handleAuth(nidefawl.qubes.network.packet.PacketAuth) -> do
    43:43:void handleMovement(nidefawl.qubes.network.packet.PacketCMovement) -> do
    47:47:void handleChunkDataMulti(nidefawl.qubes.network.packet.PacketSChunkData,int) -> do
    50:50:void handleBlockAction(nidefawl.qubes.network.packet.PacketCBlockAction) -> do
    54:54:void handleSetBlocks(nidefawl.qubes.network.packet.PacketCSetBlocks) -> do
    57:57:void handleBlock(nidefawl.qubes.network.packet.PacketSSetBlock) -> do
    60:60:void handleMultiBlock(nidefawl.qubes.network.packet.PacketSSetBlocks) -> do
    64:67:void handlePackets(java.util.concurrent.LinkedBlockingQueue) -> do
    70:70:void handleLightChunk(nidefawl.qubes.network.packet.PacketSLightChunk) -> do
    77:77:void handleTrackChunk(nidefawl.qubes.network.packet.PacketSTrackChunk) -> do
    83:83:void handleClientSettings(nidefawl.qubes.network.packet.PacketCSettings) -> do
    90:90:void handleSwitchWorld(nidefawl.qubes.network.packet.PacketCSwitchWorld) -> do
    97:97:void handleChat(nidefawl.qubes.network.packet.PacketChatMessage) -> do
    104:104:void handleChannels(nidefawl.qubes.network.packet.PacketChatChannels) -> do
    111:111:void handleWorldTime(nidefawl.qubes.network.packet.PacketSWorldTime) -> do
    118:118:void handleTeleport(nidefawl.qubes.network.packet.PacketSTeleport) -> do
    124:124:void handleSync(nidefawl.qubes.network.packet.PacketSyncBlocks) -> do
    131:131:void handleTeleportAck(nidefawl.qubes.network.packet.PacketCTeleportAck) -> do
    137:137:void handleEntityUntrack(nidefawl.qubes.network.packet.PacketSEntityUnTrack) -> do
    143:143:void handleEntityTrack(nidefawl.qubes.network.packet.PacketSEntityTrack) -> do
    149:149:void handleEntityMove(nidefawl.qubes.network.packet.PacketSEntityMove) -> do
    155:155:void handleWorldBiomes(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    158:158:void handleDigState(nidefawl.qubes.network.packet.PacketCDigState) -> do
    161:161:void handleServerDigState(nidefawl.qubes.network.packet.PacketSDigState) -> do
    164:164:void handleDebugBBs(nidefawl.qubes.network.packet.PacketSDebugBB) -> do
    167:167:void handleInvClick(nidefawl.qubes.network.packet.PacketCInvClick) -> do
    170:170:void handleInvSync(nidefawl.qubes.network.packet.PacketSInvSync) -> do
    173:173:void handleCrafting(nidefawl.qubes.network.packet.PacketCCrafting) -> do
    176:176:void handleCraftingProgress(nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
    179:179:void handleInvSyncIncr(nidefawl.qubes.network.packet.PacketSInvSyncIncr) -> do
    182:182:void handleInvCarried(nidefawl.qubes.network.packet.PacketSInvCarried) -> do
    185:185:void handleInvTransaction(nidefawl.qubes.network.packet.PacketCInvTransaction) -> do
    188:188:void handleDebugPath(nidefawl.qubes.network.packet.PacketSDebugPath) -> do
    191:191:void handleSetProperty(nidefawl.qubes.network.packet.PacketCSetProperty) -> do
    194:194:void handleEntityProperties(nidefawl.qubes.network.packet.PacketSEntityProperties) -> do
    197:197:void handleEntityEquip(nidefawl.qubes.network.packet.PacketSEntityEquip) -> do
    200:200:void handleListReq(nidefawl.qubes.network.packet.PacketCListRequest) -> do
    203:203:void handleList(nidefawl.qubes.network.packet.PacketSList) -> do
    206:206:void handleLogin(nidefawl.qubes.network.packet.PacketSLogin) -> do
    209:209:void handleParticles(nidefawl.qubes.network.packet.PacketSParticles) -> do
nidefawl.qubes.network.MemoryConnection -> Ijll1LllL1L1llIj:
    boolean isClient -> if
    nidefawl.qubes.network.MemoryConnection otherEnd -> do
    12:14:void <init>(boolean) -> <init>
    17:18:void setOtherEnd(nidefawl.qubes.network.MemoryConnection) -> do
    22:22:java.lang.String getHostnameString() -> if
    27:28:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    32:32:boolean readPackets() -> if
    37:37:boolean writePackets() -> for
    42:42:int getCompression() -> if
nidefawl.qubes.network.ReaderThread -> L1IjJiiJlliJL1ll:
    int ACTIVE_THREADS -> do
    nidefawl.qubes.network.Connection conn -> do
    boolean interrupted -> do
    7:13:void <init>(nidefawl.qubes.network.Connection) -> <init>
    16:20:void interruptThread() -> do
    24:45:void run() -> run
    4:4:void <clinit>() -> <clinit>
nidefawl.qubes.network.StreamIO -> IjllJijIllIjlliJ:
    void read(java.io.DataInput) -> do
    void write(java.io.DataOutput) -> do
nidefawl.qubes.network.TCPConnection -> JiiJlljIL1IjJi1L:
    java.net.Socket socket -> do
    java.io.DataInputStream inStream -> do
    java.io.DataOutputStream outStream -> do
    nidefawl.qubes.network.ReaderThread readThread -> do
    nidefawl.qubes.network.WriterThread writeThread -> do
    17:23:void <init>(java.net.Socket) -> <init>
    26:29:void startThreads() -> int
    33:40:boolean readPackets() -> if
    44:53:boolean writePackets() -> for
    56:59:void immediateDisconnect(java.lang.String) -> do
    62:62:java.net.InetSocketAddress getAddr() -> do
    66:66:java.lang.String getHostnameString() -> if
    71:82:void closeSocket() -> if
    85:87:void interruptThreads() -> for
    91:91:int getCompression() -> if
nidefawl.qubes.network.WriterThread -> iJIjIjiJiJL1JiL1:
    int ACTIVE_THREADS -> do
    nidefawl.qubes.network.Connection conn -> do
    boolean interrupted -> do
    6:12:void <init>(nidefawl.qubes.network.Connection) -> <init>
    15:19:void interruptThread() -> do
    23:46:void run() -> run
    4:4:void <clinit>() -> <clinit>
nidefawl.qubes.network.client.ClientHandler -> iJJiJiIjIjL1L1L1:
    int state -> do
    java.lang.String disconnectReason -> do
    long time -> do
    int disconnectFrom -> if
    nidefawl.qubes.network.client.NetworkClient client -> do
    nidefawl.qubes.chunk.client.ChunkManagerClient chunkManager -> do
    nidefawl.qubes.entity.PlayerSelf player -> do
    nidefawl.qubes.world.WorldClient world -> do
    java.util.zip.Inflater inflate -> do
    int i10Meg -> for
    byte[] tmpBuffer -> do
    java.util.ArrayList worldList -> do
    47:67:void <init>(nidefawl.qubes.network.client.NetworkClient) -> <init>
    76:83:void update() -> do
    87:88:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    92:103:void handleHandshake(nidefawl.qubes.network.packet.PacketHandshake) -> do
    106:115:void handleSync(nidefawl.qubes.network.packet.PacketSyncBlocks) -> do
    117:122:void handleLogin(nidefawl.qubes.network.packet.PacketSLogin) -> do
    125:140:void handleAuth(nidefawl.qubes.network.packet.PacketAuth) -> do
    144:144:java.lang.String getHandlerName() -> do
    149:150:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    153:153:int getState() -> do
    159:163:void onDisconnect(int,java.lang.String) -> do
    165:167:java.lang.String getDisconnectReason() -> if
    172:186:void handleSpawnInWorld(nidefawl.qubes.network.packet.PacketSSpawnInWorld) -> do
    192:198:void handleTeleport(nidefawl.qubes.network.packet.PacketSTeleport) -> do
    201:202:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    205:208:void byteToShortArray(byte[],short[],int) -> do
    214:239:void handleChunkDataMulti(nidefawl.qubes.network.packet.PacketSChunkData,int) -> do
    242:312:void processChunkData(nidefawl.qubes.network.packet.PacketSChunkData,byte[],int) -> do
    315:325:byte[] inflate(byte[]) -> do
    330:330:boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    334:335:void handleBlock(nidefawl.qubes.network.packet.PacketSSetBlock) -> do
    338:364:void handleMultiBlock(nidefawl.qubes.network.packet.PacketSSetBlocks) -> do
    367:385:void handleLightChunk(nidefawl.qubes.network.packet.PacketSLightChunk) -> do
    387:391:void handleTrackChunk(nidefawl.qubes.network.packet.PacketSTrackChunk) -> do
    394:395:void handleChat(nidefawl.qubes.network.packet.PacketChatMessage) -> do
    398:400:void handleChannels(nidefawl.qubes.network.packet.PacketChatChannels) -> do
    406:410:void handleWorldTime(nidefawl.qubes.network.packet.PacketSWorldTime) -> do
    416:420:void handleEntityUntrack(nidefawl.qubes.network.packet.PacketSEntityUnTrack) -> do
    426:437:void handleEntityTrack(nidefawl.qubes.network.packet.PacketSEntityTrack) -> do
    443:456:void handleEntityMove(nidefawl.qubes.network.packet.PacketSEntityMove) -> do
    460:462:void handleWorldBiomes(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    464:465:void handleServerDigState(nidefawl.qubes.network.packet.PacketSDigState) -> do
    467:471:void handleDebugBBs(nidefawl.qubes.network.packet.PacketSDebugBB) -> do
    473:476:void handleDebugPath(nidefawl.qubes.network.packet.PacketSDebugPath) -> do
    479:486:void handleInvSync(nidefawl.qubes.network.packet.PacketSInvSync) -> do
    488:495:void handleInvSyncIncr(nidefawl.qubes.network.packet.PacketSInvSyncIncr) -> do
    497:507:void handleCraftingProgress(nidefawl.qubes.network.packet.PacketSCraftingProgress) -> do
    510:515:void handleInvCarried(nidefawl.qubes.network.packet.PacketSInvCarried) -> do
    519:525:void handleEntityProperties(nidefawl.qubes.network.packet.PacketSEntityProperties) -> do
    530:534:void handleEntityEquip(nidefawl.qubes.network.packet.PacketSEntityEquip) -> do
    537:548:void handleList(nidefawl.qubes.network.packet.PacketSList) -> do
    551:552:void handleParticles(nidefawl.qubes.network.packet.PacketSParticles) -> do
    44:44:void access$000(nidefawl.qubes.network.client.ClientHandler,nidefawl.qubes.network.packet.PacketSChunkData,byte[],int) -> do
nidefawl.qubes.network.client.ClientHandler$1 -> llJi1LiJjIllll1L:
    byte[] decpressData -> do
    nidefawl.qubes.network.packet.PacketSChunkData val$packet -> do
    int val$flags -> do
    nidefawl.qubes.network.client.ClientHandler this$0 -> do
    215:215:void <init>(nidefawl.qubes.network.client.ClientHandler,nidefawl.qubes.network.packet.PacketSChunkData,int) -> <init>
    219:223:java.lang.Void call() -> do
    227:230:void post() -> post
    233:233:nidefawl.qubes.async.AsyncTask$TaskType getType() -> getType
    215:215:java.lang.Object call() -> call
nidefawl.qubes.network.client.ClientHandler$2 -> JiL11LiJ1LIjIjJi:
    int[] $SwitchMap$nidefawl$qubes$io$network$DataListType -> do
    537:537:void <clinit>() -> <clinit>
nidefawl.qubes.network.client.NetworkClient -> jIIjjIlliJL1jIJi:
    nidefawl.qubes.network.client.ClientHandler handler -> do
    nidefawl.qubes.network.Connection conn -> do
    int netVersion -> do
    16:39:void <init>(java.lang.String,short,boolean) -> <init>
    43:63:void update() -> do
    65:86:void processLogin() -> if
    88:88:nidefawl.qubes.network.client.ClientHandler getClient() -> do
    92:92:boolean isConnected() -> do
    97:98:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    101:102:void disconnect(java.lang.String) -> do
    106:107:void onKick(int,java.lang.String) -> do
nidefawl.qubes.network.client.ThreadConnect -> lljIIj1LL1:
    java.lang.String host -> do
    int port -> do
    java.lang.Thread thread -> do
    boolean finished -> do
    boolean cancelled -> if
    boolean connected -> for
    java.lang.String stateStr -> if
    boolean isLocalAttempt -> int
    15:24:void <init>(java.lang.String,int,boolean) -> <init>
    28:66:void run() -> run
    69:73:void startThread() -> do
    76:76:java.lang.String getState() -> do
    79:80:void cancel() -> if
nidefawl.qubes.network.packet.AbstractPacketWorldRef -> L1iJJiJi1L1L1LL1:
    int worldID -> do
    11:12:void <init>() -> <init>
    14:16:void <init>(int) -> <init>
    20:21:void readPacket(java.io.DataInput) -> do
    25:26:void writePacket(java.io.DataOutput) -> do
    29:29:int getWorldId() -> do
nidefawl.qubes.network.packet.InvalidPacketException -> Ij1L1LL1jIll1LIj:
    java.lang.Class clazz -> do
    9:11:void <init>(java.lang.Class,java.lang.Exception) -> <init>
    14:15:void <init>(java.lang.String) -> <init>
    18:19:void <init>(java.lang.String,java.lang.Exception) -> <init>
    22:22:java.lang.Class getClazz() -> do
nidefawl.qubes.network.packet.Packet -> L1IjJijIIjiJJiIj:
    int NEXT_PACKET_ID -> do
    java.lang.Class[] packets -> do
    boolean[] sentByServer -> do
    boolean[] sentByClient -> if
    java.util.Map classToIDMap -> do
    int id -> if
    nidefawl.qubes.network.packet.Packet lastSuccess -> do
    74:76:void <init>() -> <init>
    80:92:nidefawl.qubes.network.packet.Packet read(java.io.DataInput) -> do
    96:98:void write(nidefawl.qubes.network.packet.Packet,java.io.DataOutput) -> do
    102:102:nidefawl.qubes.network.packet.Packet makePacket(int) -> do
    void readPacket(java.io.DataInput) -> do
    void writePacket(java.io.DataOutput) -> do
    void handle(nidefawl.qubes.network.Handler) -> do
    112:120:nidefawl.qubes.network.packet.Packet makePacket(java.lang.Class) -> do
    124:124:int getID() -> do
    128:133:void register(java.lang.Class,boolean,boolean) -> do
    142:142:java.lang.String readString(java.io.DataInput) -> do
    146:153:java.lang.String readString(java.io.DataInput,int) -> do
    156:163:void writeString(java.lang.String,java.io.DataOutput) -> do
    166:178:nidefawl.qubes.item.BaseStack readStack(java.io.DataInput) -> do
    184:195:void writeStack(nidefawl.qubes.item.BaseStack,java.io.DataOutput) -> do
    21:78:void <clinit>() -> <clinit>
nidefawl.qubes.network.packet.PacketAuth -> JiiJllIjiJL1L1iJ:
    java.lang.String name -> do
    boolean success -> do
    11:12:void <init>() -> <init>
    14:16:void <init>(java.lang.String) -> <init>
    22:25:void <init>(java.lang.String,boolean) -> <init>
    29:31:void readPacket(java.io.DataInput) -> do
    35:37:void writePacket(java.io.DataOutput) -> do
    41:42:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCBlockAction -> iJ1LIjJijIJijIJi:
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> if
    nidefawl.qubes.item.BlockStack stack -> do
    int action -> for
    16:19:void <init>() -> <init>
    18:35:void <init>(int,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,nidefawl.qubes.item.BlockStack,int) -> <init>
    39:46:void readPacket(java.io.DataInput) -> do
    50:56:void writePacket(java.io.DataOutput) -> do
    62:65:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCCrafting -> JiiJllL1lljIjI:
    int catid -> do
    int recipeid -> if
    int action -> for
    int amount -> int
    14:15:void <init>() -> <init>
    18:19:void <init>(int,int,int) -> <init>
    21:26:void <init>(int,int,int,int) -> <init>
    31:35:void readPacket(java.io.DataInput) -> do
    39:43:void writePacket(java.io.DataOutput) -> do
    47:48:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCDigState -> IjjIIjIjiJiJjIll:
    nidefawl.qubes.vec.BlockPos pos -> do
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> if
    nidefawl.qubes.item.BaseStack stack -> do
    int stage -> for
    14:18:void <init>() -> <init>
    17:30:void <init>(int,int,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,nidefawl.qubes.item.BaseStack) -> <init>
    34:40:void readPacket(java.io.DataInput) -> do
    44:50:void writePacket(java.io.DataOutput) -> do
    56:58:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCInvClick -> llIjL1IjjIll1LiJ:
    int id -> do
    int idx -> if
    int button -> for
    int action -> int
    nidefawl.qubes.item.BaseStack stack -> do
    16:17:void <init>() -> <init>
    20:26:void <init>(int,int,int,int,nidefawl.qubes.item.BaseStack) -> <init>
    31:36:void readPacket(java.io.DataInput) -> do
    40:45:void writePacket(java.io.DataOutput) -> do
    49:50:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCInvTransaction -> IjIjJi1L1LIjllJi:
    int id -> do
    int action -> if
    12:13:void <init>() -> <init>
    16:19:void <init>(int,int) -> <init>
    24:26:void readPacket(java.io.DataInput) -> do
    30:32:void writePacket(java.io.DataOutput) -> do
    36:37:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCListRequest -> jIIjL1L1IjJijIjI:
    int reqId -> do
    nidefawl.qubes.io.network.DataListType type -> do
    14:15:void <init>() -> <init>
    17:20:void <init>(int,nidefawl.qubes.io.network.DataListType) -> <init>
    24:26:void readPacket(java.io.DataInput) -> do
    30:32:void writePacket(java.io.DataOutput) -> do
    36:37:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCMovement -> Jillll1LIj1LIj1L:
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> do
    15:16:void <init>() -> <init>
    18:23:void <init>(nidefawl.qubes.vec.Vec3D,float,float,int) -> <init>
    27:31:void readPacket(java.io.DataInput) -> do
    35:41:void writePacket(java.io.DataOutput) -> do
    47:48:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSetBlocks -> L11LJiiJll1LJi:
    int x -> if
    int y -> for
    int z -> int
    int x2 -> new
    int y2 -> try
    int z2 -> byte
    nidefawl.qubes.item.BlockStack stack -> do
    int flags -> case
    nidefawl.qubes.vec.Vector3f fpos -> do
    int face -> char
    18:21:void <init>() -> <init>
    18:43:void <init>(int,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,int,nidefawl.qubes.item.BlockStack,boolean) -> <init>
    47:60:void readPacket(java.io.DataInput) -> do
    64:75:void writePacket(java.io.DataOutput) -> do
    81:83:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSetProperty -> iJL1jIjIJijIJi1L:
    int propVal -> do
    int propId -> if
    13:14:void <init>() -> <init>
    15:18:void <init>(int,int) -> <init>
    22:24:void readPacket(java.io.DataInput) -> do
    28:30:void writePacket(java.io.DataOutput) -> do
    34:35:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSettings -> JiJilliJJiL1Ijll:
    int chunkLoadDistance -> do
    10:11:void <init>() -> <init>
    13:15:void <init>(int) -> <init>
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:30:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCSwitchWorld -> IjiJL1L1iJjIjIIj:
    int flags -> do
    12:13:void <init>() -> <init>
    15:17:void <init>(int) -> <init>
    21:22:void readPacket(java.io.DataInput) -> do
    26:27:void writePacket(java.io.DataOutput) -> do
    33:34:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketCTeleportAck -> iJL1L1jI1LIjIj:
    int sync -> if
    10:11:void <init>() -> <init>
    15:17:void <init>(int,int) -> <init>
    21:23:void readPacket(java.io.DataInput) -> do
    27:29:void writePacket(java.io.DataOutput) -> do
    35:36:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketChatChannels -> jIjIIjL1jIJiL1Ij:
    java.util.ArrayList list -> do
    28:29:void <init>() -> <init>
    34:36:void <init>(java.util.Collection) -> <init>
    40:45:void readPacket(java.io.DataInput) -> do
    52:56:void writePacket(java.io.DataOutput) -> do
    68:69:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketChatMessage -> Ji1L1LL1iJllJiIj:
    java.lang.String channel -> do
    java.lang.String message -> if
    11:12:void <init>() -> <init>
    14:17:void <init>(java.lang.String,java.lang.String) -> <init>
    21:23:void readPacket(java.io.DataInput) -> do
    27:29:void writePacket(java.io.DataOutput) -> do
    33:34:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketDisconnect -> lliJllIjL1iJiJll:
    int code -> do
    java.lang.String message -> do
    8:11:void <init>() -> <init>
    8:16:void <init>(int,java.lang.String) -> <init>
    20:22:void readPacket(java.io.DataInput) -> do
    26:28:void writePacket(java.io.DataOutput) -> do
    32:33:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketHandshake -> Ij1LJiIjL1lliJll:
    int version -> do
    10:11:void <init>() -> <init>
    13:15:void <init>(int) -> <init>
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:30:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketPing -> jIJill1LjIjIiJ1L:
    long time -> do
    10:11:void <init>() -> <init>
    13:15:void <init>(long) -> <init>
    19:20:void readPacket(java.io.DataInput) -> do
    24:25:void writePacket(java.io.DataOutput) -> do
    29:30:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSChunkData -> JilljIJiL1IjJiiJ:
    int len -> if
    byte[] blocks -> do
    int flags -> for
    int[][] coords -> do
    15:16:void <init>() -> <init>
    18:19:void <init>(int) -> <init>
    23:33:void readPacket(java.io.DataInput) -> do
    37:46:void writePacket(java.io.DataOutput) -> do
    52:60:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSCraftingProgress -> llIjjIllll1LIj:
    int id -> do
    int action -> if
    long currentTime -> do
    long startTime -> if
    long endTime -> for
    int recipe -> for
    boolean finished -> do
    int amount -> int
    19:20:void <init>() -> <init>
    26:34:void readPacket(java.io.DataInput) -> do
    38:46:void writePacket(java.io.DataOutput) -> do
    50:51:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSDebugBB -> IjL1llL1L1iJIjiJ:
    java.util.List boxes -> do
    16:17:void <init>() -> <init>
    18:20:void <init>(java.util.List) -> <init>
    24:31:void readPacket(java.io.DataInput) -> do
    35:40:void writePacket(java.io.DataOutput) -> do
    44:45:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSDebugPath -> iJ1LiJllIjjIiJL1:
    java.util.List pts -> do
    16:17:void <init>() -> <init>
    24:32:void readPacket(java.io.DataInput) -> do
    36:43:void writePacket(java.io.DataOutput) -> do
    47:48:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSDigState -> IjJiiJIjllL1IjL1:
    int stage -> if
    11:12:void <init>() -> <init>
    17:19:void <init>(int,int) -> <init>
    23:25:void readPacket(java.io.DataInput) -> do
    29:31:void writePacket(java.io.DataOutput) -> do
    37:39:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityEquip -> JijIjI1LIjIjL1Ji:
    int entId -> do
    nidefawl.qubes.item.BaseStack[] stacks -> do
    21:22:void <init>() -> <init>
    23:26:void <init>(int,nidefawl.qubes.item.BaseStack[]) -> <init>
    30:36:void readPacket(java.io.DataInput) -> do
    40:45:void writePacket(java.io.DataOutput) -> do
    51:52:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityMove -> iJllJijIL1llJi1L:
    int entId -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> if
    float yawBodyOffset -> for
    24:25:void <init>() -> <init>
    26:33:void <init>(int,int,nidefawl.qubes.vec.Vec3D,float,float,float) -> <init>
    37:46:void readPacket(java.io.DataInput) -> do
    50:62:void writePacket(java.io.DataOutput) -> do
    68:69:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityProperties -> iJ1LIj1LJiIjL11L:
    int entId -> do
    nidefawl.qubes.nbt.Tag data -> do
    23:24:void <init>() -> <init>
    28:30:void readPacket(java.io.DataInput) -> do
    34:36:void writePacket(java.io.DataOutput) -> do
    42:43:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityTrack -> JiIjll1LlljIiJJi:
    int entId -> do
    int entType -> if
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float yawbody -> if
    float pitch -> for
    nidefawl.qubes.nbt.Tag data -> do
    30:31:void <init>() -> <init>
    35:45:void readPacket(java.io.DataInput) -> do
    49:66:void writePacket(java.io.DataOutput) -> do
    72:73:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSEntityUnTrack -> L1iJjI1LiJ1L1LiJ:
    int entId -> do
    21:22:void <init>() -> <init>
    24:26:void <init>(int) -> <init>
    30:31:void readPacket(java.io.DataInput) -> do
    35:36:void writePacket(java.io.DataOutput) -> do
    42:43:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSInvCarried -> IjlliJjIJiJiJi1L:
    nidefawl.qubes.inventory.slots.SlotStack stack -> do
    12:14:void <init>(nidefawl.qubes.inventory.slots.SlotStack) -> <init>
    15:16:void <init>() -> <init>
    21:23:void readPacket(java.io.DataInput) -> do
    27:28:void writePacket(java.io.DataOutput) -> do
    32:33:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSInvSync -> iJ1LJiL11Lll1LiJ:
    int invId -> do
    int invSize -> if
    java.util.Collection stacks -> do
    17:21:void <init>(int,int,java.util.Collection) -> <init>
    22:23:void <init>() -> <init>
    28:37:void readPacket(java.io.DataInput) -> do
    41:47:void writePacket(java.io.DataOutput) -> do
    51:52:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSInvSyncIncr -> IjJiIjjIllllllL1:
    int invId -> do
    java.util.Collection stacks -> do
    16:19:void <init>(int,java.util.Collection) -> <init>
    20:21:void <init>() -> <init>
    26:34:void readPacket(java.io.DataInput) -> do
    38:43:void writePacket(java.io.DataOutput) -> do
    47:48:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSLightChunk -> JiiJjIL1L1Ij:
    int coordX -> if
    int coordZ -> for
    byte[] data -> do
    short min -> do
    short max -> if
    byte flags -> do
    15:16:void <init>() -> <init>
    18:19:void <init>(int) -> <init>
    23:32:void readPacket(java.io.DataInput) -> do
    36:44:void writePacket(java.io.DataOutput) -> do
    50:53:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSList -> jIiJJiIj1LIj1LJi:
    int reqId -> do
    nidefawl.qubes.io.network.DataListType type -> do
    java.util.List list -> do
    19:20:void <init>() -> <init>
    22:26:void <init>(int,nidefawl.qubes.io.network.DataListType,java.util.List) -> <init>
    30:39:void readPacket(java.io.DataInput) -> do
    43:50:void writePacket(java.io.DataOutput) -> do
    54:55:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSLogin -> L1Ijll1LllIjL1Ij:
    9:10:void <init>() -> <init>
    15:15:void readPacket(java.io.DataInput) -> do
    19:19:void writePacket(java.io.DataOutput) -> do
    23:24:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSParticles -> JijIL1ll1LiJjIL1:
    nidefawl.qubes.vec.BlockPos pos -> do
    int type -> if
    int arg -> for
    15:17:void <init>() -> <init>
    19:23:void <init>(nidefawl.qubes.world.WorldServer,nidefawl.qubes.vec.BlockPos,int,int) -> <init>
    27:30:void handle(nidefawl.qubes.network.Handler) -> do
    33:37:void writePacket(java.io.DataOutput) -> do
    40:44:void readPacket(java.io.DataInput) -> do
nidefawl.qubes.network.packet.PacketSSetBlock -> iJ1LiJ1LiJjIll1L:
    int x -> if
    int y -> for
    int z -> int
    int type -> new
    int light -> try
    11:12:void <init>() -> <init>
    29:36:void readPacket(java.io.DataInput) -> do
    40:46:void writePacket(java.io.DataOutput) -> do
    52:54:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSSetBlocks -> JijIiJIjllL1L1jI:
    int chunkX -> if
    int chunkZ -> for
    short[] positions -> do
    short[] blocks -> if
    byte[] lights -> do
    short[] data -> for
    nidefawl.qubes.chunk.blockdata.BlockData[] bdata -> do
    int numBlockData -> int
    12:13:void <init>() -> <init>
    16:31:void <init>(int,int,int,short[],short[],byte[],short[],nidefawl.qubes.chunk.blockdata.BlockData[]) -> <init>
    43:73:void readPacket(java.io.DataInput) -> do
    77:98:void writePacket(java.io.DataOutput) -> do
    104:106:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSSpawnInWorld -> llL1iJIjiJL1IjIj:
    nidefawl.qubes.world.IWorldSettings worldSettings -> do
    nidefawl.qubes.world.biomes.IBiomeSettings biomeSettings -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    int flags -> do
    int entId -> if
    21:22:void <init>() -> <init>
    24:30:void <init>(int,nidefawl.qubes.world.IWorldSettings,nidefawl.qubes.world.biomes.IBiomeSettings,nidefawl.qubes.vec.Vec3D,int) -> <init>
    34:42:void readPacket(java.io.DataInput) -> do
    46:54:void writePacket(java.io.DataOutput) -> do
    60:66:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSTeleport -> llIj1LjIIjJiIjjI:
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    int flags -> if
    int sync -> for
    17:18:void <init>() -> <init>
    21:27:void <init>(int,int,nidefawl.qubes.vec.Vec3D,float,float,int) -> <init>
    31:37:void readPacket(java.io.DataInput) -> do
    41:49:void writePacket(java.io.DataOutput) -> do
    55:56:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSTrackChunk -> JijI1LJiIjJiIjiJ:
    int x -> if
    int z -> for
    boolean add -> do
    12:13:void <init>() -> <init>
    16:20:void <init>(int,int,int,boolean) -> <init>
    24:29:void readPacket(java.io.DataInput) -> do
    33:37:void writePacket(java.io.DataOutput) -> do
    41:43:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSWorldBiomes -> lllliJ1LL1iJjIiJ:
    int numBiomes -> if
    int[] coordsX -> do
    int[] coordsZ -> if
    byte[] biomes -> do
    25:26:void <init>() -> <init>
    34:44:void readPacket(java.io.DataInput) -> do
    48:55:void writePacket(java.io.DataOutput) -> do
    61:63:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSWorldTime -> iJJi1LL1JiiJ1LL1:
    long time -> do
    long daylen -> if
    boolean isFixed -> do
    13:14:void <init>() -> <init>
    17:21:void <init>(int,long,long,boolean) -> <init>
    25:29:void readPacket(java.io.DataInput) -> do
    33:37:void writePacket(java.io.DataOutput) -> do
    43:46:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.packet.PacketSyncBlocks -> Ji1LJillL1L11Lll:
    short[] blockIds -> do
    14:15:void <init>() -> <init>
    17:19:void <init>(short[]) -> <init>
    23:32:void readPacket(java.io.DataInput) -> do
    36:39:void writePacket(java.io.DataOutput) -> do
    43:44:void handle(nidefawl.qubes.network.Handler) -> do
nidefawl.qubes.network.server.ListenThread -> ll1LiJJi1LiJ:
    java.net.ServerSocket serverSocket -> do
    nidefawl.qubes.network.server.NetworkServer server -> do
    boolean finished -> do
    boolean listening -> if
    14:21:void <init>(nidefawl.qubes.network.server.NetworkServer,int) -> <init>
    26:49:void run() -> run
    51:69:void halt() -> do
nidefawl.qubes.network.server.NetworkServer -> L1ll1L1LL1L1L11L:
    boolean isRunning -> do
    nidefawl.qubes.network.server.ListenThread listenThread -> do
    nidefawl.qubes.server.GameServer server -> do
    long packetTimeout -> do
    long pingDelay -> if
    int netVersion -> do
    java.util.ArrayList handlersPlay -> do
    java.util.ArrayList handlersLogin -> if
    24:37:void <init>(nidefawl.qubes.server.GameServer) -> <init>
    40:41:void startListener() -> do
    45:50:void addConnection(java.net.Socket) -> do
    52:59:nidefawl.qubes.network.Connection newMemoryConnection() -> do
    63:74:void halt() -> if
    77:115:void update() -> for
    118:119:void addServerHandlerPlay(nidefawl.qubes.entity.Player,nidefawl.qubes.network.server.ServerHandlerLogin,nidefawl.qubes.network.server.ServerHandlerPlay) -> do
    122:122:java.util.ArrayList getLoginHandlers() -> do
    125:125:java.util.ArrayList getHandlers() -> if
nidefawl.qubes.network.server.ServerHandler -> iJjIll1LL11LL1Ji:
    int state -> do
    nidefawl.qubes.network.Connection conn -> do
    java.net.InetSocketAddress addr -> do
    java.lang.String handlerName -> do
    long time -> do
    nidefawl.qubes.server.GameServer server -> do
    nidefawl.qubes.network.server.NetworkServer netServer -> do
    14:29:void <init>(nidefawl.qubes.server.GameServer,nidefawl.qubes.network.server.NetworkServer,nidefawl.qubes.network.Connection) -> <init>
    31:31:java.net.InetSocketAddress getAddr() -> do
    41:71:void update() -> do
    75:76:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    81:81:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    85:85:java.lang.String getHandlerName() -> do
    90:91:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    94:95:void kick(java.lang.String) -> do
    98:98:boolean finished() -> do
nidefawl.qubes.network.server.ServerHandlerLogin -> llJijIiJllJiJi1L:
    java.lang.String name -> if
    20:21:void <init>(nidefawl.qubes.server.GameServer,nidefawl.qubes.network.server.NetworkServer,nidefawl.qubes.network.Connection) -> <init>
    25:36:void handleHandshake(nidefawl.qubes.network.packet.PacketHandshake) -> do
    40:40:void onDisconnect(int,java.lang.String) -> do
    44:52:void handleAuth(nidefawl.qubes.network.packet.PacketAuth) -> do
    56:85:void handleClientSettings(nidefawl.qubes.network.packet.PacketCSettings) -> do
    89:89:boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    94:94:boolean finished() -> do
    99:100:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    103:117:void handleSync(nidefawl.qubes.network.packet.PacketSyncBlocks) -> do
nidefawl.qubes.network.server.ServerHandlerPlay -> iJjIiJIjL1llJiIj:
    nidefawl.qubes.entity.PlayerServer player -> do
    int posSyncSent -> if
    int posSyncRecv -> for
    33:36:void <init>(nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.network.server.ServerHandlerLogin) -> <init>
    41:41:void handlePing(nidefawl.qubes.network.packet.PacketPing) -> do
    44:50:void update() -> do
    54:101:void handleSwitchWorld(nidefawl.qubes.network.packet.PacketCSwitchWorld) -> do
    105:105:java.lang.String getHandlerName() -> do
    110:111:void handleDisconnect(nidefawl.qubes.network.packet.PacketDisconnect) -> do
    116:127:void onDisconnect(int,java.lang.String) -> do
    130:131:void sendPacket(nidefawl.qubes.network.packet.Packet) -> do
    134:143:void handleBlockAction(nidefawl.qubes.network.packet.PacketCBlockAction) -> do
    147:231:void handleSetBlocks(nidefawl.qubes.network.packet.PacketCSetBlocks) -> do
    235:235:boolean isValidWorld(nidefawl.qubes.network.packet.AbstractPacketWorldRef) -> do
    239:239:nidefawl.qubes.entity.PlayerServer getPlayer() -> do
    243:251:void handleChat(nidefawl.qubes.network.packet.PacketChatMessage) -> do
    255:264:void handleMovement(nidefawl.qubes.network.packet.PacketCMovement) -> do
    267:268:void handleTeleportAck(nidefawl.qubes.network.packet.PacketCTeleportAck) -> do
    271:283:void resyncPosition() -> if
    286:287:void handleDigState(nidefawl.qubes.network.packet.PacketCDigState) -> do
    290:308:void handleInvClick(nidefawl.qubes.network.packet.PacketCInvClick) -> do
    310:353:void handleCrafting(nidefawl.qubes.network.packet.PacketCCrafting) -> do
    355:376:void handleInvTransaction(nidefawl.qubes.network.packet.PacketCInvTransaction) -> do
    379:436:void handleSetProperty(nidefawl.qubes.network.packet.PacketCSetProperty) -> do
    440:464:void handleListReq(nidefawl.qubes.network.packet.PacketCListRequest) -> do
    467:467:int getCompression() -> do
nidefawl.qubes.network.server.ServerHandlerPlay$1 -> jI1L1LL1llJijIJi:
    int[] $SwitchMap$nidefawl$qubes$io$network$DataListType -> do
    443:443:void <clinit>() -> <clinit>
nidefawl.qubes.noise.AbstractNoiseGen -> JillL11LjIIjL1jI:
    3:3:void <init>() -> <init>
nidefawl.qubes.noise.NoiseLib -> L1L1IjL1iJiJiJ1L:
    boolean LIB_PRESENT -> do
    46:49:nidefawl.qubes.noise.opennoise.OpenSimplexNoise makeGenerator(long) -> do
    53:56:nidefawl.qubes.noise.TerrainNoiseScale newNoiseScale(long) -> do
    19:39:void <clinit>() -> <clinit>
nidefawl.qubes.noise.NoiseMap2D -> L1iJ1L1LllL11LL1:
    java.lang.String tex -> do
    short[] data -> do
    int height -> do
    int width -> if
    14:31:void <init>(java.lang.String) -> <init>
    33:44:double evalI(int,int) -> do
    59:59:int getWidth() -> do
    62:62:int getHeight() -> if
nidefawl.qubes.noise.RiverNoise2D -> iJJiJilliJiJiJL1:
    double[][] dWeights -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise n1 -> do
    double scale -> do
    int maxI -> do
    int size -> if
    62:69:void <init>(long,double,int) -> <init>
    72:74:double dist2d(double,double,double,double) -> do
    78:103:nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult generate(int,int) -> do
    5:5:double[][] access$000() -> do
    39:57:void <clinit>() -> <clinit>
nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult -> JiIjiJIjlliJJill:
    double[] dNoise -> do
    int size -> do
    int maxI -> if
    10:13:void <init>(int,int) -> <init>
    19:35:double getBlur(int,int,int) -> do
    6:6:double[] access$100(nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult) -> do
nidefawl.qubes.noise.TerrainNoise -> iJL1llL1jI1LL1iJ:
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise noise -> do
    double scaleX -> do
    double scaleY -> if
    double scaleZ -> for
    int nOctaves -> do
    12:18:void <init>(long,double,double,double,int) -> <init>
    21:32:double get(int,int,int) -> do
nidefawl.qubes.noise.TerrainNoise2D -> jI1LjIllJiJiJi:
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise noise -> do
    double scaleX -> do
    double scaleZ -> if
    int nOctaves -> do
    11:16:void <init>(long,double,double,int) -> <init>
    19:29:double get(int,int) -> do
nidefawl.qubes.noise.TerrainNoiseCustom1 -> L1iJL1IjllIjllL1:
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise noise -> do
    double scaleX -> do
    double scaleY -> if
    double scaleZ -> for
    int nOctaves -> do
    12:18:void <init>(long,double,double,double,int) -> <init>
    21:32:double get(int,int,int) -> do
nidefawl.qubes.noise.TerrainNoiseMap2D -> L1IjIjllL1iJIjiJ:
    double[][] dWeights -> do
    nidefawl.qubes.noise.NoiseMap2D map -> do
    double scale -> do
    int maxI -> do
    int size -> if
    30:37:void <init>(java.lang.String,double,int) -> <init>
    40:74:nidefawl.qubes.noise.TerrainNoiseMap2DResult generate(int,int,double,double) -> do
    7:25:void <clinit>() -> <clinit>
nidefawl.qubes.noise.TerrainNoiseMap2DResult -> L1jIL11LIjIjiJL1:
    double[] dNoise -> do
    int size -> do
    int maxI -> if
    7:10:void <init>(int,int) -> <init>
    16:32:double getBlur(int,int,int) -> do
nidefawl.qubes.noise.TerrainNoiseScale -> JiL1JillL1llIjll:
    3:3:void <init>() -> <init>
    double[] gen(int,int) -> do
    nidefawl.qubes.noise.TerrainNoiseScale setUpsampleFactor(int) -> do
    nidefawl.qubes.noise.TerrainNoiseScale setScale(double,double,double) -> do
    nidefawl.qubes.noise.TerrainNoiseScale setOctavesFreq(int,double) -> do
nidefawl.qubes.noise.TerrainNoiseScaleJava -> jIjIjIllJilljI1L:
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise noise -> do
    int w -> do
    int h -> if
    double scaleX -> do
    double scaleY -> if
    double scaleZ -> for
    int nOctaves -> for
    double freqMult -> int
    int factor -> int
    int wLow -> new
    int hLow -> try
    12:25:void <init>(long) -> <init>
    29:31:nidefawl.qubes.noise.TerrainNoiseScale setOctavesFreq(int,double) -> do
    36:39:nidefawl.qubes.noise.TerrainNoiseScale setUpsampleFactor(int) -> do
    44:47:nidefawl.qubes.noise.TerrainNoiseScale setScale(double,double,double) -> do
    51:62:double get(int,int,int) -> do
    66:105:double[] gen(int,int) -> do
nidefawl.qubes.noise.TerrainNoiseScaleLib -> JijI1LL1IjjIIjll:
    int w -> do
    int h -> if
    double scaleX -> do
    double scaleY -> if
    double scaleZ -> for
    int nOctaves -> for
    double freqMult -> int
    int factor -> int
    int wLow -> new
    int hLow -> try
    long ptr -> do
    long bufferAddr -> if
    long native_init(long,int,int) -> do
    void native_setUpsampleFactor(long,int) -> do
    void native_setScale(long,double,double,double) -> do
    void native_setOctavesFreq(long,int,double) -> do
    void native_generateNoise(long,int,int,long) -> do
    void native_free(long) -> do
    23:39:void <init>(long) -> <init>
    41:45:nidefawl.qubes.noise.TerrainNoiseScale setUpsampleFactor(int) -> do
    48:52:nidefawl.qubes.noise.TerrainNoiseScale setScale(double,double,double) -> do
    55:58:nidefawl.qubes.noise.TerrainNoiseScale setOctavesFreq(int,double) -> do
    63:66:double[] gen(int,int) -> do
    71:74:void finalize() -> finalize
nidefawl.qubes.noise.opennoise.OpenSimplexNoise -> iJL1IjiJiJIjJi:
    16:17:void <init>() -> <init>
    double eval(double,double,double) -> do
    double eval(double,double) -> do
nidefawl.qubes.noise.opennoise.OpenSimplexNoiseJava -> jIiJIjlliJJiJill:
    short[] perm -> do
    short[] permGradIndex3D -> if
    byte[] gradients2D -> do
    byte[] gradients3D -> if
    byte[] gradients4D -> for
    37:38:void <init>() -> <init>
    53:71:void <init>(long) -> <init>
    77:185:double eval(double,double) -> do
    193:747:double eval(double,double,double) -> do
    2067:2068:double extrapolate(int,int,double,double) -> do
    2074:2075:double extrapolate(int,int,int,double,double,double) -> do
    2090:2091:int fastFloor(double) -> do
    2096:2122:void <clinit>() -> <clinit>
nidefawl.qubes.noise.opennoise.OpenSimplexNoiseLib -> IjIjJijIiJ1LIj1L:
    long ptr -> do
    long init(long) -> do
    void free(long) -> do
    double eval(long,double,double) -> do
    double eval(long,double,double,double) -> do
    20:22:void <init>(long) -> <init>
    26:26:double eval(double,double) -> do
    31:31:double eval(double,double,double) -> do
    40:42:void finalize() -> finalize
nidefawl.qubes.particle.AbstractParticleRenderer -> Ij1L1L1L1LllJiJi:
    5:5:void <init>() -> <init>
nidefawl.qubes.particle.CubeParticle -> IjIjjIIjL11LlljI:
    int tex -> try
    int normalMap -> byte
    int type -> case
    int pass -> char
    nidefawl.qubes.vec.Vector3f color -> do
    15:22:void <init>() -> <init>
    25:26:void setTex(int) -> do
    33:50:int store(int,java.nio.FloatBuffer,java.nio.IntBuffer) -> do
    55:80:void tickUpdate(nidefawl.qubes.world.World) -> do
    84:85:void setTextureOffset(float,float) -> do
nidefawl.qubes.particle.CubeParticleRenderer -> IjjIL1JijIll1LiJ:
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes -> do
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes_blockinfo -> if
    boolean startup -> for
    int fireUpdate -> byte
    float lastUpdate -> if
    boolean pause -> do
    float pauseTime -> do
    nidefawl.qubes.shader.Shader particleShaderSeperateBuffer -> do
    nidefawl.qubes.gl.GLTriBuffer cubeFormat1 -> do
    nidefawl.qubes.gl.GLTriBuffer cubeFormat2 -> if
    int selFormat -> case
    int maxSprites -> char
    int totalSpritesRendered -> do
    int storedSprites -> if
    int tick -> for
    java.util.List particles -> do
    java.util.Random r -> do
    29:58:void <init>() -> <init>
    63:72:void init() -> do
    75:103:void initShaders() -> int
    106:122:void renderParticles(nidefawl.qubes.world.World,float,float) -> do
    125:171:void spawnParticles(nidefawl.qubes.world.WorldClient,int,int,int,int,int) -> do
    207:225:void storeParticles(nidefawl.qubes.world.World,float,float) -> if
    228:254:void tickUpdate(nidefawl.qubes.world.World) -> do
    257:257:void resize(int,int) -> do
    259:264:void preRenderUpdate(nidefawl.qubes.world.World,float) -> do
    266:266:int getNumParticles() -> do
    270:270:void preinit() -> for
    32:35:void <clinit>() -> <clinit>
nidefawl.qubes.particle.CubeParticleRenderer$1 -> iJIjiJIjiJJiiJiJ:
    nidefawl.qubes.particle.CubeParticleRenderer this$0 -> do
    78:78:void <init>(nidefawl.qubes.particle.CubeParticleRenderer) -> <init>
    81:81:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.particle.Particle -> L1lliJL1iJiJ1LjI:
    boolean dead -> do
    int maxLive -> do
    nidefawl.qubes.vec.Vec3D mot -> do
    nidefawl.qubes.vec.Vec3D lastMot -> if
    nidefawl.qubes.vec.Vec3D pos -> for
    nidefawl.qubes.vec.Vec3D lastPos -> int
    nidefawl.qubes.vec.Vector3f renderPos -> if
    nidefawl.qubes.vec.Vector3f renderRot -> for
    nidefawl.qubes.vec.Vec3D rot -> new
    nidefawl.qubes.vec.Vec3D lastRot -> try
    nidefawl.qubes.vec.Vec3D rotspeed -> byte
    nidefawl.qubes.vec.Vector2f texOffset -> do
    float size -> do
    float initSize -> if
    float lastSize -> for
    float renderSize -> int
    int tick -> if
    boolean noclip -> if
    boolean hitGround -> for
    nidefawl.qubes.vec.AABB aabb -> do
    nidefawl.qubes.vec.AABB aabb2 -> if
    nidefawl.qubes.vec.AABB aabb3 -> for
    nidefawl.qubes.vec.AABB aabb4 -> int
    nidefawl.qubes.util.CollisionQuery coll -> do
    float gravity -> new
    boolean applyGravity -> int
    int lightValue -> for
    int checkTicks -> int
    int sleepTicks -> new
    boolean sleeping -> new
    int lastBlock -> try
    10:47:void <init>() -> <init>
    50:51:void die() -> do
    54:56:void setMotion(float,float,float) -> do
    59:65:void setPos(float,float,float) -> if
    68:70:void setRot(float,float,float) -> for
    73:74:void setRotSpeed(float,float,float) -> int
    77:80:void setSize(float) -> do
    83:86:void update(float) -> if
    89:132:void tickUpdate(nidefawl.qubes.world.World) -> do
    135:139:void preStep() -> if
    141:244:void step(nidefawl.qubes.world.World) -> if
    246:260:void postStep() -> for
    262:262:boolean doesFall() -> do
    266:266:float getGravity() -> do
nidefawl.qubes.path.Path -> ll1LjIL1IjL1llll:
    nidefawl.qubes.path.PathPoint[] arr -> do
    int curPos -> do
    8:10:void <init>(nidefawl.qubes.path.PathPoint[]) -> <init>
    13:13:boolean isFinished() -> do
    17:17:nidefawl.qubes.path.PathPoint get() -> do
    20:20:nidefawl.qubes.path.PathPoint getEnd() -> if
    30:30:int getLength() -> do
    34:34:int getPos() -> if
    38:38:nidefawl.qubes.path.PathPoint get(int) -> do
    42:46:void setPos(int) -> do
nidefawl.qubes.path.PathFinder -> L11LJillJiIjIj1L:
    nidefawl.qubes.path.PathList path -> do
    java.util.Map block -> do
    nidefawl.qubes.vec.BlockPos size -> do
    nidefawl.qubes.vec.BlockPos blockPos -> if
    nidefawl.qubes.path.PathPoint[] pathOptions -> do
    15:21:void <init>() -> <init>
    23:34:nidefawl.qubes.path.Path findPath(nidefawl.qubes.entity.Entity,nidefawl.qubes.vec.Vec3D,float) -> do
    38:77:nidefawl.qubes.path.Path findPath(nidefawl.qubes.entity.Entity,nidefawl.qubes.path.PathPoint,nidefawl.qubes.path.PathPoint,float) -> do
    80:106:int findPathOptions(nidefawl.qubes.entity.Entity,nidefawl.qubes.path.PathPoint,nidefawl.qubes.path.PathPoint,float) -> do
    109:138:nidefawl.qubes.path.PathPoint getPoint(nidefawl.qubes.entity.Entity,int,int,int,int) -> do
    141:160:int getBlockState(nidefawl.qubes.entity.Entity,int,int,int) -> do
    163:175:nidefawl.qubes.path.Path createPath(nidefawl.qubes.path.PathPoint,nidefawl.qubes.path.PathPoint) -> do
    178:191:nidefawl.qubes.path.PathPoint addPoint(int,int,int) -> do
nidefawl.qubes.path.PathList -> IjlljIllL1iJlljI:
    java.util.LinkedList list -> do
    java.util.Comparator comparator -> do
    java.util.List points -> do
    7:17:void <init>() -> <init>
    19:20:void reset() -> do
    23:31:void addPoint(nidefawl.qubes.path.PathPoint) -> do
    37:37:boolean isEmpty() -> do
    40:42:nidefawl.qubes.path.PathPoint pop() -> do
    45:49:void updateCost(nidefawl.qubes.path.PathPoint,float) -> do
nidefawl.qubes.path.PathList$1 -> lllliJlljI1LjIiJ:
    nidefawl.qubes.path.PathList this$0 -> do
    9:9:void <init>(nidefawl.qubes.path.PathList) -> <init>
    13:13:int compare(nidefawl.qubes.path.PathPoint,nidefawl.qubes.path.PathPoint) -> do
    9:9:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.path.PathPoint -> JiL1jIllJiiJiJiJ:
    int x -> do
    int y -> if
    int z -> for
    float totalPathDistance -> do
    float distanceToNext -> if
    float distanceToTarget -> for
    boolean isFirst -> do
    int pos -> int
    nidefawl.qubes.path.PathPoint previous -> do
    20:25:void <init>(int,int,int) -> <init>
    28:29:float distanceTo(nidefawl.qubes.path.PathPoint) -> do
    34:38:boolean equals(java.lang.Object) -> equals
    42:42:int hashCode() -> hashCode
    46:46:boolean inUse() -> do
    50:51:void getPosition(nidefawl.qubes.entity.EntityAI,nidefawl.qubes.vec.Vec3D) -> do
    55:55:java.lang.String toString() -> toString
nidefawl.qubes.path.RandomPosGen -> IjjIL1IjjI1Lll:
    nidefawl.qubes.vec.BlockPos tmp -> do
    9:10:void <init>() -> <init>
    12:36:nidefawl.qubes.vec.BlockPos find(nidefawl.qubes.entity.Entity,nidefawl.qubes.vec.Vec3D,int,int) -> do
nidefawl.qubes.perf.GPUProfiler -> JiiJJilllljIjIll:
    nidefawl.qubes.util.Pool taskPool -> do
    java.util.ArrayList queryObjects -> do
    int frameCounter -> do
    java.util.ArrayList completedFrames -> if
    boolean DISABLE_FRAME -> do
    63:69:void start(java.lang.String) -> do
    72:78:void end() -> do
    28:42:void <clinit>() -> <clinit>
nidefawl.qubes.perf.GPUProfiler$1 -> L1iJL1iJ1LIjlljI:
    31:31:void <init>(int) -> <init>
nidefawl.qubes.perf.TimingHelper -> L1Ij1LL1IjjIIjJi:
    boolean useNanos -> do
    boolean init -> if
    int LEN -> do
    long[] nanos -> do
    long[] millis -> if
    long[] calls -> for
    long[] beginNanos -> int
    long[] beginMillis -> new
    boolean[] on -> do
    java.lang.String[] names -> do
    java.util.HashMap map -> do
    int jObjectIdx -> if
    java.util.Stack stack -> do
    63:80:boolean start(int) -> do
    83:86:void startSilent(int) -> do
    99:119:long end(int) -> do
    127:139:boolean hasChild(int) -> if
    142:183:void dump() -> do
    188:188:boolean hasName(int) -> for
    198:202:void reset() -> if
    7:19:void <clinit>() -> <clinit>
nidefawl.qubes.perf.TimingHelper$1 -> lllliJJilliJjIL1:
    java.util.HashMap val$entries -> do
    163:163:void <init>(java.util.HashMap) -> <init>
    166:166:int compare(java.lang.Integer,java.lang.Integer) -> do
    163:163:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.perf.TimingHelper$TimingEntry -> llJiJiL1L1jIiJ1L:
    float perCall -> do
    int idx -> do
    121:121:void <init>() -> <init>
nidefawl.qubes.player.EntityData -> llL11LIjlllliJJi:
    3:3:void <init>() -> <init>
nidefawl.qubes.player.PlayerData -> L1Ij1LL1L1L1jIjI:
    java.util.UUID world -> do
    boolean flying -> do
    int chunkLoadDistance -> do
    java.util.HashSet joinedChannels -> do
    java.util.HashMap worldPositions -> do
    java.util.List invStacks -> do
    java.util.List[] invCraftStacks -> do
    nidefawl.qubes.nbt.Tag$Compound[] craftingStates -> do
    nidefawl.qubes.nbt.Tag$Compound properties -> do
    25:35:void <init>() -> <init>
    38:65:void load(nidefawl.qubes.nbt.Tag$Compound) -> do
    68:88:nidefawl.qubes.nbt.Tag save() -> do
nidefawl.qubes.render.AbstractRenderer -> jIjI1L1LL1Ji1LIj:
    boolean recompileShaders -> if
    java.util.List resourcesShaders -> if
    java.util.List resourcesShadersNew -> for
    java.util.List resourcesFramebuffers -> int
    int rendererWidth -> int
    int rendererHeight -> new
    int downsample -> try
    15:22:void <init>() -> <init>
    27:39:void addResource(nidefawl.qubes.util.IManagedResource) -> do
    43:49:void release() -> if
    55:56:void pushCurrentShaders() -> char
    62:68:void popNewShaders() -> else
    74:78:void releaseNewShaders() -> goto
    83:99:void releaseAll(nidefawl.qubes.util.EResourceType) -> do
    102:106:void resizeRenderer(int,int) -> if
    109:109:void resize(int,int) -> do
    114:114:void preinit() -> for
nidefawl.qubes.render.AbstractRenderer$1 -> L1ll1LiJIj1LiJjI:
    int[] $SwitchMap$nidefawl$qubes$util$EResourceType -> do
    27:27:void <clinit>() -> <clinit>
nidefawl.qubes.render.BlurRenderer -> L1iJ1LlljIL1Ijll:
    nidefawl.qubes.gl.FrameBuffer fbBlur1 -> do
    nidefawl.qubes.gl.FrameBuffer fbBlur2 -> if
    nidefawl.qubes.gl.FrameBuffer fbSSRBlurredX -> for
    nidefawl.qubes.gl.FrameBuffer fbSSRBlurredY -> int
    nidefawl.qubes.shader.Shader shaderBlurSeperate -> do
    nidefawl.qubes.shader.Shader shaderBlurKawase -> if
    boolean startup -> do
    int[][] kawaseKernelSizePasses -> do
    float w1 -> do
    float h1 -> if
    22:31:void <init>() -> <init>
    43:66:void initShaders() -> int
    68:84:int renderBlur1PassDownsample(int) -> do
    87:99:int renderBlurSeperate(int,int) -> do
    102:105:void resize(int,int) -> do
    109:111:void initBlurSepeate(int,int,int) -> do
    113:118:void initBlurKawase(int,int,int) -> if
    121:122:void init() -> do
    125:125:void preinit() -> for
nidefawl.qubes.render.FinalRenderer -> JiJillllIjJiiJiJ:
    nidefawl.qubes.shader.Shader shaderBloomCombine -> do
    nidefawl.qubes.shader.Shader shaderFinal -> if
    nidefawl.qubes.shader.Shader shaderDeferred -> for
    nidefawl.qubes.shader.Shader shaderDeferredWater -> int
    nidefawl.qubes.shader.Shader shaderDeferredFirstPerson -> new
    nidefawl.qubes.shader.Shader shaderInterpLum -> try
    nidefawl.qubes.shader.Shader shaderThreshold -> byte
    nidefawl.qubes.shader.Shader shaderSSR -> case
    nidefawl.qubes.shader.Shader shaderSSRCombine -> char
    nidefawl.qubes.shader.Shader shaderDownsample4x -> else
    nidefawl.qubes.shader.Shader shaderDownsample4xLum -> goto
    nidefawl.qubes.shader.Shader shaderNormals -> long
    nidefawl.qubes.gl.FrameBuffer fbSSR -> do
    nidefawl.qubes.gl.FrameBuffer fbSSRCombined -> if
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> for
    nidefawl.qubes.gl.FrameBuffer fbSSAO -> int
    nidefawl.qubes.gl.FrameBuffer fbBloomOut -> new
    nidefawl.qubes.gl.FrameBuffer[] fbLuminanceDownsample -> do
    nidefawl.qubes.gl.FrameBuffer[] fbLuminanceInterp -> if
    int preWaterDepthTex -> if
    boolean startup -> for
    int ssr -> for
    int frame -> byte
    nidefawl.qubes.render.post.SMAA smaa -> do
    boolean aoNeedsInit -> do
    int texSlotNoise -> do
    int[] aoSize -> do
    31:63:void <init>() -> <init>
    66:132:void renderDeferred(nidefawl.qubes.world.World,float,int) -> do
    134:135:void bindFB() -> int
    137:138:void clearFrameBuffer() -> new
    142:185:void calcLum(nidefawl.qubes.world.World,float) -> do
    192:194:void render(nidefawl.qubes.world.World,float,int) -> if
    196:197:void renderBlur(nidefawl.qubes.world.World,float) -> if
    200:200:int getSsr() -> do
    208:221:void raytraceSSR(nidefawl.qubes.world.World,float) -> for
    232:259:void combineSSR(nidefawl.qubes.world.World,float) -> int
    263:274:void renderAA(int,float,nidefawl.qubes.gl.FrameBuffer) -> do
    276:285:nidefawl.qubes.gl.FrameBuffer renderTonemap(nidefawl.qubes.world.World,float) -> do
    298:303:void copyPreWaterDepth() -> try
    305:311:void copySceneDepthBuffer() -> byte
    313:354:void renderBloom(nidefawl.qubes.world.World,float) -> new
    359:532:void initShaders() -> case
    537:565:void initAO() -> long
    576:587:void updateHBAOSettings() -> this
    589:597:void initAA() -> void
    600:666:void resize(int,int) -> do
    669:673:void aoReinit() -> break
    677:679:void release() -> if
    684:687:void init() -> do
    692:694:void setSSR(int) -> do
nidefawl.qubes.render.FinalRenderer$1 -> IjJillL1jIiJ1Lll:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    361:361:void <init>(nidefawl.qubes.render.FinalRenderer) -> <init>
    365:369:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.FinalRenderer$2 -> llIjjIIjiJL1jIiJ:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    373:373:void <init>(nidefawl.qubes.render.FinalRenderer) -> <init>
    376:382:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.FinalRenderer$3 -> iJL11LllIjjIiJL1:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    385:385:void <init>(nidefawl.qubes.render.FinalRenderer) -> <init>
    388:394:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.FinalRenderer$4 -> JilliJiJjIJiJiIj:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    397:397:void <init>(nidefawl.qubes.render.FinalRenderer) -> <init>
    400:406:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.FinalRenderer$5 -> IjiJL1iJJillL1ll:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    409:409:void <init>(nidefawl.qubes.render.FinalRenderer) -> <init>
    412:415:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.FinalRenderer$6 -> JillJiJi1LL1iJIj:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    418:418:void <init>(nidefawl.qubes.render.FinalRenderer) -> <init>
    422:424:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.FinalRenderer$7 -> IjlljIllllJilljI:
    nidefawl.qubes.render.FinalRenderer this$0 -> do
    431:431:void <init>(nidefawl.qubes.render.FinalRenderer) -> <init>
    435:437:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.LightCompute -> JiL1L1L1iJiJL1Ji:
    nidefawl.qubes.shader.ShaderBuffer ssbo_lights -> do
    nidefawl.qubes.shader.Shader shaderComputerLight -> do
    int[] lightTiles -> do
    int lightTilesTex -> do
    boolean startup -> do
    int[] debugResults -> if
    int numLights -> if
    48:48:void preinit() -> for
    51:72:void initShaders() -> int
    41:75:void <init>() -> <init>
    78:80:void init() -> do
    83:92:void resize(int,int) -> do
    95:118:void updateLights(nidefawl.qubes.world.WorldClient,float) -> do
    120:149:void render(nidefawl.qubes.world.WorldClient,float,int) -> do
    153:240:void renderDebug() -> new
    243:243:int getTexture() -> do
    37:37:void <clinit>() -> <clinit>
nidefawl.qubes.render.ShadowRenderer -> L1ll1LiJjIIjiJJi:
    nidefawl.qubes.shader.Shader shadowShader -> do
    boolean startup -> do
    int renderMode -> do
    int SHADOW_BUFFER_SIZE -> if
    java.lang.String[] shaderNames -> do
    nidefawl.qubes.gl.FrameBuffer fbShadow -> do
    22:37:void <init>() -> <init>
    46:78:void initShaders() -> int
    82:85:void init() -> do
    90:134:void renderMultiPass(nidefawl.qubes.world.World,float) -> do
    139:183:void renderMultiPassTextured(nidefawl.qubes.world.World,float) -> if
    186:191:void renderShadowPass(nidefawl.qubes.world.World,float) -> for
    194:201:void resize(int,int) -> do
    204:204:int getDepthTex() -> do
    213:213:int getTextureSize() -> if
nidefawl.qubes.render.ShadowRenderer$1 -> iJ1LjI1LjIIjiJiJ:
    nidefawl.qubes.render.ShadowRenderer this$0 -> do
    48:48:void <init>(nidefawl.qubes.render.ShadowRenderer) -> <init>
    52:55:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.SkyRenderer -> iJjIJill1LL1lljI:
    nidefawl.qubes.gl.FrameBuffer fbSkybox -> do
    nidefawl.qubes.shader.Shader spriteShader -> do
    nidefawl.qubes.shader.Shader cloudsShader -> if
    boolean startup -> do
    nidefawl.qubes.gl.GLVBO vboAttr -> do
    nidefawl.qubes.gl.GLVBO vboStaticQuad -> if
    nidefawl.qubes.gl.GLVBO vboIdx -> for
    nidefawl.qubes.gl.CubeMapCamera cubeMatrix -> do
    nidefawl.qubes.meshing.BlockFaceAttr attr -> do
    int vaoPos -> for
    java.util.List clouds -> do
    nidefawl.qubes.gl.ReallocIntBuffer vertexUploadDirectBuf -> do
    int storedSprites -> do
    int totalSpritesRendered -> if
    nidefawl.qubes.gl.VertexBuffer vertexBuf -> do
    nidefawl.qubes.vec.Vector3f tmp -> do
    int[] texClouds -> do
    java.nio.ByteBuffer bufMat -> do
    java.nio.FloatBuffer bufMatFloat -> do
    float WEATHER -> do
    37:54:void <init>() -> <init>
    162:165:void increaseClouds() -> int
    167:170:void decreaseClouds() -> new
    173:198:void initShaders() -> try
    201:257:void init() -> do
    260:264:void updateSpritesTick() -> byte
    266:271:void updateSprites(float) -> do
    273:286:void storeSprites(float,int) -> do
    288:336:void redraw() -> case
    338:342:void buildQuad(nidefawl.qubes.gl.VertexBuffer) -> do
    344:350:void resize(int,int) -> do
    355:396:void renderSky(nidefawl.qubes.world.WorldClient,float) -> do
    400:414:void renderSkyBox(nidefawl.qubes.world.WorldClient,float) -> if
    416:417:void tickUpdate() -> long
    56:160:void <clinit>() -> <clinit>
nidefawl.qubes.render.SkyRenderer$Cloud -> llJiIjIjiJL1JijI:
    int texture -> do
    java.util.List sprites -> do
    nidefawl.qubes.vec.Vector3f mot -> do
    nidefawl.qubes.vec.Vector3f pos -> if
    nidefawl.qubes.vec.Vector3f lastPos -> for
    nidefawl.qubes.vec.Vector3f renderPos -> int
    64:73:void <init>() -> <init>
    75:83:int store(java.nio.FloatBuffer) -> do
    86:91:void update(float) -> do
    94:99:void tick() -> do
nidefawl.qubes.render.SkyRenderer$PointSprite -> llJillJilljIJiiJ:
    float size -> do
    float initSize -> if
    float lastSize -> for
    float renderSize -> int
    float rotspeed -> new
    float rot -> try
    float lastRot -> byte
    float renderRot -> case
    float xoffset -> char
    float yoffset -> else
    nidefawl.qubes.vec.Vector3f posOffset -> do
    nidefawl.qubes.vec.Vector3f col -> if
    nidefawl.qubes.vec.Vector3f lastCol -> for
    nidefawl.qubes.vec.Vector3f initCol -> int
    nidefawl.qubes.vec.Vector3f renderCol -> new
    nidefawl.qubes.vec.Vector3f renderPos -> try
    int tick -> do
    110:118:void <init>() -> <init>
    120:121:void setSize(float) -> do
    123:127:void setCol(float,float,float) -> do
    129:144:void update(float) -> if
    147:158:void tick() -> do
    101:101:nidefawl.qubes.vec.Vector3f access$000(nidefawl.qubes.render.SkyRenderer$PointSprite) -> do
nidefawl.qubes.render.WorldRenderer -> jIJillIjL1L11LL1:
    boolean startup -> do
    nidefawl.qubes.vec.Vector3f skyColor -> do
    nidefawl.qubes.vec.Vector3f fogColor -> if
    java.util.HashMap debugBBs -> do
    java.util.HashMap debugPaths -> if
    int rendered -> do
    int texWaterNoise -> if
    int texNoise3D -> for
    nidefawl.qubes.shader.Shader terrainShader -> do
    nidefawl.qubes.shader.Shader terrainShaderFar -> if
    nidefawl.qubes.shader.Shader waterShader -> for
    nidefawl.qubes.shader.Shader shaderModelVoxel -> int
    nidefawl.qubes.shader.Shader shaderModelfirstPerson -> new
    nidefawl.qubes.shader.Shader shaderZPre -> try
    nidefawl.qubes.shader.Shader skybox -> byte
    nidefawl.qubes.models.qmodel.QModelProperties modelProperties -> do
    38:274:void <init>() -> <init>
    46:56:java.lang.String getPassName(int) -> do
    81:161:void initShaders() -> int
    164:170:void init() -> do
    176:240:void renderWorld(nidefawl.qubes.world.World,float) -> do
    258:273:void renderEntities(nidefawl.qubes.world.World,int,float,nidefawl.qubes.shader.Shader,int) -> do
    276:336:void renderEntitiesBatched(nidefawl.qubes.world.World,int,float,nidefawl.qubes.shader.Shader,int) -> if
    355:363:void renderTransparent(nidefawl.qubes.world.World,float) -> if
    366:504:void renderFirstPerson(nidefawl.qubes.world.World,float) -> for
    507:525:void renderNormals(nidefawl.qubes.world.World,float) -> int
    528:541:void renderTerrainWireFrame(nidefawl.qubes.world.World,float) -> new
    548:617:void renderDebugBB(nidefawl.qubes.world.World,float) -> try
    620:636:void resize(int,int) -> do
    639:639:void tickUpdate() -> new
    643:643:boolean isNormalMappingActive() -> do
nidefawl.qubes.render.WorldRenderer$1 -> llL11L1LJiL1JiiJ:
    nidefawl.qubes.render.WorldRenderer this$0 -> do
    84:84:void <init>(nidefawl.qubes.render.WorldRenderer) -> <init>
    87:92:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.WorldRenderer$2 -> iJiJ1LIjIjJiiJIj:
    nidefawl.qubes.render.WorldRenderer this$0 -> do
    96:96:void <init>(nidefawl.qubes.render.WorldRenderer) -> <init>
    99:102:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.WorldRenderer$3 -> JiL1JiiJL1iJIjjI:
    nidefawl.qubes.render.WorldRenderer this$0 -> do
    108:108:void <init>(nidefawl.qubes.render.WorldRenderer) -> <init>
    111:114:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.gui.SingleBlockDraw -> Ijll1L1L1L1L1LIj:
    nidefawl.qubes.gl.GLVBO vbo -> do
    nidefawl.qubes.gl.GLVBO vboIdx -> if
    nidefawl.qubes.gl.ReallocIntBuffer vboBuf -> do
    nidefawl.qubes.gl.ReallocIntBuffer vboIdxBuf -> if
    nidefawl.qubes.gl.BufferedMatrix modelMatrix -> do
    nidefawl.qubes.gl.BufferedMatrix projMatrix -> if
    float x -> do
    float y -> if
    float z -> for
    float scale -> int
    float rotX -> new
    float rotY -> try
    float rotZ -> byte
    java.util.LinkedList queue -> do
    41:63:void <init>() -> <init>
    69:75:void init() -> do
    81:104:void drawBlockDefault(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    106:114:void addToQueue(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> int
    117:169:void processQueue() -> if
    172:185:void drawBlock(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> if
    188:200:void doRender(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> for
    207:210:void setOffset(float,float,float) -> do
    216:217:void setScale(float) -> do
    226:229:void setRotation(float,float,float) -> if
nidefawl.qubes.render.gui.SingleBlockDraw$BlockDrawQueueEntry -> JijIjIIjL1JiiJL1:
    nidefawl.qubes.block.Block block -> do
    int data -> do
    nidefawl.qubes.item.StackData stackData -> do
    46:47:void <init>() -> <init>
    48:52:void <init>(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> <init>
    54:54:boolean is(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
nidefawl.qubes.render.gui.SingleBlockRenderAtlas -> Ij1LJiiJ1LIjlljI:
    nidefawl.qubes.render.gui.SingleBlockRenderAtlas instance -> do
    byte[] defaultData -> do
    nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas[] textures -> do
    java.util.Map map -> do
    63:63:float getTexW() -> do
    66:66:float getX(int) -> do
    69:69:float getY(int) -> if
    72:72:int getXPx(int) -> do
    75:75:int getYPx(int) -> if
    81:94:nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas getFirstFreeTextureAtlas() -> do
    100:100:nidefawl.qubes.render.gui.SingleBlockRenderAtlas getInstance() -> do
    78:114:void <init>() -> <init>
    107:112:boolean needsRender(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    116:124:nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas getAtlas(int,boolean) -> do
    127:129:nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas getAtlas(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    135:135:void init() -> do
    139:147:void setupTextureAtlas(nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas) -> do
    150:158:void reset() -> if
    163:168:int getTexture(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    172:177:int getTextureIdx(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> if
    180:181:int getHash(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> for
    19:34:void <clinit>() -> <clinit>
nidefawl.qubes.render.gui.SingleBlockRenderAtlas$TextureAtlas -> Ij1LJiIj1LIjjIIj:
    int[] hashes -> do
    int idx -> do
    nidefawl.qubes.gl.FrameBuffer frameBuffer -> do
    37:45:void <init>(int) -> <init>
    47:56:int getTextureIdx(int) -> do
    59:59:boolean hasFree() -> do
nidefawl.qubes.render.gui.SingleBlockRenderer -> L1JillJijIIjjIiJ:
    nidefawl.qubes.vec.BlockPos offset -> do
    nidefawl.qubes.util.SingleBlockWorld singleBlockWorld -> do
    nidefawl.qubes.gl.VertexBuffer singleBlockBuffer -> do
    23:28:void <init>() -> <init>
    32:46:nidefawl.qubes.gl.VertexBuffer renderSingleBlock(nidefawl.qubes.block.Block,int,nidefawl.qubes.item.StackData) -> do
    51:52:void putBuffer(nidefawl.qubes.block.Block,int) -> do
    54:55:void putSingleVert(nidefawl.qubes.block.Block,int,int) -> do
    57:58:void putTriIndex(nidefawl.qubes.block.Block,int,int[],int,int) -> do
    60:60:boolean isInventoryBlockRender() -> do
    20:20:void <clinit>() -> <clinit>
nidefawl.qubes.render.gui.VRGuiRenderer -> JiJijIL11LL1iJll:
    int texCursor -> do
    java.util.HashMap map -> do
    java.util.ArrayList list -> do
    java.util.ArrayList inUseBuffers -> if
    java.util.ArrayList freeBuffers -> for
    nidefawl.qubes.render.gui.VRGuiRenderer$Gui3DPosition hit -> do
    32:42:void <init>() -> <init>
    204:232:void addGui(nidefawl.qubes.gui.Gui,nidefawl.qubes.gui.Gui,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    235:241:void removeGui(nidefawl.qubes.gui.Gui) -> do
    243:255:void tickUpdate() -> do
    258:262:void releaseFB(nidefawl.qubes.render.gui.VRGuiRenderer$Gui3DPosition) -> do
    266:305:void update(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.gl.PositionMouseOver) -> do
    308:429:void render(float) -> do
    433:450:nidefawl.qubes.gl.FrameBuffer getFrameBuffer() -> do
    454:454:boolean hasAny() -> do
    457:463:void reset() -> if
    466:466:boolean isMouseOverGui() -> if
    470:472:void init() -> for
    476:539:void renderGUIs(float) -> if
nidefawl.qubes.render.gui.VRGuiRenderer$Gui3DPosition -> JillJiJijIIjIjll:
    nidefawl.qubes.gl.FrameBuffer fbGUIFixed -> do
    nidefawl.qubes.vec.Vector3f location -> do
    nidefawl.qubes.vec.Vector3f planeNormalWS -> if
    nidefawl.qubes.vec.Vector3f vIntersection -> for
    nidefawl.qubes.vec.Vector3f vIntersectionWS -> int
    nidefawl.qubes.vec.Vector3f vIntersectionGuiSpace -> new
    nidefawl.qubes.vec.Matrix4f rotation -> do
    nidefawl.qubes.vec.Matrix4f modelMatrix -> if
    nidefawl.qubes.gui.Gui gui -> do
    boolean hasHit -> do
    double mouseX -> do
    double mouseY -> if
    float timeAdded -> do
    float timeRemoved -> if
    float fadeOutF -> for
    float fadeInF -> int
    boolean canRemove -> if
    boolean fadeOut -> for
    47:69:void <init>(nidefawl.qubes.gui.Gui,nidefawl.qubes.vec.Vector3f,float) -> <init>
    72:132:void updatePosition(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    135:164:void checkIntersection(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    173:194:void tickUpdate() -> do
    197:199:void onClose() -> if
nidefawl.qubes.render.post.HBAOPlus -> nidefawl.qubes.render.post.HBAOPlus:
    boolean hasContext -> hasContext
    boolean needsInit -> needsInit
    14:14:void <init>() -> <init>
    void createContext(int,int,org.lwjgl.opengl.GLCapabilities) -> createContext
    void deleteContext() -> deleteContext
    void renderAO() -> renderAO
    void setProjMatrix(long) -> setProjMatrix
    void setViewMatrix(long) -> setViewMatrix
    void setOutputFBO(int) -> setOutputFBO
    void setDepthTex(int) -> setDepthTex
    void setRenderMask(int) -> setRenderMask
    void setNormalTex(int) -> setNormalTex
    void setBias(float) -> setBias
    void setNormalDecodeScaleBias(float,float) -> setNormalDecodeScaleBias
    void setRadius(float) -> setRadius
    void setDetailAO(float) -> setDetailAO
    void setCoarseAO(float) -> setCoarseAO
    void setPowerExponent(float) -> setPowerExponent
    void setDepthStorage(int) -> setDepthStorage
    void setDepthClampMode(int) -> setDepthClampMode
    void setDepthThreshold(boolean,float,float) -> setDepthThreshold
    void setBlur(boolean,int,float) -> setBlur
    void setBlurSharpen(boolean,float,float,float) -> setBlurSharpen
    void debugControl(int) -> debugControl
    java.lang.String[] getCallStack() -> getCallStack
    133:138:void <clinit>() -> <clinit>
nidefawl.qubes.render.post.SMAA -> Ij1L1L1LlliJiJ:
    nidefawl.qubes.util.SimpleResourceManager mgr -> do
    nidefawl.qubes.shader.Shader shaderAAEdge -> do
    nidefawl.qubes.shader.Shader shaderAABlendWeight -> if
    nidefawl.qubes.shader.Shader shaderAANeighborBlend -> for
    nidefawl.qubes.gl.FrameBuffer fbFlipInput -> do
    nidefawl.qubes.gl.FrameBuffer fbAAEdge -> if
    nidefawl.qubes.gl.FrameBuffer fbAAWeightBlend -> for
    int areaTex -> do
    int searchTex -> if
    boolean srgb -> do
    java.lang.String[] qualDefines -> do
    java.lang.String[] qualDesc -> if
    52:53:void <init>(int) -> <init>
    30:96:void <init>(int,boolean) -> <init>
    100:105:void init(int,int) -> do
    109:135:int makeAATexture(byte[],int,int,int,int,int) -> do
    139:141:void releaseAll(nidefawl.qubes.util.EResourceType) -> do
    149:203:void render(int,int,nidefawl.qubes.gl.FrameBuffer) -> do
    207:244:void renderSMAA(int,int,nidefawl.qubes.gl.FrameBuffer) -> if
    49:50:void <clinit>() -> <clinit>
nidefawl.qubes.render.post.SMAA$1 -> JiiJll1L1LiJiJIj:
    int val$quality -> do
    nidefawl.qubes.render.post.SMAA this$0 -> do
    62:62:void <init>(nidefawl.qubes.render.post.SMAA,int) -> <init>
    65:68:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.render.region.MeshedRegion -> L1IjL1jIL1L1IjJi:
    int[] vertexCount -> do
    int[] elementCount -> if
    boolean[] hasPass -> do
    int rX -> do
    int rZ -> if
    int rY -> for
    boolean xNeg -> do
    boolean xPos -> if
    boolean zPos -> for
    boolean zNeg -> int
    nidefawl.qubes.vec.AABBInt aabb -> do
    int[] frustumStates -> for
    boolean needsUpdate -> new
    boolean isUpdating -> try
    boolean isRenderable -> byte
    boolean isValid -> case
    int failedCached -> int
    boolean hasAnyPass -> char
    nidefawl.qubes.gl.GLVBO[] vbo -> do
    nidefawl.qubes.gl.GLVBO[] vboIndices -> if
    int shadowDrawMode -> else
    boolean frustumStateChanged -> else
    int occlusionQueryState -> new
    int occlusionResult -> try
    int occlFrameSkips -> byte
    int distance -> case
    nidefawl.qubes.vec.Vector3f queryPos -> do
    long totalBytes -> do
    long[] alloc -> do
    long[] totalBytesPass -> if
    int nextBuffer -> char
    17:100:void <init>() -> <init>
    54:60:void renderRegion(float,int) -> do
    64:75:void renderRegionIndirect(nidefawl.qubes.gl.MultiDrawIndirectBuffer,int) -> do
    80:98:void preUploadBuffers() -> do
    105:139:void uploadBuffer(int,nidefawl.qubes.gl.VertexBuffer,int) -> do
    143:162:void release() -> if
    165:165:int getNumVertices(int) -> do
    169:169:boolean hasPass(int) -> do
    173:184:void updateBB() -> for
    188:188:java.lang.String toString() -> toString
    194:194:boolean hasAnyPass() -> do
    197:197:int getShadowDrawMode() -> do
    99:102:void <clinit>() -> <clinit>
nidefawl.qubes.render.region.RegionRenderer -> L1L1L11Lll1LjI:
    int RENDER_DISTANCE -> do
    int OFFS_OVER -> if
    int LENGTH_OVER -> for
    int HEIGHT_SLICES -> byte
    java.util.Comparator compareUpdateRenderers -> do
    java.util.Comparator compareRenderers -> if
    int rendered -> case
    int occlCulled -> char
    int renderChunkX -> else
    int renderChunkY -> goto
    int renderChunkZ -> long
    java.util.ArrayList renderList -> do
    java.util.ArrayList shadowRenderList -> if
    java.util.ArrayList regionsToUpdate -> for
    boolean needsSortingUpdateRenderers -> do
    int[] occlQueries -> do
    nidefawl.qubes.render.region.MeshedRegion[] occlQueriesRunning -> do
    int queriesRunning -> this
    nidefawl.qubes.shader.Shader occlQueryShader -> do
    boolean startup -> int
    float camX -> do
    float camY -> if
    float camZ -> for
    nidefawl.qubes.render.region.MeshedRegion[][] regions -> do
    int numV -> void
    nidefawl.qubes.util.ThreadedWorker worker -> do
    nidefawl.qubes.render.region.RegionRenderer$ThreadContext[] threadCtx -> do
    int rChunkX -> break
    int rChunkY -> catch
    int rChunkZ -> class
    boolean threadedCulling -> for
    nidefawl.qubes.gl.ReallocIntBuffer[] buffers -> do
    nidefawl.qubes.gl.ReallocIntBuffer[] idxShortBuffers -> if
    nidefawl.qubes.gl.MultiDrawIndirectBuffer buffer -> do
    30:95:void <init>() -> <init>
    144:155:void init() -> do
    159:176:void initShaders() -> int
    179:193:nidefawl.qubes.render.region.MeshedRegion[][] create() -> do
    197:240:void reposition(int,int) -> int
    243:254:nidefawl.qubes.render.region.MeshedRegion getByChunkCoord(int,int,int) -> do
    257:263:nidefawl.qubes.render.region.MeshedRegion getByRegionCoord(int,int,int) -> if
    267:283:void resetAll() -> new
    286:290:void setRenderDistance(int) -> do
    293:318:void reRender() -> try
    322:339:void flagBlock(int,int,int) -> do
    342:355:void flagChunk(int,int) -> for
    442:547:void renderMain(nidefawl.qubes.world.World,float,nidefawl.qubes.render.WorldRenderer) -> do
    550:601:void renderRegions(nidefawl.qubes.world.World,float,int,int,int) -> do
    604:607:void flushRegions() -> byte
    610:721:void update(nidefawl.qubes.world.WorldClient,float,float,float,int,int,float) -> do
    725:777:void fromThread(int,int) -> fromThread
    780:824:void traverseRenderers() -> case
    830:849:void updateFrustum(nidefawl.qubes.render.region.MeshedRegion) -> do
    851:872:void tickUpdate() -> long
    875:879:void sortUpdateRenderers() -> this
    883:884:void sortRenderers() -> void
    889:895:int sortUpdateRenderersCompare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> do
    901:907:int sortRenderersCompare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> if
    41:130:void <clinit>() -> <clinit>
nidefawl.qubes.render.region.RegionRenderer$1 -> iJ1LIj1LIjJiiJiJ:
    nidefawl.qubes.render.region.RegionRenderer this$0 -> do
    48:48:void <init>(nidefawl.qubes.render.region.RegionRenderer) -> <init>
    51:51:int compare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> do
    48:48:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.render.region.RegionRenderer$2 -> iJll1LJi1LIj1L1L:
    nidefawl.qubes.render.region.RegionRenderer this$0 -> do
    54:54:void <init>(nidefawl.qubes.render.region.RegionRenderer) -> <init>
    57:57:int compare(nidefawl.qubes.render.region.MeshedRegion,nidefawl.qubes.render.region.MeshedRegion) -> do
    54:54:int compare(java.lang.Object,java.lang.Object) -> compare
nidefawl.qubes.render.region.RegionRenderer$ThreadContext -> JiiJlliJIjL1Jill:
    java.util.ArrayList renderList -> do
    java.util.ArrayList shadowRenderList -> if
    java.util.ArrayList regionsToUpdate -> for
    int workedOn -> do
    71:75:void <init>() -> <init>
nidefawl.qubes.server.GameServer -> llIjlllllljIIjL1:
    nidefawl.qubes.config.ServerConfig config -> do
    nidefawl.qubes.server.commands.CommandHandler commands -> do
    java.lang.Thread mainThread -> do
    nidefawl.qubes.network.server.NetworkServer networkServer -> do
    boolean running -> do
    boolean finished -> if
    boolean listening -> for
    nidefawl.qubes.world.WorldServer[] worlds -> do
    java.util.HashMap worldsMap -> do
    long lastTick -> do
    long lastSaveTick -> if
    int lastSaveStep -> do
    nidefawl.qubes.util.GameError reportedException -> do
    int nextWorldID -> if
    java.util.concurrent.ConcurrentLinkedQueue commandQueue -> do
    nidefawl.qubes.server.PlayerManager playerManager -> do
    nidefawl.qubes.chat.ChannelManager channelManager -> do
    28:48:void <init>() -> <init>
    51:54:void startServer() -> do
    59:77:void run() -> run
    81:109:void load() -> int
    113:123:nidefawl.qubes.world.WorldServer loadWorld(java.io.File) -> do
    127:176:void tryCreateDefaultWorlds(java.io.File,java.util.ArrayList) -> do
    179:179:int getNextWorldID() -> do
    183:222:void loop() -> if
    224:231:void resyncTime() -> new
    234:242:void updateTick() -> try
    244:252:void saveAndUnloadData() -> byte
    255:255:boolean isRunning() -> do
    258:259:void stopServer() -> for
    262:287:void onShutdown() -> case
    302:302:nidefawl.qubes.config.ServerConfig getConfig() -> do
    306:306:nidefawl.qubes.server.commands.CommandHandler getCommandHandler() -> do
    311:312:void setException(nidefawl.qubes.util.GameError) -> setException
    315:315:nidefawl.qubes.server.PlayerManager getPlayerManager() -> do
    319:319:nidefawl.qubes.world.WorldServer getWorld(java.util.UUID) -> do
    323:323:nidefawl.qubes.world.WorldServer getSpawnWorld() -> do
    331:338:void save(boolean) -> do
    341:341:nidefawl.qubes.network.server.NetworkServer getNetwork() -> do
    345:345:nidefawl.qubes.world.WorldServer[] getWorlds() -> do
    353:353:nidefawl.qubes.chat.ChannelManager getChatChannelMgr() -> do
    357:357:long getServerTime() -> do
    361:361:boolean isFinished() -> if
    365:365:boolean isListening() -> for
nidefawl.qubes.server.GameServer$1 -> jIjIIjll1L1L1LIj:
    nidefawl.qubes.server.GameServer this$0 -> do
    88:88:void <init>(nidefawl.qubes.server.GameServer) -> <init>
    92:92:boolean accept(java.io.File) -> accept
nidefawl.qubes.server.LocalGameServer -> jIL1JiiJL1JiL1Ji:
    nidefawl.qubes.server.GameServer server -> do
    nidefawl.qubes.server.GameServer shutdownServ -> if
    12:14:void <init>() -> <init>
    16:17:boolean getStatus() -> do
    20:29:void start() -> do
    31:37:void stop() -> if
    39:48:boolean isShutdownDone() -> if
    51:55:nidefawl.qubes.network.Connection newMemoryConnection() -> do
    58:62:boolean isReady() -> for
nidefawl.qubes.server.PlayerChunkTracker -> L1lllljIL1Ij1L1L:
    java.util.Map map -> do
    java.util.Set flaggedInstances -> do
    nidefawl.qubes.world.WorldServer worldServer -> do
    int ticksLastCheck -> do
    java.util.List blocksToSend -> do
    nidefawl.qubes.vec.BlockBoundingBox box2 -> do
    127:330:void <init>(nidefawl.qubes.world.WorldServer) -> <init>
    153:190:void update(nidefawl.qubes.entity.PlayerServer) -> do
    200:203:void trackPlayerChunk(nidefawl.qubes.entity.PlayerServer,int,int) -> do
    213:227:void untrackPlayerChunk(nidefawl.qubes.entity.PlayerServer,int,int) -> if
    235:245:void removePlayer(nidefawl.qubes.entity.PlayerServer) -> if
    253:272:void addPlayer(nidefawl.qubes.entity.PlayerServer) -> for
    283:290:nidefawl.qubes.server.PlayerChunkTracker$Entry getEntry(int,int,boolean) -> do
    301:309:void flagBlock(int,int,int) -> do
    319:324:void flagChunk(int,int) -> do
    336:400:void sendBlockChanges() -> do
    407:412:nidefawl.qubes.network.server.ServerHandlerPlay[] getHandlerArr(nidefawl.qubes.server.PlayerChunkTracker$Entry) -> do
    421:421:int getSize() -> do
    432:440:boolean isRequired(int,int) -> do
    447:458:void recheckIfRequiredChunksLoaded(boolean) -> do
    468:478:void flagLights(int,int,nidefawl.qubes.vec.BlockBoundingBox) -> do
    495:503:void flagLights(int,int,int,int,int,int,int,int) -> do
nidefawl.qubes.server.PlayerChunkTracker$Entry -> JiiJJi1LJiiJL11L:
    int x -> do
    int z -> if
    java.util.List players -> do
    long hash -> do
    boolean wholeChunkUpdate -> do
    java.util.Set flaggedBlocks -> do
    nidefawl.qubes.vec.BlockBoundingBox flaggedLights -> do
    boolean hasFlaggedLights -> if
    40:67:void <init>(int,int) -> <init>
    75:76:void addPlayer(nidefawl.qubes.entity.PlayerServer) -> do
    84:85:void removePlayer(nidefawl.qubes.entity.PlayerServer) -> if
    93:93:boolean isEmpty() -> do
    118:123:void flag(int,int,int) -> do
nidefawl.qubes.server.PlayerEntityTracker -> IjIjllJi1LjIiJ:
    java.util.Map map -> do
    nidefawl.qubes.entity.PlayerServer player -> do
    30:58:void <init>(nidefawl.qubes.entity.PlayerServer) -> <init>
    63:64:void leaveWorld() -> do
    68:76:void joinWorld(nidefawl.qubes.world.WorldServer) -> do
    79:116:void update() -> if
    119:135:void track(nidefawl.qubes.entity.Entity) -> do
    142:153:nidefawl.qubes.network.packet.PacketSEntityTrack getPacket(nidefawl.qubes.server.PlayerEntityTracker$Entry) -> do
    156:166:void untrack(nidefawl.qubes.entity.Entity) -> if
nidefawl.qubes.server.PlayerEntityTracker$Entry -> lliJllllIjIjllll:
    nidefawl.qubes.entity.Entity entity -> do
    nidefawl.qubes.vec.Vec3D pos -> do
    float yaw -> do
    float pitch -> if
    float yawBodyOffset -> for
    nidefawl.qubes.item.BaseStack[] equipment -> do
    33:45:void <init>(nidefawl.qubes.entity.Entity) -> <init>
nidefawl.qubes.server.PlayerManager -> JiiJJillllllJiiJ:
    java.io.File directory -> do
    java.util.Map players -> do
    java.util.Map playersLowerCase -> if
    nidefawl.qubes.entity.PlayerServer[] serverPlayers -> do
    nidefawl.qubes.server.GameServer server -> do
    29:36:void <init>(nidefawl.qubes.server.GameServer) -> <init>
    39:40:void init() -> do
    42:42:java.io.File getPlayerFile(java.lang.String) -> do
    46:59:nidefawl.qubes.player.PlayerData loadPlayer(java.lang.String) -> do
    63:70:void savePlayer(java.lang.String,nidefawl.qubes.player.PlayerData) -> do
    73:99:nidefawl.qubes.entity.PlayerServer addPlayer(java.lang.String) -> do
    103:108:void removePlayer(nidefawl.qubes.entity.PlayerServer) -> do
    111:122:void savePlayers() -> if
    124:124:nidefawl.qubes.entity.PlayerServer getPlayer(java.lang.String) -> if
    128:139:nidefawl.qubes.entity.PlayerServer matchPlayer(java.lang.String) -> for
    146:146:java.util.Collection getPlayers() -> do
    150:158:void updateTick() -> for
nidefawl.qubes.server.commands.Command -> L1iJiJL11LJijIjI:
    java.util.HashSet aliases -> do
    java.lang.String name -> do
    9:15:void <init>(java.lang.String) -> <init>
    18:19:void addAlias(java.lang.String) -> do
    22:22:boolean matches(java.lang.String,java.lang.String[],java.lang.String) -> do
    26:26:void testPermission(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> do
    void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
    31:31:java.lang.String getName() -> do
    35:35:boolean runSynchronized() -> do
    39:41:void checkArgs(java.lang.String[],int,int,java.lang.String) -> do
    44:48:nidefawl.qubes.entity.PlayerServer matchPlayer(nidefawl.qubes.server.GameServer,java.lang.String) -> do
nidefawl.qubes.server.commands.CommandDebug -> JillIjllL1IjJi:
    22:23:void <init>() -> <init>
    26:81:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
nidefawl.qubes.server.commands.CommandEntity -> llJijIL11LJiIjll:
    11:12:void <init>() -> <init>
    15:63:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
nidefawl.qubes.server.commands.CommandException -> llL11LllIjllJijI:
    6:7:void <init>(java.lang.String,java.lang.Exception) -> <init>
    10:11:void <init>(java.lang.String) -> <init>
nidefawl.qubes.server.commands.CommandHandler -> L11LiJllllL11L:
    java.util.HashSet commands -> do
    8:12:void <init>() -> <init>
    15:25:void registerBaseCommands() -> do
    29:34:void register(java.lang.Class) -> do
    37:47:void handle(nidefawl.qubes.server.commands.ICommandSource,java.lang.String) -> do
    51:64:void executeCommand(nidefawl.qubes.server.commands.ICommandSource,nidefawl.qubes.server.commands.Command,java.lang.String,java.lang.String[],java.lang.String) -> do
nidefawl.qubes.server.commands.CommandKick -> JiIjJijIiJJiiJll:
    10:11:void <init>() -> <init>
    14:23:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
nidefawl.qubes.server.commands.CommandList -> JillJillJi1LL1jI:
    11:12:void <init>() -> <init>
    15:24:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
nidefawl.qubes.server.commands.CommandSave -> JijIjIL1JiL1Ji:
    6:8:void <init>() -> <init>
    11:16:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
nidefawl.qubes.server.commands.CommandSetTime -> JiL1iJJilliJL1L1:
    10:11:void <init>() -> <init>
    14:48:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
    54:59:void showTime(nidefawl.qubes.server.commands.ICommandSource) -> do
nidefawl.qubes.server.commands.CommandStats -> llllIjIjJiJijI:
    9:10:void <init>() -> <init>
    13:24:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
nidefawl.qubes.server.commands.CommandStop -> iJjIL1ll1LllJiL1:
    6:8:void <init>() -> <init>
    11:12:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
    15:15:boolean runSynchronized() -> do
nidefawl.qubes.server.commands.CommandTP -> jIlljIJiL1jIlliJ:
    10:11:void <init>() -> <init>
    14:24:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
nidefawl.qubes.server.commands.CommandToCoord -> jIlljIIjllllJiJi:
    9:10:void <init>() -> <init>
    13:19:void execute(nidefawl.qubes.server.commands.ICommandSource,java.lang.String,java.lang.String[],java.lang.String) -> if
nidefawl.qubes.server.commands.ICommandSource -> IjIjjIiJJi1LJiIj:
    void preExecuteCommand(nidefawl.qubes.server.commands.Command) -> do
    void onUnknownCommand(java.lang.String,java.lang.String) -> if
    nidefawl.qubes.server.GameServer getServer() -> do
    void onError(nidefawl.qubes.server.commands.Command,nidefawl.qubes.server.commands.CommandException) -> do
    void sendMessage(java.lang.String) -> if
    nidefawl.qubes.world.WorldServer getWorld() -> do
nidefawl.qubes.server.commands.PreparedCommand -> iJllJill1LIjL1Ji:
    nidefawl.qubes.server.commands.ICommandSource source -> do
    nidefawl.qubes.server.commands.Command c -> do
    java.lang.String cmd -> do
    java.lang.String[] args -> do
    java.lang.String line -> if
    10:16:void <init>(nidefawl.qubes.server.commands.ICommandSource,nidefawl.qubes.server.commands.Command,java.lang.String,java.lang.String[],java.lang.String) -> <init>
    20:28:void run() -> do
nidefawl.qubes.server.compress.CompressChunks -> IjjIL11LjIJiIjiJ:
    java.util.Collection chunks -> do
    int worldid -> do
    int[][] coords -> do
    nidefawl.qubes.network.server.ServerHandlerPlay[] handlers -> do
    boolean hasLight -> do
    int compressionLvl -> if
    24:30:void <init>(int,java.util.Collection,nidefawl.qubes.network.server.ServerHandlerPlay[],boolean,int) -> <init>
    34:38:void shortToByteArray(short[],byte[],int) -> do
    42:114:int fill(byte[]) -> do
    119:144:void finish(byte[],int) -> do
    149:166:boolean isValid() -> do
    172:172:int getCompression() -> do
nidefawl.qubes.server.compress.CompressLight -> IjIjlljIL11LllIj:
    nidefawl.qubes.chunk.Chunk chunks -> do
    int worldid -> do
    int chunkLen -> if
    nidefawl.qubes.network.server.ServerHandlerPlay[] handlers -> do
    int coordZ -> for
    int coordX -> int
    nidefawl.qubes.vec.BlockBoundingBox box -> do
    int compressionLvl -> new
    24:30:void <init>(int,nidefawl.qubes.chunk.Chunk,nidefawl.qubes.vec.BlockBoundingBox,int,nidefawl.qubes.network.server.ServerHandlerPlay[]) -> <init>
    34:41:int fill(byte[]) -> do
    46:72:void finish(byte[],int) -> do
    77:94:boolean isValid() -> do
    99:99:int getCompression() -> do
nidefawl.qubes.server.compress.CompressThread -> iJllIjJiiJiJiJ:
    java.lang.Thread thread -> do
    java.util.concurrent.LinkedBlockingQueue queue -> do
    nidefawl.qubes.server.GameServer server -> do
    16:18:void <init>(nidefawl.qubes.server.GameServer) -> <init>
    22:57:void run() -> run
    60:64:void startNewThread(nidefawl.qubes.server.GameServer) -> do
    67:68:void submit(nidefawl.qubes.server.compress.ICompressTask) -> do
    13:13:void <clinit>() -> <clinit>
nidefawl.qubes.server.compress.ICompressTask -> iJjIIjiJJiJiJiiJ:
    int fill(byte[]) -> do
    void finish(byte[],int) -> do
    boolean isValid() -> do
    int getCompression() -> do
nidefawl.qubes.shader.AbstractUniform -> iJL1L1JiIjiJIj1L:
    java.lang.String name -> do
    int loc -> do
    boolean first -> do
    6:10:void <init>(java.lang.String,int) -> <init>
    13:13:boolean validLoc() -> do
    18:18:void release() -> do
nidefawl.qubes.shader.ComputeShader -> jIjIJiIjJijI1L1L:
    int computeShader -> do
    12:36:void <init>(java.lang.String,nidefawl.qubes.shader.ShaderSource) -> <init>
    40:47:void attach() -> do
    49:66:void release() -> this
nidefawl.qubes.shader.DebugShaders -> llJiL1jIL1Ijll:
    nidefawl.qubes.shader.ShaderBuffer debugOutput -> do
    java.util.ArrayList variables -> do
    nidefawl.qubes.shader.Shader shader -> do
    25:34:int getSizeOfType(int) -> do
    38:51:int getArrayStartOffset(int) -> if
    54:55:int getArrayIdxOffset(int,int) -> do
    58:70:int typeFromString(java.lang.String) -> do
    84:88:void <init>() -> <init>
    92:125:java.util.ArrayList readBack() -> do
    129:140:java.lang.String registerDebugVar(java.lang.String,java.lang.String,java.lang.String) -> do
    144:156:void initDebug(nidefawl.qubes.shader.Shader) -> do
    159:175:void enable() -> do
nidefawl.qubes.shader.DebugShaders$Var -> jI1LIjL1lliJlliJ:
    int idx -> do
    int type -> if
    java.lang.String name -> do
    java.lang.String typeName -> if
    nidefawl.qubes.vec.Vector4f value -> do
    73:78:void <init>() -> <init>
    81:81:java.lang.String toString() -> toString
nidefawl.qubes.shader.GraphicShader -> L1jIll1LL1IjJiIj:
    int fragShader -> do
    int vertShader -> if
    int geometryShader -> for
    java.lang.String attr -> if
    15:94:void <init>(java.lang.String,nidefawl.qubes.shader.ShaderSource,nidefawl.qubes.shader.ShaderSource,nidefawl.qubes.shader.ShaderSource) -> <init>
    98:151:void attach() -> do
    153:178:void release() -> this
nidefawl.qubes.shader.IShaderDef -> iJL1L1iJL11LiJll:
    java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.shader.Shader -> ll1LIjiJiJiJjIIj:
    int SHADERS -> int
    int shader -> new
    java.lang.String name -> do
    java.util.HashMap locations -> do
    java.util.HashMap uniforms -> if
    java.util.HashMap missinglocations -> for
    boolean valid -> do
    nidefawl.qubes.shader.ShaderSourceBundle src -> do
    nidefawl.qubes.shader.DebugShaders debugVars -> do
    java.util.HashMap map -> int
    java.nio.IntBuffer buf -> do
    int lastBoundShader -> try
    37:38:void incUniformCalls() -> if
    42:57:int getUniformLocation(java.lang.String) -> do
    25:62:void <init>(java.lang.String) -> <init>
    83:102:void linkProgram() -> for
    106:108:int getStatus(int,int) -> do
    112:120:java.lang.String getLog(int,int) -> do
    123:138:void enable() -> int
    141:144:void disable() -> new
    void release() -> this
    148:152:void setProgramUniform1i(java.lang.String,int) -> do
    161:165:void setProgramUniform2f(java.lang.String,float,float) -> do
    167:171:void setProgramUniform1f(java.lang.String,float) -> do
    173:177:void setProgramUniform3f(java.lang.String,float,float,float) -> do
    179:193:nidefawl.qubes.shader.AbstractUniform getUniform(java.lang.String,java.lang.Class) -> do
    197:201:void setProgramUniform4f(java.lang.String,float,float,float,float) -> do
    213:217:void setProgramUniformMatrix4(java.lang.String,boolean,java.nio.FloatBuffer,boolean) -> do
    243:243:nidefawl.qubes.util.EResourceType getType() -> do
    257:258:void setSource(nidefawl.qubes.shader.ShaderSourceBundle) -> do
    260:260:nidefawl.qubes.shader.ShaderSourceBundle getSource() -> do
    265:269:void initDebug(nidefawl.qubes.shader.DebugShaders) -> do
    271:271:java.util.List readDebugVars() -> do
    24:139:void <clinit>() -> <clinit>
nidefawl.qubes.shader.ShaderBuffer -> L1JijI1LllIjjIjI:
    java.util.List buffers -> do
    int nextIdx -> do
    java.lang.String name -> do
    int buffer -> int
    int len -> if
    int frameLen -> for
    int bindingPoint -> new
    java.util.List shaders -> if
    boolean makePersistant -> do
    boolean isPersistantMapped -> if
    java.nio.ByteBuffer buf -> do
    java.nio.FloatBuffer bufFloat -> do
    java.nio.IntBuffer bufInt -> do
    java.nio.ByteBuffer mappedBuffer -> if
    java.nio.FloatBuffer mappedBufferFloat -> if
    java.nio.IntBuffer mappedBufferInt -> if
    boolean framePooled -> for
    int framePoolLength -> try
    int frameOffset -> byte
    long[] fences -> do
    51:52:void <init>(java.lang.String) -> <init>
    34:59:void <init>(java.lang.String,int,boolean) -> <init>
    61:62:nidefawl.qubes.shader.ShaderBuffer setMakePersistantMapped(boolean) -> do
    65:69:void sync() -> do
    71:130:void nextFrame() -> if
    132:132:nidefawl.qubes.shader.ShaderBuffer setSize(int) -> do
    135:143:nidefawl.qubes.shader.ShaderBuffer setSize(int,int) -> do
    149:196:void update() -> for
    199:224:void setup() -> int
    227:235:void rebindShaders() -> new
    237:242:void init() -> try
    244:256:void bindBuffers(nidefawl.qubes.shader.Shader) -> do
    262:270:void addShader(nidefawl.qubes.shader.Shader) -> if
    272:276:java.nio.FloatBuffer getFloatBuffer() -> do
    280:284:java.nio.IntBuffer getIntBuffer() -> do
    287:291:java.nio.ByteBuffer getBuf() -> do
    294:307:java.nio.ByteBuffer map(boolean) -> do
    310:321:void _map(int) -> do
    324:325:void unmap() -> byte
    327:328:void unbind() -> case
    330:331:void bind() -> char
    336:338:void clearBuffers() -> else
    340:340:int offsetInt() -> do
    343:343:int offset() -> if
    346:346:int getBuffer() -> for
    353:353:java.nio.FloatBuffer getMappedBufferFloat() -> if
    27:28:void <clinit>() -> <clinit>
nidefawl.qubes.shader.ShaderCompileError -> ll1L1L1LiJllJiIj:
    java.lang.String name -> do
    java.lang.String log -> if
    nidefawl.qubes.shader.ShaderSource code -> do
    16:22:void <init>(nidefawl.qubes.shader.ShaderSource,java.lang.String,java.lang.String) -> <init>
    25:28:void <init>(java.lang.String,java.lang.String,java.lang.String) -> <init>
    31:31:java.lang.String getName() -> do
    35:35:java.lang.String getLog() -> if
    43:43:nidefawl.qubes.shader.ShaderSource getShaderSource() -> do
nidefawl.qubes.shader.ShaderSource -> L1iJL1L11L1LiJ:
    java.util.regex.Pattern patternInclude -> do
    java.util.regex.Pattern patternDefine -> if
    java.util.regex.Pattern patternAttr -> for
    java.util.regex.Pattern patternDebug -> int
    java.util.regex.Pattern lineErrorAMD -> new
    java.util.regex.Pattern lineErrorNVIDIA -> try
    java.util.HashMap sources -> do
    java.util.HashMap sourceNames -> if
    java.lang.String processed -> do
    int nInclude -> do
    java.lang.String attrTypes -> if
    nidefawl.qubes.shader.ShaderSourceBundle shaderSourceBundle -> do
    26:40:void <init>(nidefawl.qubes.shader.ShaderSourceBundle) -> <init>
    42:43:void load(nidefawl.qubes.assets.AssetManager,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    45:165:java.lang.String readParse(nidefawl.qubes.assets.AssetManager,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef,boolean) -> do
    173:203:java.lang.String getGlobalDef(java.lang.String) -> if
    206:206:boolean isEmpty() -> do
    209:209:java.lang.String getSource() -> do
    212:250:java.lang.String decorateErrors(java.lang.String) -> do
    253:253:java.lang.String getAttrTypes() -> if
    19:24:void <clinit>() -> <clinit>
nidefawl.qubes.shader.ShaderSourceBundle -> L1jIIj1LiJL11L1L:
    nidefawl.qubes.shader.ShaderSource computeCode -> do
    nidefawl.qubes.shader.ShaderSource vertCode -> if
    nidefawl.qubes.shader.ShaderSource fragCode -> for
    nidefawl.qubes.shader.ShaderSource geomCode -> int
    nidefawl.qubes.shader.DebugShaders s -> do
    java.lang.String name -> do
    12:20:void <init>(java.lang.String) -> <init>
    23:27:void load(nidefawl.qubes.assets.AssetManager,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,nidefawl.qubes.shader.IShaderDef) -> do
    30:34:nidefawl.qubes.shader.Shader compileShader() -> do
    42:42:nidefawl.qubes.shader.ShaderSource getFragment() -> do
    46:49:java.lang.String addDebugVar(java.lang.String,java.lang.String,java.lang.String) -> do
    52:52:nidefawl.qubes.shader.DebugShaders getDebugVars() -> do
nidefawl.qubes.shader.Shaders -> JiIjiJIjJiiJIjL1:
    nidefawl.qubes.util.SimpleResourceManager shaders -> do
    nidefawl.qubes.util.SimpleResourceManager newshaders -> if
    boolean startup -> do
    nidefawl.qubes.shader.Shader depthBufShader -> do
    nidefawl.qubes.shader.Shader normals -> if
    nidefawl.qubes.shader.Shader wireframe -> for
    nidefawl.qubes.shader.Shader texturedAlphaTest -> int
    nidefawl.qubes.shader.Shader textured -> new
    nidefawl.qubes.shader.Shader textured_to_srgb -> try
    nidefawl.qubes.shader.Shader textured_to_lin -> byte
    nidefawl.qubes.shader.Shader colored -> case
    nidefawl.qubes.shader.Shader colored3D -> char
    nidefawl.qubes.shader.Shader textured3D -> else
    nidefawl.qubes.shader.Shader textured3DAlphaTest -> goto
    nidefawl.qubes.shader.Shader textured3DMipMap -> long
    nidefawl.qubes.shader.Shader renderUINT -> this
    nidefawl.qubes.shader.Shader singleblock -> void
    nidefawl.qubes.shader.Shader singleblock3D -> break
    nidefawl.qubes.shader.Shader gui -> catch
    nidefawl.qubes.shader.Shader item -> class
    nidefawl.qubes.shader.Shader tonemap -> const
    16:17:void init() -> do
    41:191:void initShaders() -> if
    10:13:void <clinit>() -> <clinit>
nidefawl.qubes.shader.Shaders$1 -> jIL1L11L1LIj1L:
    49:49:void <init>() -> <init>
    53:56:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.shader.Shaders$2 -> ll1LL1iJL1jIJiIj:
    59:59:void <init>() -> <init>
    63:66:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.shader.Shaders$3 -> iJ1LJiJiIjJi1LjI:
    69:69:void <init>() -> <init>
    73:76:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.shader.Shaders$4 -> jIjI1LIjllL1llll:
    81:81:void <init>() -> <init>
    85:88:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.shader.Shaders$5 -> llJiJijIlliJiJiJ:
    91:91:void <init>() -> <init>
    95:101:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.shader.Uniform1f -> JillL1IjiJllL1iJ:
    float lastX -> do
    10:11:void <init>(java.lang.String,int) -> <init>
    14:19:boolean set(float) -> do
    24:28:boolean set() -> if
nidefawl.qubes.shader.Uniform1i -> Ji1L1LIjiJJiIj:
    int lastX -> if
    10:11:void <init>(java.lang.String,int) -> <init>
    14:21:boolean set(int) -> do
    26:30:boolean set() -> if
nidefawl.qubes.shader.Uniform2f -> iJ1LL11LL1iJjI:
    float lastX -> do
    float lastY -> if
    11:12:void <init>(java.lang.String,int) -> <init>
    15:23:boolean set(float,float) -> do
    28:32:boolean set() -> if
nidefawl.qubes.shader.Uniform3f -> L1Ij1LjIjIL1IjIj:
    float lastX -> do
    float lastY -> if
    float lastZ -> for
    14:15:void <init>(java.lang.String,int) -> <init>
    18:27:boolean set(float,float,float) -> do
    32:36:boolean set() -> if
nidefawl.qubes.shader.Uniform4f -> IjJiiJIjJi1LiJJi:
    float lastX -> do
    float lastY -> if
    float lastZ -> for
    float lastW -> int
    13:14:void <init>(java.lang.String,int) -> <init>
    17:27:boolean set(float,float,float,float) -> do
    32:36:boolean set() -> if
nidefawl.qubes.shader.UniformBuffer -> llL1L1L1jIIjJiJi:
    int nextIdx -> do
    nidefawl.qubes.shader.UniformBuffer[] buffers -> do
    java.lang.String name -> do
    int buffer -> for
    int len -> if
    java.nio.FloatBuffer floatBuffer -> do
    int bindingPoint -> int
    boolean autoBind -> if
    nidefawl.qubes.shader.UniformBuffer uboMatrix3D -> do
    nidefawl.qubes.shader.UniformBuffer uboMatrix3D_Temp -> if
    nidefawl.qubes.shader.UniformBuffer uboMatrix2D -> for
    nidefawl.qubes.shader.UniformBuffer uboMatrixShadow -> int
    nidefawl.qubes.shader.UniformBuffer uboSceneData -> new
    nidefawl.qubes.shader.UniformBuffer LightInfo -> try
    nidefawl.qubes.shader.UniformBuffer VertexDirections -> byte
    nidefawl.qubes.shader.UniformBuffer TBNMat -> case
    java.util.List shaders -> do
    boolean once -> do
    31:32:void <init>(java.lang.String) -> <init>
    33:204:void <init>(java.lang.String,int,boolean) -> <init>
    41:42:nidefawl.qubes.shader.UniformBuffer addMat4() -> do
    45:46:nidefawl.qubes.shader.UniformBuffer addVec4() -> if
    53:54:void setPosition(int) -> do
    56:57:void reset() -> do
    59:60:void put(java.nio.FloatBuffer) -> do
    62:63:void put(float[]) -> do
    68:69:void put(float) -> do
    75:79:void put(float,float,float) -> do
    81:82:void putNeg(float,float,float) -> if
    84:95:void update() -> if
    97:106:void setup() -> for
    108:117:void release() -> goto
    160:165:void init() -> int
    167:171:void destroy() -> new
    174:181:void rebindShaders() -> try
    184:196:void bindBuffers(nidefawl.qubes.shader.Shader) -> do
    200:203:void bind() -> byte
    209:217:void addShader(nidefawl.qubes.shader.Shader) -> if
    226:345:void updateUBO(nidefawl.qubes.world.WorldClient,float) -> do
    351:411:void updateTBNMatrices() -> long
    416:487:void updateVertDir() -> this
    492:498:void updateOrtho() -> case
    501:504:void setNormalMat(java.nio.FloatBuffer) -> if
    512:522:void updateSceneMatrices() -> char
    524:530:void updatePxOffset() -> else
    22:218:void <clinit>() -> <clinit>
nidefawl.qubes.shader.UniformMat4 -> lljIiJllJijIjI:
    float[] last -> do
    boolean transpose -> if
    java.nio.FloatBuffer buf -> do
    11:16:void <init>(java.lang.String,int) -> <init>
    19:38:boolean set(java.nio.FloatBuffer,boolean) -> do
    56:60:void release() -> do
nidefawl.qubes.texture.PNGDecoder -> IjIjJiiJL1L1iJL1:
    byte[] SIGNATURE -> do
    java.io.InputStream input -> do
    java.util.zip.CRC32 crc -> do
    byte[] buffer -> if
    int chunkLength -> do
    int chunkType -> if
    int chunkRemaining -> for
    int width -> int
    int height -> new
    int bitdepth -> try
    int colorType -> byte
    int bytesPerPixel -> case
    byte[] palette -> for
    byte[] paletteA -> int
    byte[] transPixel -> new
    boolean $assertionsDisabled -> do
    72:104:void <init>(java.io.InputStream) -> <init>
    109:109:int getBitdepth() -> do
    113:113:int getHeight() -> if
    117:117:int getWidth() -> for
    186:219:nidefawl.qubes.texture.PNGDecoder$Format decideTextureFormat(nidefawl.qubes.texture.PNGDecoder$Format) -> do
    236:350:void decode(java.nio.ByteBuffer,int,nidefawl.qubes.texture.PNGDecoder$Format) -> do
    376:377:void copy(java.nio.ByteBuffer,byte[]) -> do
    380:399:void copyRGBtoABGR(java.nio.ByteBuffer,byte[]) -> if
    402:421:void copyRGBtoRGBA(java.nio.ByteBuffer,byte[]) -> for
    424:443:void copyRGBtoBGRA(java.nio.ByteBuffer,byte[]) -> int
    446:449:void copyRGBAtoABGR(java.nio.ByteBuffer,byte[]) -> new
    452:455:void copyRGBAtoBGRA(java.nio.ByteBuffer,byte[]) -> try
    458:461:void copyRGBAtoRGB(java.nio.ByteBuffer,byte[]) -> byte
    464:468:void copyGreyscaleToARGB(java.nio.ByteBuffer,byte[]) -> case
    472:491:void copyPALtoARGB(java.nio.ByteBuffer,byte[]) -> char
    494:497:void copyRGBAtoARGB(java.nio.ByteBuffer,byte[]) -> else
    499:518:void copyRGBtoARGB(java.nio.ByteBuffer,byte[]) -> goto
    521:540:void copyPALtoABGR(java.nio.ByteBuffer,byte[]) -> long
    543:562:void copyPALtoRGBA(java.nio.ByteBuffer,byte[]) -> this
    565:584:void copyPALtoBGRA(java.nio.ByteBuffer,byte[]) -> void
    587:594:void expand4(byte[],byte[]) -> do
    597:606:void expand2(byte[],byte[]) -> if
    609:622:void expand1(byte[],byte[]) -> for
    624:642:void unfilter(byte[],byte[]) -> int
    645:649:void unfilterSub(byte[]) -> do
    652:656:void unfilterUp(byte[],byte[]) -> new
    659:668:void unfilterAverage(byte[],byte[]) -> try
    671:691:void unfilterPaeth(byte[],byte[]) -> byte
    694:751:void readIHDR() -> do
    754:760:void readPLTE() -> if
    763:785:void readtRNS() -> for
    788:802:void closeChunk() -> int
    805:811:void openChunk() -> new
    814:818:void openChunk(int) -> do
    821:824:void checkChunkLength(int) -> if
    827:833:int readChunk(byte[],int,int) -> do
    837:843:void refillInflater(java.util.zip.Inflater) -> do
    846:867:void readChunkUnzip(java.util.zip.Inflater,byte[],int,int) -> do
    871:878:void readFully(byte[],int,int) -> do
    881:881:int readInt(byte[],int) -> do
    889:896:void skip(long) -> do
    899:904:boolean checkSignature(byte[]) -> do
    12:41:void <clinit>() -> <clinit>
nidefawl.qubes.texture.PNGDecoder$1 -> IjL11LllL1llJiiJ:
    int[] $SwitchMap$nidefawl$qubes$texture$PNGDecoder$Format -> do
    188:188:void <clinit>() -> <clinit>
nidefawl.qubes.texture.PNGDecoder$Format -> llllIjlljIllL1Ij:
    nidefawl.qubes.texture.PNGDecoder$Format ALPHA -> do
    nidefawl.qubes.texture.PNGDecoder$Format LUMINANCE -> if
    nidefawl.qubes.texture.PNGDecoder$Format LUMINANCE_ALPHA -> for
    nidefawl.qubes.texture.PNGDecoder$Format RGB -> int
    nidefawl.qubes.texture.PNGDecoder$Format RGBA -> new
    nidefawl.qubes.texture.PNGDecoder$Format BGRA -> try
    nidefawl.qubes.texture.PNGDecoder$Format ABGR -> byte
    nidefawl.qubes.texture.PNGDecoder$Format ARGB -> case
    int numComponents -> do
    boolean hasAlpha -> do
    nidefawl.qubes.texture.PNGDecoder$Format[] $VALUES -> do
    14:14:nidefawl.qubes.texture.PNGDecoder$Format[] values() -> values
    14:14:nidefawl.qubes.texture.PNGDecoder$Format valueOf(java.lang.String) -> valueOf
    27:30:void <init>(java.lang.String,int,int,boolean) -> <init>
    33:33:int getNumComponents() -> do
    14:22:void <clinit>() -> <clinit>
nidefawl.qubes.texture.TMgr -> iJjI1Lll1LIj1LL1:
    9:9:int getNoise() -> do
    13:13:int getBlocks() -> if
    17:17:int getNoiseArr() -> for
    21:21:int getItems() -> int
    29:29:int getEmpty() -> new
    33:33:int getEmptyWhite() -> try
    41:41:int getNormals() -> byte
nidefawl.qubes.texture.TextureManager -> L11L1LJiIj1LIjjI:
    nidefawl.qubes.texture.TextureManager instance -> do
    int texNoise -> do
    int texEmpty -> if
    int texEmptyNormal -> for
    java.nio.ByteBuffer directBuf -> do
    int texEmptyWhite -> int
    35:36:void <init>() -> <init>
    39:39:nidefawl.qubes.texture.TextureManager getInstance() -> do
    44:55:void init() -> do
    58:67:void reload() -> if
    75:90:int makeNewTexture(byte[],int,int,boolean,boolean,int,int) -> do
    94:94:int makeNewTexture(nidefawl.qubes.assets.AssetTexture,boolean,boolean,int) -> do
    97:97:int makeNewTexture(nidefawl.qubes.assets.AssetTexture,boolean,boolean,int,int) -> do
    107:156:void uploadTexture(byte[],int,int,int,int,int,boolean,boolean,int) -> do
    163:163:void destroy() -> for
    24:24:void <clinit>() -> <clinit>
nidefawl.qubes.texture.TextureUtil -> L1JillJiJiIjL11L:
    20:28:byte[] genNoise2(int) -> do
    173:191:int getAverageColor(byte[],int,int) -> do
    199:199:int clampRGB(int) -> do
    208:249:byte[] makeMipMap(byte[],int,int,int) -> do
    258:268:void clampAlpha(byte[],int,int) -> do
    271:283:byte[] toBytesRGBA(int[]) -> do
    327:327:float getR(int) -> do
    330:330:float getG(int) -> if
    333:333:float getB(int) -> for
    337:350:int mixRGB(int,int,float) -> do
    354:371:int mix3RGB(int,int,int) -> do
    374:384:void setTransparentPixelsColor(byte[],int,int,int) -> do
nidefawl.qubes.texture.array.BlockNormalMapArray -> L1IjL1jI1LL1Ijll:
    nidefawl.qubes.texture.array.BlockNormalMapArray instance -> do
    27:27:nidefawl.qubes.texture.array.BlockNormalMapArray getInstance() -> do
    34:35:void <init>() -> <init>
    38:40:void load() -> load
    44:49:void findMaxTileWidth() -> findMaxTileWidth
    54:79:void collectTextures(nidefawl.qubes.assets.AssetManager) -> collectTextures
    82:136:void uploadTextures() -> uploadTextures
    141:161:void postUpload() -> postUpload
    25:25:void <clinit>() -> <clinit>
nidefawl.qubes.texture.array.BlockTextureArray -> iJll1LL11LllJi1L:
    nidefawl.qubes.texture.array.BlockTextureArray instance -> do
    float anisotropicFiltering -> do
    int totalSlots -> do
    32:32:nidefawl.qubes.texture.array.BlockTextureArray getInstance() -> do
    29:40:void <init>() -> <init>
    43:62:void postUpload() -> postUpload
    65:109:void uploadTextures() -> uploadTextures
    113:137:void collectTextures(nidefawl.qubes.assets.AssetManager) -> collectTextures
    140:141:void setAnisotropicFiltering(int) -> do
    28:28:void <clinit>() -> <clinit>
nidefawl.qubes.texture.array.ItemTextureArray -> JilljI1L1LIjjI1L:
    nidefawl.qubes.texture.array.ItemTextureArray instance -> do
    28:28:nidefawl.qubes.texture.array.ItemTextureArray getInstance() -> do
    33:34:void <init>() -> <init>
    38:82:void uploadTextures() -> uploadTextures
    86:110:void collectTextures(nidefawl.qubes.assets.AssetManager) -> collectTextures
    114:132:void postUpload() -> postUpload
    26:26:void <clinit>() -> <clinit>
nidefawl.qubes.texture.array.NoiseTextureArray -> Ji1LL1jI1LlliJjI:
    nidefawl.qubes.texture.array.NoiseTextureArray instance -> do
    23:23:nidefawl.qubes.texture.array.NoiseTextureArray getInstance() -> do
    27:28:void <init>() -> <init>
    32:52:void uploadTextures() -> uploadTextures
    56:62:void postUpload() -> postUpload
    66:68:void load() -> load
    72:80:void collectTextures(nidefawl.qubes.assets.AssetManager) -> collectTextures
    21:21:void <clinit>() -> <clinit>
nidefawl.qubes.texture.array.TextureArray -> JijIIj1LiJIjL1Ij:
    boolean SKIP_LOAD_TEXTURES -> SKIP_LOAD_TEXTURES
    java.util.HashMap texNameToAssetMap -> texNameToAssetMap
    java.util.HashMap blockIDToAssetList -> blockIDToAssetList
    java.util.HashMap slotTextureMap -> slotTextureMap
    boolean firstInit -> firstInit
    int[] textures -> textures
    int glid -> glid
    int tileSize -> tileSize
    int numTextures -> numTextures
    int numMipmaps -> numMipmaps
    int subtypeBits -> subtypeBits
    boolean report -> report
    float loadprogress -> loadprogress
    float uploadprogress -> uploadprogress
    25:43:void <init>(int) -> <init>
    46:53:void unload() -> unload
    55:56:void init() -> init
    59:61:void preUpdate() -> preUpdate
    63:72:void _load() -> _load
    74:76:void load() -> load
    79:84:void reload() -> reload
    88:94:void postUpdate() -> postUpdate
    97:100:void free() -> free
    108:114:java.nio.ByteBuffer put(java.nio.ByteBuffer,byte[]) -> put
    118:118:int getTextureIdx(int,int) -> getTextureIdx
    121:122:void setTexture(int,int,int) -> setTexture
    127:133:void calculateSubtypeBits() -> calculateSubtypeBits
    135:154:void findMaxTileWidth() -> findMaxTileWidth
    157:162:void upscaleTextures() -> upscaleTextures
    167:176:void initGLStorage() -> initGLStorage
    void uploadTextures() -> uploadTextures
    void collectTextures(nidefawl.qubes.assets.AssetManager) -> collectTextures
    void postUpload() -> postUpload
    183:183:float getProgress() -> getProgress
    187:187:int getNumMipmaps() -> getNumMipmaps
    191:191:int getNumTextures() -> getNumTextures
nidefawl.qubes.util.BlockColl -> jI1LiJ1LJiJijI:
    int x -> do
    int y -> if
    int z -> for
    int type -> int
    nidefawl.qubes.vec.AABB blockBB -> do
    5:10:void <init>() -> <init>
nidefawl.qubes.util.CharSequenceIterator -> jIL1Ij1LJijIIjIj:
    java.lang.CharSequence sequence -> do
    int pos -> do
    19:21:void <init>(java.lang.CharSequence) -> <init>
    24:24:boolean hasNext() -> hasNext
    29:29:java.lang.Character next() -> do
    35:37:char nextChar() -> do
    42:42:void remove() -> remove
    12:12:java.lang.Object next() -> next
nidefawl.qubes.util.ClipboardHelper -> jIJiL11LL1IjJiL1:
    10:11:void setClipboardString(java.lang.String) -> do
    14:15:java.lang.String getClipboardString() -> do
nidefawl.qubes.util.CollisionQuery -> IjllIjjIiJllIjiJ:
    java.util.ArrayList collisions -> do
    java.util.ArrayList tempList -> if
    nidefawl.qubes.vec.AABBFloat[] tmpBBs -> do
    int numCollisions -> do
    nidefawl.qubes.vec.AABBFloat tmpBB -> do
    11:20:void <init>() -> <init>
    23:26:nidefawl.qubes.util.BlockColl get() -> do
    29:60:boolean queryAny(nidefawl.qubes.world.World,nidefawl.qubes.vec.AABB) -> do
    63:100:void query(nidefawl.qubes.world.World,nidefawl.qubes.vec.AABB) -> do
    102:134:boolean queryAnyCollisions(nidefawl.qubes.world.World,nidefawl.qubes.vec.AABB,float) -> do
    138:138:int getNumCollisions() -> do
    141:141:nidefawl.qubes.util.BlockColl get(int) -> do
nidefawl.qubes.util.Color -> JiJi1LlllliJ1L:
    7:49:int HSBtoRGB(float,float,float) -> do
    53:85:float[] RGBtoHSB(int,int,int,float[]) -> do
    89:94:void setColorVec(int,nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.util.CrashInfo -> nidefawl.qubes.util.CrashInfo:
    java.lang.String title -> title
    java.lang.String desc -> desc
    java.lang.String outBuf -> outBuf
    java.lang.String errBuf -> errBuf
    java.lang.String exc -> exc
    15:34:void <init>(java.lang.String,java.util.List) -> <init>
    40:42:void setLogBuf(java.lang.String) -> setLogBuf
    48:50:void setErrBuf(java.lang.String) -> setErrBuf
    56:61:void setException(java.lang.Throwable) -> setException
nidefawl.qubes.util.DumbPool -> llJiL1IjiJ1LL1L1:
    nidefawl.qubes.util.DumbPool[] dumbPools -> do
    java.lang.Object[] objects -> do
    int nextIdx -> do
    6:24:void <init>(java.lang.Class) -> <init>
    27:28:void poolReset() -> do
    31:31:java.lang.Object get() -> do
    35:42:void reset() -> if
    4:4:void <clinit>() -> <clinit>
nidefawl.qubes.util.EResourceType -> jIJiiJL1jIiJ1LL1:
    nidefawl.qubes.util.EResourceType SHADER -> do
    nidefawl.qubes.util.EResourceType FRAMEBUFFER -> if
    nidefawl.qubes.util.EResourceType[] $VALUES -> do
    10:10:nidefawl.qubes.util.EResourceType[] values() -> values
    10:10:nidefawl.qubes.util.EResourceType valueOf(java.lang.String) -> valueOf
    10:10:void <init>(java.lang.String,int) -> <init>
    10:11:void <clinit>() -> <clinit>
nidefawl.qubes.util.Ease -> JiIjJiiJJiL1Jill:
    35:35:float cubicIn(float) -> do
    39:40:float cubicOut(float) -> if
nidefawl.qubes.util.FastArrayList -> JiIjllllJiIjjIL1:
    java.lang.Object[] array -> do
    int size -> do
    7:10:void <init>(int) -> <init>
    14:14:int size() -> size
    19:19:boolean isEmpty() -> isEmpty
    24:28:boolean contains(java.lang.Object) -> contains
    33:33:java.util.Iterator iterator() -> iterator
    56:56:java.lang.Object[] toArray() -> toArray
    61:61:java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    66:67:boolean add(java.lang.Object) -> add
    72:78:boolean remove(java.lang.Object) -> remove
    83:83:boolean containsAll(java.util.Collection) -> containsAll
    88:88:boolean addAll(java.util.Collection) -> addAll
    93:93:boolean addAll(int,java.util.Collection) -> addAll
    98:98:boolean removeAll(java.util.Collection) -> removeAll
    103:103:boolean retainAll(java.util.Collection) -> retainAll
    108:109:void clear() -> clear
    113:113:java.lang.Object get(int) -> get
    118:123:java.lang.Object set(int,java.lang.Object) -> set
    128:128:void add(int,java.lang.Object) -> add
    133:138:java.lang.Object remove(int) -> remove
    143:143:int indexOf(java.lang.Object) -> indexOf
    148:148:int lastIndexOf(java.lang.Object) -> lastIndexOf
    153:153:java.util.ListIterator listIterator() -> listIterator
    158:158:java.util.ListIterator listIterator(int) -> listIterator
    163:163:java.util.List subList(int,int) -> subList
    5:5:java.lang.Object[] access$000(nidefawl.qubes.util.FastArrayList) -> do
nidefawl.qubes.util.FastArrayList$1 -> L1Ji1LiJL1IjIj:
    int size -> do
    int idx -> if
    nidefawl.qubes.util.FastArrayList this$0 -> do
    33:35:void <init>(nidefawl.qubes.util.FastArrayList) -> <init>
    39:39:boolean hasNext() -> hasNext
    44:44:java.lang.Object next() -> next
    49:49:void remove() -> remove
nidefawl.qubes.util.GameContext -> IjiJjIJiiJL11L1L:
    java.lang.Thread mainThread -> do
    nidefawl.qubes.util.Side side -> do
    nidefawl.qubes.util.GameError initError -> do
    long startBoot -> do
    21:21:long getTimeSinceStart() -> do
    26:27:void setMainThread(java.lang.Thread) -> do
    35:35:java.lang.Thread getMainThread() -> do
    42:42:nidefawl.qubes.util.Side getSide() -> do
    46:49:void setSideAndPath(nidefawl.qubes.util.Side,java.lang.String) -> do
    56:66:void earlyInit() -> do
    72:72:nidefawl.qubes.util.GameError getInitError() -> do
    79:98:void lateInit() -> if
nidefawl.qubes.util.GameError -> jIjIIjL1L11LJiL1:
    11:12:void <init>(java.lang.Exception) -> <init>
    14:15:void <init>(java.lang.String) -> <init>
    18:19:void <init>(java.lang.String,java.lang.Throwable) -> <init>
    22:23:void <init>(java.lang.String,java.lang.Exception) -> <init>
nidefawl.qubes.util.GameMath -> lliJJiIjJiL11LJi:
    float[] m -> do
    float[] inv -> if
    12:12:float cos(float) -> do
    15:15:float sin(float) -> if
    20:20:float atan(float) -> for
    25:25:float atan2(float,float) -> do
    30:30:float asin(float) -> int
    39:40:int floor(double) -> do
    43:43:int ceil(double) -> if
    120:120:float coTangent(float) -> new
    124:124:float degreesToRadians(float) -> try
    128:128:float sqrtf(float) -> byte
    132:135:int randomI(long) -> do
    144:144:int lhToZ(long) -> if
    147:147:int lhToX(long) -> for
    150:150:long toLong(int,int) -> do
    160:160:int toInt(int,int) -> do
    164:166:double dist2d(double,double,double,double) -> do
    170:176:int log2(int) -> do
    179:179:int signum(float) -> do
    182:182:boolean isNormalFloat(float) -> do
    192:192:float clamp(float,float,float) -> do
    195:198:int distSq3Di(int,int,int,int,int,int) -> do
    206:206:float powf(float,float) -> if
    214:233:float pow(float,int) -> do
    237:251:double getAngle(double,double,double,double) -> if
    254:254:float tan(float) -> case
    259:259:float easeInOutCubic(float) -> char
    262:273:int[] downsample(int,int,int) -> do
    277:277:int round(float) -> if
    280:285:float wrapAngle(float) -> else
    296:300:float wrapAngleToRange(float,float) -> for
    45:46:void <clinit>() -> <clinit>
nidefawl.qubes.util.Half -> L1iJIj1LllIjIjJi:
    41:61:int fromFloat(float) -> do
nidefawl.qubes.util.IManagedResource -> JilliJJi1LiJL1iJ:
    void release() -> this
    nidefawl.qubes.util.EResourceType getType() -> do
nidefawl.qubes.util.IOHelper -> iJlljIIjL1L1llL1:
    12:19:void copyTo(nidefawl.qubes.network.StreamIO,nidefawl.qubes.network.StreamIO) -> do
nidefawl.qubes.util.IRenderComponent -> JilllljIjIiJL1jI:
    void init() -> do
    void release() -> if
    void preinit() -> for
nidefawl.qubes.util.IResourceManager -> llJillllIjIjL1iJ:
    void addResource(nidefawl.qubes.util.IManagedResource) -> do
nidefawl.qubes.util.IThreadedWork -> JiL1iJiJiJ1LiJ:
    void fromThread(int,int) -> fromThread
nidefawl.qubes.util.Pool -> lliJllIjjIiJlljI:
    nidefawl.qubes.util.Poolable[] array -> do
    boolean[] inUse -> do
    6:9:void <init>(int) -> <init>
nidefawl.qubes.util.Poolable -> L1JiL1L11LJiIjll:
nidefawl.qubes.util.Project -> iJ1LL1iJIjL1jIIj:
    float[] IDENTITY_MATRIX -> do
    java.nio.FloatBuffer finalMatrix -> do
    java.nio.FloatBuffer tempMatrix -> if
    float[] in -> if
    float[] out -> for
    nidefawl.qubes.vec.Vector3f tmp3 -> do
    nidefawl.qubes.vec.Vector3f tmp4 -> if
    nidefawl.qubes.vec.Vector3f tmp5 -> for
    200:211:void fovProjMat(float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    214:222:void orthoMat(float,float,float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    230:262:void lookAt(float,float,float,float,float,float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    13:226:void <clinit>() -> <clinit>
nidefawl.qubes.util.RayTrace -> JilljIIj1L1LjIiJ:
    nidefawl.qubes.vec.Vector3f dirFrac -> do
    nidefawl.qubes.vec.AABBFloat bb -> do
    nidefawl.qubes.util.RayTrace$RayTraceIntersection intersection -> do
    nidefawl.qubes.vec.BlockPos quarter -> do
    boolean quarterMode -> do
    11:35:void <init>() -> <init>
    40:41:void reset() -> do
    44:141:void doRaytrace(nidefawl.qubes.world.World,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,int) -> do
    145:172:boolean callback(nidefawl.qubes.world.World,int,int,int,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    176:176:boolean rayTraceBlock(nidefawl.qubes.block.Block) -> do
    188:188:float intbound(float,float) -> do
    193:193:boolean hasHit() -> do
    196:196:nidefawl.qubes.util.RayTrace$RayTraceIntersection getHit() -> do
    204:204:nidefawl.qubes.vec.AABBFloat getTempBB() -> do
    214:225:void setIntersection(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,float,int) -> do
nidefawl.qubes.util.RayTrace$HitType -> IjiJIjJiiJjIL1Ij:
    nidefawl.qubes.util.RayTrace$HitType BLOCK -> do
    nidefawl.qubes.util.RayTrace$HitType NONE -> if
    nidefawl.qubes.util.RayTrace$HitType[] $VALUES -> do
    12:12:nidefawl.qubes.util.RayTrace$HitType[] values() -> values
    12:12:nidefawl.qubes.util.RayTrace$HitType valueOf(java.lang.String) -> valueOf
    12:12:void <init>(java.lang.String,int) -> <init>
    12:13:void <clinit>() -> <clinit>
nidefawl.qubes.util.RayTrace$RayTraceIntersection -> iJiJIjjIL1L1L1jI:
    nidefawl.qubes.util.RayTrace$HitType hit -> do
    int blockId -> do
    nidefawl.qubes.vec.BlockPos blockPos -> do
    nidefawl.qubes.vec.BlockPos q -> if
    nidefawl.qubes.vec.Vector3f pos -> do
    float distance -> do
    int face -> if
    15:20:void <init>() -> <init>
nidefawl.qubes.util.RegionEntry -> llIjiJ1LlliJ1L:
    void addKey(int) -> do
    int getMinX() -> do
    int getMinZ() -> if
    int getMaxX() -> for
    int getMaxZ() -> int
nidefawl.qubes.util.RegionMap -> L11L1Lllllll1L1L:
    com.google.common.collect.Multimap mmap -> do
    byte bits -> do
    12:17:void <init>(int) -> <init>
    20:20:int toRegion(int) -> do
    28:40:void add(nidefawl.qubes.util.RegionEntry) -> do
    76:88:java.util.Collection getRegions(int,int,int) -> do
    181:182:void clear() -> do
    185:185:java.util.Collection values() -> do
nidefawl.qubes.util.RenderUtil -> iJ1LjIIj1LIj1LIj:
    33:87:void makeCube(nidefawl.qubes.gl.VertexBuffer,float,nidefawl.qubes.gl.GLVAO) -> do
    90:149:void makeSphere(nidefawl.qubes.gl.VertexBuffer,float,int,int) -> do
    151:151:int packNormal(nidefawl.qubes.vec.Vector3f) -> do
    154:161:int packNormal(float,float,float) -> do
    164:164:int packTexCoord(float,float) -> do
nidefawl.qubes.util.Renderable -> Ij1LiJiJjIJi1LL1:
    void render(float,double,double) -> render
    void initGui(boolean) -> initGui
nidefawl.qubes.util.ResettableCountDownLatch -> JiiJiJiJ1L1LJi:
    nidefawl.qubes.util.ResettableCountDownLatch$Sync sync -> do
    176:179:void <init>(int) -> <init>
    209:210:void await() -> do
    213:214:void reset() -> if
    273:274:void countDown() -> for
    295:295:java.lang.String toString() -> toString
nidefawl.qubes.util.ResettableCountDownLatch$Sync -> Ij1LJiIjL1IjJi1L:
    int startCount -> do
    137:140:void <init>(int) -> <init>
    143:143:int getCount() -> do
    147:147:int tryAcquireShared(int) -> tryAcquireShared
    153:159:boolean tryReleaseShared(int) -> tryReleaseShared
    163:164:void reset() -> do
nidefawl.qubes.util.ServerStats -> jIL1L1IjIjIjlliJ:
    java.util.concurrent.ConcurrentHashMap map -> do
    15:20:void add(java.lang.String,long) -> do
    13:13:void <clinit>() -> <clinit>
nidefawl.qubes.util.Side -> jIiJjIiJL1L1IjiJ:
    nidefawl.qubes.util.Side CLIENT -> do
    nidefawl.qubes.util.Side SERVER -> if
    nidefawl.qubes.util.Side[] $VALUES -> do
    3:3:nidefawl.qubes.util.Side[] values() -> values
    3:3:nidefawl.qubes.util.Side valueOf(java.lang.String) -> valueOf
    3:3:void <init>(java.lang.String,int) -> <init>
    3:4:void <clinit>() -> <clinit>
nidefawl.qubes.util.SimpleResourceManager -> L1JillIjJiL11LjI:
    java.util.List resources -> do
    14:16:void <init>() -> <init>
    20:21:void addResource(nidefawl.qubes.util.IManagedResource) -> do
    25:28:void release() -> do
    32:38:void releaseAll(nidefawl.qubes.util.EResourceType) -> do
nidefawl.qubes.util.SingleBlockWorld -> JiiJjIL1JiIj1LJi:
    int id -> do
    int data -> if
    nidefawl.qubes.vec.BlockPos pos -> do
    int airId -> for
    int airData -> int
    int light -> new
    nidefawl.qubes.chunk.blockdata.BlockData bdata -> do
    nidefawl.qubes.biome.Biome biome -> do
    21:29:void <init>() -> <init>
    32:35:void set(int,int,int,int,int) -> do
    47:50:int getType(int,int,int) -> if
    60:60:boolean is(int,int,int) -> do
    80:82:int getData(int,int,int) -> do
    87:90:boolean isNormalBlock(int,int,int,int) -> do
    95:95:boolean setTypeData(int,int,int,int,int,int) -> do
    100:100:int getLight(int,int,int) -> int
    105:105:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    112:113:void setBlockData(nidefawl.qubes.chunk.blockdata.BlockData) -> do
    129:129:int getBiomeFaceColor(int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    134:134:int getWater(int,int,int) -> for
nidefawl.qubes.util.SnakeIterator -> jI1LiJL11LiJL1Ji:
    int dx -> do
    int dz -> if
    int currentFace -> for
    int pos -> int
    int legPos -> new
    int legsize -> try
    int currentLeg -> byte
    int max -> case
    int[][] direction -> do
    9:15:void <init>() -> <init>
    18:25:void reset() -> do
    31:49:void next() -> if
    53:53:int getX() -> do
    56:56:int getZ() -> if
nidefawl.qubes.util.Stats -> jIiJIjllJiiJ1Lll:
    int fpsCounter -> do
    int uniformCalls -> if
    float avgFrameTime -> do
    double timeMeshing -> do
    double timeRendering -> if
    double fpsInteval -> for
    int regionUpdates -> for
    float lastFrameTimeD -> if
    int tessDrawCalls -> int
    int modelDrawCalls -> new
    int regionDrawCalls -> try
    int lastFrameDrawCalls -> byte
    int uploadBytes -> case
    19:24:void resetDrawCalls() -> do
    5:11:void <clinit>() -> <clinit>
nidefawl.qubes.util.StringUtil -> L1L1jI1LJilllljI:
    8:18:java.lang.String[] dropArrIdx(java.lang.String[],int) -> do
    23:26:long parseLong(java.lang.String,long,int) -> do
    32:34:java.util.UUID parseUUID(java.lang.String,java.util.UUID) -> do
    40:42:int parseInt(java.lang.String,int) -> do
    47:54:java.lang.String combine(java.lang.String[],int,int) -> do
nidefawl.qubes.util.SysInfo -> L1IjlljIIjlljI:
    java.lang.String osName -> do
    boolean isWindows -> do
    boolean is64Bit -> if
    java.lang.String javaVersion -> if
    long memoryMb -> do
    java.lang.String javaMachineVersion -> for
    java.lang.String openGLVersion -> int
    java.lang.String openGLVendor -> new
    16:33:void <init>() -> <init>
nidefawl.qubes.util.ThreadedWorker -> llllL11L1L1LiJjI:
    java.lang.Object sync -> do
    int numThreads -> do
    java.lang.Thread[] threads -> do
    nidefawl.qubes.util.ResettableCountDownLatch latch -> do
    nidefawl.qubes.util.ResettableCountDownLatch latch2 -> if
    nidefawl.qubes.util.IThreadedWork target -> do
    boolean isRunning -> do
    4:19:void <init>(int) -> <init>
    23:33:void init() -> do
    54:66:void work(nidefawl.qubes.util.IThreadedWork) -> do
    3:3:boolean access$000(nidefawl.qubes.util.ThreadedWorker) -> do
    3:3:java.lang.Object access$100(nidefawl.qubes.util.ThreadedWorker) -> do
    3:3:nidefawl.qubes.util.ResettableCountDownLatch access$200(nidefawl.qubes.util.ThreadedWorker) -> do
    3:3:nidefawl.qubes.util.IThreadedWork access$300(nidefawl.qubes.util.ThreadedWorker) -> do
    3:3:nidefawl.qubes.util.ResettableCountDownLatch access$400(nidefawl.qubes.util.ThreadedWorker) -> if
nidefawl.qubes.util.ThreadedWorker$Threaded -> JiL1iJJiJiL1L11L:
    int threadId -> do
    nidefawl.qubes.util.ThreadedWorker worker -> do
    73:76:void <init>(nidefawl.qubes.util.ThreadedWorker,int) -> <init>
    81:93:void run() -> run
nidefawl.qubes.util.Timer -> jIJi1LiJ1LJiL1L1:
    int tickspersec -> if
    long ms -> for
    long ns -> int
    long last -> new
    int ticks -> do
    float partialTick -> do
    long el -> do
    long absTime -> if
    11:22:void <init>(int) -> <init>
    25:83:long getTime() -> do
    87:93:void calculate() -> do
nidefawl.qubes.util.TripletIntHash -> L11LjIIjJiiJiJ1L:
    6:8:int toHash(int,int,int) -> do
    11:11:int getX(int) -> do
    14:14:int getZ(int) -> if
    17:17:int getY(int) -> for
nidefawl.qubes.util.TripletLongHash -> IjiJjIjIIj1LL1L1:
    6:8:long toHash(long,long,long) -> do
    11:11:int getX(long) -> do
    14:14:int getZ(long) -> if
    17:17:int getY(long) -> for
nidefawl.qubes.util.TripletShortHash -> Ij1L1LJiiJL1IjjI:
    6:6:short toHash(int,int,int) -> do
    9:9:int getX(int) -> do
    12:12:int getZ(int) -> if
    15:15:int getY(int) -> for
nidefawl.qubes.util.UnsafeHelper -> jIll1L1LiJJijIL1:
    long ADDRESS -> do
    long CAPACITY -> if
    sun.misc.Unsafe UNSAFE -> do
    java.nio.ByteBuffer BYTE_BUFFER -> do
    java.nio.ShortBuffer SHORT_BUFFER -> do
    java.nio.CharBuffer CHAR_BUFFER -> do
    java.nio.IntBuffer INT_BUFFER -> do
    java.nio.LongBuffer LONG_BUFFER -> do
    java.nio.FloatBuffer FLOAT_BUFFER -> do
    java.nio.DoubleBuffer DOUBLE_BUFFER -> do
    long PARENT_BYTE -> for
    long PARENT_SHORT -> int
    long PARENT_CHAR -> new
    long PARENT_INT -> try
    long PARENT_LONG -> byte
    long PARENT_FLOAT -> case
    long PARENT_DOUBLE -> char
    71:98:sun.misc.Unsafe getUnsafeInstance() -> do
    102:127:java.lang.reflect.Field getField(java.nio.Buffer,java.lang.Object) -> do
    131:143:java.lang.reflect.Field getDeclaredField(java.lang.Class,java.lang.String) -> do
    147:147:long alloc(long) -> do
    150:151:void free(long) -> do
    154:158:java.nio.ByteBuffer memByteBuffer(long,int) -> do
    162:162:long memAddress0(java.nio.Buffer) -> do
    166:172:java.nio.Buffer setup(java.nio.Buffer,long,int,long) -> do
    177:180:java.nio.ByteBuffer memSetupBuffer(java.nio.ByteBuffer,long,int) -> do
    183:187:void copyDoubleArray(long,double[]) -> do
    18:68:void <clinit>() -> <clinit>
nidefawl.qubes.vec.AABB -> L1L1JijIJiiJL1ll:
    double minX -> do
    double minY -> if
    double minZ -> for
    double maxX -> int
    double maxY -> new
    double maxZ -> try
    16:23:void <init>(double,double,double,double,double,double) -> <init>
    25:26:void <init>() -> <init>
    29:30:void <init>(nidefawl.qubes.vec.AABBInt) -> <init>
    33:33:double getWidth() -> do
    36:36:double getHeight() -> if
    39:39:double getLength() -> for
    43:49:void offset(double,double,double) -> do
    52:64:void expandTo(double,double,double) -> if
    77:83:void set(double,double,double,double,double,double) -> do
    88:89:void set(nidefawl.qubes.vec.AABB) -> do
    92:93:nidefawl.qubes.vec.AABB setWithOffset(nidefawl.qubes.vec.AABB,double,double,double) -> do
    97:98:void set(nidefawl.qubes.vec.AABBFloat) -> do
    102:102:double getCenterX() -> int
    110:110:double getCenterZ() -> new
    114:118:void centerXZ(double,double,double) -> for
    131:147:double getXOffset(nidefawl.qubes.vec.AABB,double) -> do
    151:167:double getZOffset(nidefawl.qubes.vec.AABB,double) -> if
    171:187:double getYOffset(nidefawl.qubes.vec.AABB,double) -> for
    192:192:java.lang.String toString() -> toString
    197:203:void read(java.io.DataInput) -> do
    207:213:void write(java.io.DataOutput) -> do
nidefawl.qubes.vec.AABBFloat -> lljIjIlliJllL1iJ:
    float minX -> do
    float minY -> if
    float minZ -> for
    float maxX -> int
    float maxY -> new
    float maxZ -> try
    long negativeZeroFloatBits -> do
    12:19:void <init>(float,float,float,float,float,float) -> <init>
    21:22:void <init>() -> <init>
    35:41:void offset(float,float,float) -> do
    44:56:void expandBounds(float,float,float) -> if
    69:75:void set(float,float,float,float,float,float) -> do
    80:81:void set(nidefawl.qubes.vec.AABBFloat) -> do
    116:122:boolean intersects(nidefawl.qubes.vec.AABB) -> do
    128:128:java.lang.String toString() -> toString
    144:195:boolean raytrace(nidefawl.qubes.util.RayTrace,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    200:205:boolean min(float,float) -> do
    208:213:boolean max(float,float) -> if
    216:216:boolean isEqual(nidefawl.qubes.vec.AABBFloat) -> do
    198:198:void <clinit>() -> <clinit>
nidefawl.qubes.vec.AABBInt -> L1llIjjIIjjI1LIj:
    int minX -> do
    int minY -> if
    int minZ -> for
    int maxX -> int
    int maxY -> new
    int maxZ -> try
    13:20:void <init>(int,int,int,int,int,int) -> <init>
    22:23:void <init>() -> <init>
    70:76:void set(int,int,int,int,int,int) -> do
    81:82:void set(nidefawl.qubes.vec.AABBInt) -> do
    115:115:java.lang.String toString() -> toString
    119:126:nidefawl.qubes.nbt.Tag$Compound saveTag() -> do
    130:136:void loadTag(nidefawl.qubes.nbt.Tag$Compound) -> do
    139:139:boolean contains(int,int,int) -> do
    143:143:boolean contains(nidefawl.qubes.vec.BlockPos) -> do
nidefawl.qubes.vec.BlockBoundingBox -> JiIjiJIjIjIjiJJi:
    int lowX -> do
    int highX -> if
    int lowY -> for
    int highY -> int
    int lowZ -> new
    int highZ -> try
    17:19:void <init>(int,int,int,int,int,int) -> <init>
    24:26:void <init>() -> <init>
    30:32:void expandTo(int,int,int,int,int,int) -> do
    35:54:void flag(int,int,int) -> do
    62:64:void checkBounds(int,int,int) -> if
    67:73:void set(int,int,int,int,int,int) -> if
    76:77:nidefawl.qubes.vec.BlockBoundingBox copyTo(nidefawl.qubes.vec.BlockBoundingBox) -> do
    81:81:int getLength() -> do
    85:85:int getWidth() -> if
    89:89:int getHeight() -> for
    93:93:int getVolume() -> int
    112:113:void reset() -> do
    123:125:void extend(nidefawl.qubes.vec.BlockBoundingBox) -> do
    132:132:java.lang.String toString() -> toString
    139:139:short getMinHash() -> do
    145:145:short getMaxHash() -> if
    154:154:nidefawl.qubes.vec.BlockBoundingBox fromShorts(short,short) -> do
nidefawl.qubes.vec.BlockPos -> iJ1LJiIjIjjIL1L1:
    int x -> do
    int y -> if
    int z -> for
    12:13:void <init>() -> <init>
    14:18:void <init>(int,int,int) -> <init>
    24:24:java.lang.String toString() -> toString
    29:33:boolean equals(java.lang.Object) -> equals
    38:38:int hashCode() -> hashCode
    42:42:nidefawl.qubes.vec.BlockPos copy() -> do
    50:53:void set(int,int,int) -> do
    58:61:void offset(int) -> do
    64:67:void read(java.io.DataInput) -> do
    70:73:void write(java.io.DataOutput) -> do
    78:81:void set(nidefawl.qubes.vec.BlockPos) -> do
    95:95:boolean isEqualTo(int,int,int) -> do
    100:100:float x() -> do
    104:104:float y() -> if
    108:108:float z() -> for
nidefawl.qubes.vec.ChunkPos -> JiIjIjL1JiiJiJL1:
    int x -> do
    int z -> if
    11:12:void <init>() -> <init>
    13:16:void <init>(int,int) -> <init>
    22:22:java.lang.String toString() -> toString
    27:31:boolean equals(java.lang.Object) -> equals
    36:36:int hashCode() -> hashCode
    44:46:void read(java.io.DataInput) -> do
    49:51:void write(java.io.DataOutput) -> do
nidefawl.qubes.vec.Dir -> L1IjjIjIlliJIjjI:
    12:12:int getDirX(int) -> do
    16:16:int getDirZ(int) -> if
    20:20:int getDirY(int) -> for
    28:28:boolean isTopBottom(int) -> do
    53:67:java.lang.String asString(int) -> do
    88:88:int opposite(int) -> int
nidefawl.qubes.vec.Frustum -> L1jI1LJijIjIjIJi:
    nidefawl.qubes.vec.Vector4f[] frustum -> do
    nidefawl.qubes.vec.Vector3f up -> do
    nidefawl.qubes.vec.Vector3f forward -> if
    nidefawl.qubes.vec.Vector3f cam -> for
    nidefawl.qubes.vec.Vector3f tmp -> int
    nidefawl.qubes.vec.Vector3f X -> new
    nidefawl.qubes.vec.Vector3f Y -> try
    nidefawl.qubes.vec.Vector3f Z -> byte
    float znear -> do
    float zfar -> if
    float ratio -> for
    float tang -> int
    float angle -> new
    float sphereFactorY -> try
    float sphereFactorX -> byte
    6:30:void <init>() -> <init>
    33:45:void setCamInternals(float,float,float,float) -> do
    80:110:void set(nidefawl.qubes.vec.Matrix4f) -> do
    115:120:void normalize(int) -> do
    123:123:float planeDistance(nidefawl.qubes.vec.Vector4f,float,float,float) -> do
    165:194:int sphereInFrustum(nidefawl.qubes.vec.Vector3f,float) -> do
    245:245:int checkFrustum(nidefawl.qubes.vec.AABBInt,float) -> do
    255:276:int checkFrustum(nidefawl.qubes.vec.AABBInt) -> do
    280:300:void setPos(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Matrix4f) -> do
nidefawl.qubes.vec.IVec3 -> iJL1jIL1Ij1LJi:
    float x() -> do
    float y() -> if
    float z() -> for
nidefawl.qubes.vec.Matrix4f -> iJjIjIJiJi1LiJ:
    nidefawl.qubes.util.DumbPool pool -> do
    float m00 -> do
    float m01 -> if
    float m02 -> for
    float m03 -> int
    float m10 -> new
    float m11 -> try
    float m12 -> byte
    float m13 -> case
    float m20 -> char
    float m21 -> else
    float m22 -> goto
    float m23 -> long
    float m30 -> this
    float m31 -> void
    float m32 -> break
    float m33 -> catch
    13:13:nidefawl.qubes.vec.Matrix4f pool() -> if
    22:24:nidefawl.qubes.vec.Matrix4f pool(nidefawl.qubes.vec.Matrix4f) -> do
    33:35:void <init>() -> <init>
    38:40:void <init>(nidefawl.qubes.vec.Matrix4f) -> <init>
    69:74:java.lang.String toString() -> toString
    90:90:nidefawl.qubes.vec.Matrix4f setIdentity() -> for
    99:116:nidefawl.qubes.vec.Matrix4f setIdentity(nidefawl.qubes.vec.Matrix4f) -> if
    124:124:nidefawl.qubes.vec.Matrix4f setZero() -> int
    133:150:nidefawl.qubes.vec.Matrix4f setZero(nidefawl.qubes.vec.Matrix4f) -> for
    159:159:nidefawl.qubes.vec.Matrix4f load(nidefawl.qubes.vec.Matrix4f) -> int
    169:188:nidefawl.qubes.vec.Matrix4f load(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    224:242:nidefawl.qubes.vec.Matrix4f load(float[]) -> do
    280:296:nidefawl.qubes.vec.Matrix4f store(java.nio.FloatBuffer) -> do
    308:325:nidefawl.qubes.vec.Matrix4f store(float[],int) -> do
    441:478:nidefawl.qubes.vec.Matrix4f mul(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    490:503:nidefawl.qubes.vec.Vector4f transform(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector4f,nidefawl.qubes.vec.Vector4f) -> do
    515:528:nidefawl.qubes.vec.Vector3f transform(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    569:581:nidefawl.qubes.vec.Vector3f transformTransposed(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> if
    589:589:nidefawl.qubes.vec.Matrix4f transpose() -> new
    598:598:nidefawl.qubes.vec.Matrix4f translate(float,float,float) -> do
    607:607:nidefawl.qubes.vec.Matrix4f translate(nidefawl.qubes.vec.Vector3f) -> do
    625:625:nidefawl.qubes.vec.Matrix4f scale(float) -> do
    628:640:nidefawl.qubes.vec.Matrix4f scale(float,float,float) -> if
    675:675:nidefawl.qubes.vec.Matrix4f rotate(float,float,float,float) -> do
    686:686:nidefawl.qubes.vec.Matrix4f rotate(float,float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    755:799:nidefawl.qubes.vec.Matrix4f rotate(float,float,float,float,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    809:809:nidefawl.qubes.vec.Matrix4f translate(float,float,float,nidefawl.qubes.vec.Matrix4f) -> do
    820:828:nidefawl.qubes.vec.Matrix4f translate(float,float,float,nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> do
    837:837:nidefawl.qubes.vec.Matrix4f transpose(nidefawl.qubes.vec.Matrix4f) -> new
    847:883:nidefawl.qubes.vec.Matrix4f transpose(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> if
    890:911:float determinant() -> do
    923:923:float determinant3x3(float,float,float,float,float,float,float,float,float) -> do
    933:933:nidefawl.qubes.vec.Matrix4f invert() -> try
    988:1041:nidefawl.qubes.vec.Matrix4f invert(nidefawl.qubes.vec.Matrix4f,nidefawl.qubes.vec.Matrix4f) -> for
    1093:1098:void transformVecTransposed(nidefawl.qubes.vec.Vector3f) -> do
    1102:1150:void mulMat(nidefawl.qubes.vec.Matrix4f) -> do
    1234:1250:void addWeighted(nidefawl.qubes.vec.Matrix4f,float) -> do
    1279:1297:void toEuler(nidefawl.qubes.vec.Vector3f) -> if
    1320:1327:void clearTranslation() -> for
    10:10:void <clinit>() -> <clinit>
nidefawl.qubes.vec.StackChangeCallBack -> llll1L1LiJL11LIj:
    void onChange(nidefawl.qubes.vec.Vector3f) -> do
nidefawl.qubes.vec.TransformStack -> IjlliJjIL1JijIJi:
    nidefawl.qubes.vec.Vector3f[] stack -> do
    int stackSize -> do
    nidefawl.qubes.vec.Vector3f tmp -> do
    nidefawl.qubes.vec.StackChangeCallBack cb -> do
    13:21:void <init>() -> <init>
    23:33:void translate(float,float,float) -> do
    35:39:void push() -> do
    41:46:void push(float,float,float) -> if
    48:53:void pop() -> if
    55:59:nidefawl.qubes.vec.Vector3f get() -> do
    62:63:void setCallBack(nidefawl.qubes.vec.StackChangeCallBack) -> do
    65:75:void setTranslation(float,float,float) -> for
    78:80:void setScissors(int,int,int,int) -> do
    11:11:void <clinit>() -> <clinit>
nidefawl.qubes.vec.Vec3D -> IjjIJiIjJiiJiJ1L:
    double x -> do
    double y -> if
    double z -> for
    10:11:void <init>() -> <init>
    13:17:void <init>(double,double,double) -> <init>
    19:21:void <init>(nidefawl.qubes.vec.Vec3D) -> <init>
    24:24:nidefawl.qubes.vec.BlockPos toBlock() -> do
    28:31:void set(nidefawl.qubes.vec.Vec3D) -> do
    39:42:void set(double,double,double) -> do
    45:45:double lengthSquared() -> do
    56:60:nidefawl.qubes.vec.Vec3D add(nidefawl.qubes.vec.Vec3D,nidefawl.qubes.vec.Vec3D,nidefawl.qubes.vec.Vec3D) -> do
    64:68:nidefawl.qubes.vec.Vec3D sub(nidefawl.qubes.vec.Vec3D,nidefawl.qubes.vec.Vec3D,nidefawl.qubes.vec.Vec3D) -> if
    128:132:nidefawl.qubes.vec.Vec3D scale(double) -> do
    143:152:java.lang.String toString() -> toString
    180:180:double length() -> if
    205:208:double distanceSq(nidefawl.qubes.vec.Vec3D) -> do
    212:215:void addVec(nidefawl.qubes.vec.Vec3D) -> if
    222:228:void interp(nidefawl.qubes.vec.Vec3D,nidefawl.qubes.vec.Vec3D,double,nidefawl.qubes.vec.Vec3D) -> do
nidefawl.qubes.vec.Vector2f -> JiIjIj1Lll1LjI1L:
    float x -> do
    float y -> if
    16:17:void <init>() -> <init>
    56:58:void set(double,double) -> do
nidefawl.qubes.vec.Vector3f -> Ij1LiJJiL1IjiJL1:
    nidefawl.qubes.vec.Vector3f ZERO -> do
    nidefawl.qubes.vec.Vector3f ONE -> if
    nidefawl.qubes.util.DumbPool pool -> do
    float x -> do
    float y -> if
    float z -> for
    19:19:nidefawl.qubes.vec.Vector3f pool() -> do
    22:24:nidefawl.qubes.vec.Vector3f pool(nidefawl.qubes.vec.Vector3f) -> do
    27:29:nidefawl.qubes.vec.Vector3f pool(float,float,float) -> do
    38:39:void <init>() -> <init>
    44:46:void <init>(nidefawl.qubes.vec.Vector3f) -> <init>
    51:53:void <init>(float,float,float) -> <init>
    55:57:void <init>(nidefawl.qubes.vec.Vec3D) -> <init>
    60:61:void <init>(double) -> <init>
    75:76:void set(nidefawl.qubes.vec.Vector3f) -> do
    82:85:nidefawl.qubes.vec.Vector3f set(float,float,float) -> if
    98:98:float lengthSquared() -> int
    111:114:nidefawl.qubes.vec.Vector3f translate(float,float,float) -> for
    129:133:nidefawl.qubes.vec.Vector3f add(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    149:153:nidefawl.qubes.vec.Vector3f sub(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> if
    170:175:nidefawl.qubes.vec.Vector3f cross(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> for
    234:234:float dot(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f) -> do
    270:274:nidefawl.qubes.vec.Vector3f scale(float) -> do
    283:287:nidefawl.qubes.vec.Vector3f store(java.nio.FloatBuffer) -> do
    294:303:java.lang.String toString() -> toString
    326:327:void setX(float) -> do
    335:336:void setY(float) -> if
    344:345:void setZ(float) -> for
    358:358:float length() -> new
    367:372:nidefawl.qubes.vec.Vector3f normalise() -> if
    376:381:nidefawl.qubes.vec.Vector3f normaliseZero() -> for
    385:390:nidefawl.qubes.vec.Vector3f normaliseNull() -> int
    401:402:void set(nidefawl.qubes.vec.Vec3D) -> do
    408:411:void addVec(nidefawl.qubes.vec.Vector3f) -> if
    420:423:float distanceSq(float,float,float) -> do
    434:437:void write(java.io.DataOutput) -> do
    440:443:void read(java.io.DataInput) -> do
    456:457:void subtract(nidefawl.qubes.vec.Vector3f) -> for
    460:465:void interp(nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Vector3f,float,nidefawl.qubes.vec.Vector3f) -> do
    467:472:void interp(nidefawl.qubes.vec.Vec3D,nidefawl.qubes.vec.Vec3D,float,nidefawl.qubes.vec.Vector3f) -> do
    475:486:void setElement(int,float) -> do
    489:492:nidefawl.qubes.vec.Vector3f add(nidefawl.qubes.vec.IVec3) -> do
    496:496:float x() -> do
    499:499:float y() -> if
    502:502:float z() -> for
    13:16:void <clinit>() -> <clinit>
nidefawl.qubes.vec.Vector4f -> JiIjIjIjiJJiiJ1L:
    nidefawl.qubes.util.DumbPool pool -> do
    float x -> do
    float y -> if
    float z -> for
    float w -> int
    31:32:void <init>() -> <init>
    48:50:void <init>(float,float,float,float) -> <init>
    73:77:void set(float,float,float,float) -> do
    83:83:float lengthSquared() -> do
    255:255:java.lang.String toString() -> toString
    258:264:java.lang.String toShortString(int) -> do
    333:333:float length() -> if
    366:380:void setElement(int,float) -> do
    9:9:void <clinit>() -> <clinit>
nidefawl.qubes.vr.CGLRenderModelNative -> L1IjiJL1llJilliJ:
    jopenvr.RenderModel_t t -> do
    jopenvr.RenderModel_TextureMap_t tex -> do
    nidefawl.qubes.gl.GLVBO vbo -> do
    nidefawl.qubes.gl.GLVBO vboIndex -> if
    int texId -> do
    int m_unVertexCount -> if
    boolean init -> do
    27:32:void <init>(jopenvr.RenderModel_t,jopenvr.RenderModel_TextureMap_t) -> <init>
    35:72:void init() -> do
    74:85:void render() -> if
nidefawl.qubes.vr.VR -> iJjIllL1L11LllL1:
    jopenvr.VR_IVRSystem_FnTable vrsystem -> do
    nidefawl.qubes.vr.VR$VRSettings settings -> do
    nidefawl.qubes.vr.VR$VRViewProjection cam -> do
    java.nio.FloatBuffer tlastVsync -> do
    java.nio.LongBuffer _tframeCount -> do
    java.nio.IntBuffer hmdDisplayFrequency -> do
    jopenvr.TrackedDevicePose_t$ByReference hmdTrackedDevicePoseReference -> do
    jopenvr.TrackedDevicePose_t[] hmdTrackedDevicePoses -> do
    double timePerFrame -> do
    boolean initCalled -> do
    boolean initSuccess -> if
    boolean initDone -> for
    java.lang.String initStatus -> do
    jopenvr.VR_IVRCompositor_FnTable vrCompositor -> do
    java.nio.IntBuffer hmdErrorStore -> if
    jopenvr.VR_IVROverlay_FnTable vrOverlay -> do
    jopenvr.VR_IVRRenderModels_FnTable vrRenderModels -> do
    jopenvr.VR_IVRSettings_FnTable vrSettings -> do
    jopenvr.Texture_t texType0 -> do
    jopenvr.Texture_t texType1 -> if
    nidefawl.qubes.vec.Matrix4f[] poseMatrices -> do
    nidefawl.qubes.vec.Vec3D[] deviceVelocity -> do
    nidefawl.qubes.vec.Matrix4f hmdPose -> do
    nidefawl.qubes.vec.Matrix4f pose -> if
    nidefawl.qubes.vec.Matrix4f offsetPose -> for
    nidefawl.qubes.vec.Matrix4f offsetPoseInv -> int
    nidefawl.qubes.vec.Matrix4f poseInv -> new
    boolean headIsTracking -> new
    int RIGHT_CONTROLLER -> int
    int LEFT_CONTROLLER -> new
    boolean[] controllerTracking -> do
    nidefawl.qubes.vec.Matrix4f[] controllerPose -> if
    nidefawl.qubes.vec.Matrix4f[] controllerRotation -> for
    int[] controllerDeviceIndex -> do
    jopenvr.VRControllerState_t$ByReference[] inputStateRefernceArray -> do
    nidefawl.qubes.vec.Vec3D[][] controllerVelocitySamples -> do
    int[] controllerVelocitySampleCount -> if
    nidefawl.qubes.vec.Matrix4f[] controllerTipTransform -> int
    nidefawl.qubes.vec.Matrix4f[] handRotation -> new
    int renderWidth -> do
    int renderHeight -> if
    nidefawl.qubes.vr.CGLRenderModelNative[] m_rTrackedDeviceToRenderModel -> do
    boolean[] isTrackedDeviceConnected -> if
    int[] trackedDeviceClass -> for
    java.util.HashMap models -> do
    java.util.HashSet missingModels -> do
    boolean isInputCaptured -> int
    jopenvr.VREvent_t$ByReference eventStructReference -> do
    nidefawl.qubes.vec.Vector4f tmp1 -> do
    nidefawl.qubes.vec.Vector4f tmp2 -> if
    nidefawl.qubes.vec.Vector3f tmp3 -> do
    float rotationSpeed -> do
    float lastRotationSpeed -> if
    float rotation -> for
    float lastRotation -> int
    nidefawl.qubes.shader.Shader modelShader -> do
    int ticka -> for
    nidefawl.qubes.gl.FrameBuffer fbLeft -> do
    nidefawl.qubes.gl.FrameBuffer fbRight -> if
    182:184:com.sun.jna.Pointer ptrFomrString(java.lang.String) -> do
    189:222:boolean InitVR() -> do
    228:248:void initModelShaders() -> case
    251:260:java.lang.String GetTrackedDeviceString(int,int) -> do
    265:279:void SetupRenderModelForTrackedDevice(int) -> if
    282:318:nidefawl.qubes.vr.CGLRenderModelNative FindOrLoadRenderModel(java.lang.String) -> do
    322:337:void initOpenVRRenderModels() -> do
    341:349:void initOpenVROverlay() -> if
    352:367:void initOpenVROSettings() -> for
    369:416:void initializeJOpenVR() -> char
    420:484:void initOpenVRCompositor(boolean) -> do
    489:513:java.lang.String getCompostiorError(int) -> do
    520:646:void updatePose(float) -> do
    666:666:void getTipTransforms() -> else
    670:680:void findControllerDevices() -> goto
    683:722:void Submit() -> int
    725:739:void initApp(nidefawl.qubes.GameBase) -> do
    743:767:void tick() -> new
    771:790:void initVRFB(int,int) -> if
    792:797:nidefawl.qubes.vec.Matrix4f getViewMat(int) -> do
    801:806:nidefawl.qubes.vec.Matrix4f getPoseMat(int) -> if
    812:812:boolean isInit() -> if
    816:824:nidefawl.qubes.gl.FrameBuffer getFB(int) -> do
    829:840:void setViewPort(int) -> do
    845:851:nidefawl.qubes.vec.Matrix4f convertSteamVRMatrix3ToMatrix4f(jopenvr.HmdMatrix34_t,nidefawl.qubes.vec.Matrix4f) -> do
    856:860:nidefawl.qubes.vec.Matrix4f convertSteamVRMatrix4ToMatrix4f(jopenvr.HmdMatrix44_t,nidefawl.qubes.vec.Matrix4f) -> do
    864:880:void Matrix4fSet(nidefawl.qubes.vec.Matrix4f,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float) -> do
    883:908:void drawFullscreenCompanion(int,int) -> do
    911:914:void shutdown() -> try
    917:987:void renderControllers() -> byte
    989:1018:void renderControllerAxes(int,nidefawl.qubes.vec.Matrix4f) -> do
    1021:1030:float getAxis(int,int,int) -> do
    92:741:void <clinit>() -> <clinit>
nidefawl.qubes.vr.VR$1 -> IjjIJiiJjIIjjIIj:
    229:229:void <init>() -> <init>
    232:235:java.lang.String getDefinition(java.lang.String) -> getDefinition
nidefawl.qubes.vr.VR$VRSettings -> jIiJ1LJi1LIjll1L:
    boolean vrReverseHands -> do
    88:88:void <init>() -> <init>
nidefawl.qubes.vr.VR$VRViewProjection -> jIIjL1iJjIjIJi1L:
    nidefawl.qubes.vec.Matrix4f projLeft -> do
    nidefawl.qubes.vec.Matrix4f projRight -> if
    nidefawl.qubes.vec.Matrix4f poseEyeLeft -> for
    nidefawl.qubes.vec.Matrix4f poseEyeRight -> int
    nidefawl.qubes.vec.Matrix4f viewLeft -> new
    nidefawl.qubes.vec.Matrix4f viewRight -> try
    nidefawl.qubes.vec.Matrix4f poseLeft -> byte
    nidefawl.qubes.vec.Matrix4f poseRight -> case
    nidefawl.qubes.vec.Vector3f unifiedFrustumCameraOffset -> do
    36:45:void <init>() -> <init>
    47:55:void setEyeToHeadTransform() -> do
    58:64:void setEyeProj(float,float) -> do
    66:70:void update(float) -> do
    73:86:void calcFrustumOffset() -> if
nidefawl.qubes.vr.VREvents -> iJlliJIjiJll1L:
    114:319:java.lang.String evtToName(int) -> do
nidefawl.qubes.world.BlockPlacer -> L1llll1LllJiiJ:
    nidefawl.qubes.entity.PlayerServer player -> do
    nidefawl.qubes.item.BlockStack stack -> do
    long startTime -> do
    nidefawl.qubes.world.biomes.HexBiome biome -> do
    nidefawl.qubes.world.structure.tree.Tree tree -> do
    int resolved -> do
    nidefawl.qubes.vec.BlockPos pos -> do
    31:42:void <init>(nidefawl.qubes.entity.PlayerServer) -> <init>
    47:47:nidefawl.qubes.entity.Player getPlayer() -> do
    50:50:nidefawl.qubes.world.World getWorld() -> do
    54:67:nidefawl.qubes.world.structure.tree.Tree getTree() -> do
    70:74:nidefawl.qubes.world.biomes.HexBiome getBiome() -> do
    79:110:void tryMine(nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.item.BaseStack,int,int) -> do
    112:257:void tryPlace(nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.item.BlockStack,int) -> do
    267:277:void tryHarvest(int,int,int) -> do
    291:300:boolean canPlaceDefault(nidefawl.qubes.block.Block,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.vec.BlockPos,int,int,int) -> do
    310:315:void placeDefault(nidefawl.qubes.vec.BlockPos,int,int,int) -> do
    320:325:nidefawl.qubes.chunk.blockdata.BlockData getBlockData() -> do
nidefawl.qubes.world.IBlockWorld -> jIIjllllJi1LllL1:
    int getType(int,int,int) -> if
    int getData(int,int,int) -> do
    boolean isNormalBlock(int,int,int,int) -> do
    boolean setTypeData(int,int,int,int,int,int) -> do
    int getLight(int,int,int) -> int
    nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    int getBiomeFaceColor(int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    int getWater(int,int,int) -> for
nidefawl.qubes.world.IWorldSettings -> jIllllJijIIjiJiJ:
    long getSeed() -> do
    java.util.UUID getUUID() -> do
    long getTime() -> if
    int getId() -> do
    java.lang.String getName() -> do
    long getDayLen() -> for
    boolean isFixedTime() -> do
    void setTime(long) -> do
    void setDayLen(long) -> if
    void setFixedTime(boolean) -> do
nidefawl.qubes.world.SunLightModel -> IjJijIL1iJL1Ij1L:
    float dayLightIntensity -> do
    float nightNoon -> if
    float dayNoon -> for
    float lightAngleUp -> int
    nidefawl.qubes.vec.Matrix4f sunModelView -> do
    nidefawl.qubes.vec.Matrix4f moonModelView -> if
    nidefawl.qubes.vec.Vector3f sunPosition -> do
    nidefawl.qubes.vec.Vector3f moonPosition -> if
    nidefawl.qubes.vec.Vector3f lightPosition -> for
    nidefawl.qubes.vec.Vector3f lightDirection -> int
    nidefawl.qubes.vec.Vector3f tmp1 -> new
    long time -> do
    long dayLen -> if
    float sunPathRotation -> new
    float moonPathRotation -> try
    21:35:void <init>() -> <init>
    38:72:void updateFrame(float) -> do
    74:75:void setDayLen(long) -> do
    77:78:void setTime(long) -> if
    93:102:float getSunAngle(float) -> do
    111:111:nidefawl.qubes.vec.Vector3f getLightPosition() -> do
    114:114:float getLightAngleUp() -> do
    118:118:float getDayLightIntensity() -> if
    122:122:float getDayNoonFloat() -> for
    126:126:float getNightNoonFloat() -> int
nidefawl.qubes.world.World -> JijIIjjI1LIjJiIj:
    java.util.ArrayList lights -> do
    int worldHeight -> do
    int worldHeightMinusOne -> if
    int worldHeightBits -> for
    int worldHeightBitsPlusFour -> int
    int worldSeaLevel -> new
    long seed -> do
    nidefawl.qubes.chunk.ChunkManager chunkMgr -> do
    java.util.Random rand -> do
    java.util.UUID uuid -> do
    int id -> try
    nidefawl.qubes.world.IWorldSettings settings -> do
    nidefawl.qubes.world.biomes.IBiomeManager biomeManager -> do
    java.lang.String name -> do
    23:57:void <init>(nidefawl.qubes.world.IWorldSettings) -> <init>
    nidefawl.qubes.chunk.ChunkManager makeChunkManager() -> do
    74:86:float getSunAngle(float) -> do
    102:102:int getType(nidefawl.qubes.vec.BlockPos) -> do
    112:112:int getData(nidefawl.qubes.vec.BlockPos) -> if
    116:124:nidefawl.qubes.chunk.blockdata.BlockData getBlockData(int,int,int) -> do
    128:136:int getType(int,int,int) -> if
    140:148:int getWater(int,int,int) -> for
    152:160:int getData(int,int,int) -> do
    167:183:boolean setData(int,int,int,int,int) -> do
    191:208:boolean setType(int,int,int,int,int) -> if
    211:217:void updateBlocks(int,int,int,int,int) -> do
    220:224:nidefawl.qubes.block.Block getBlock(int,int,int) -> do
    229:246:boolean setBlockData(int,int,int,nidefawl.qubes.chunk.blockdata.BlockData,int) -> do
    250:250:boolean setBlockData(nidefawl.qubes.vec.BlockPos,nidefawl.qubes.chunk.blockdata.BlockData,int) -> do
    255:270:boolean setTypeData(int,int,int,int,int,int) -> do
    274:274:void updateLight(int,int,int) -> do
    void flagBlock(int,int,int) -> if
    279:279:nidefawl.qubes.chunk.Chunk getChunk(int,int) -> do
    284:284:void onLoad() -> do
    287:290:void removeLight(int) -> do
    293:304:void addLight(nidefawl.qubes.vec.Vector3f) -> do
    307:329:void spawnLights(nidefawl.qubes.vec.BlockPos) -> do
    333:337:int getHeight(int,int) -> do
    340:340:nidefawl.qubes.chunk.ChunkManager getChunkManager() -> if
    345:345:java.util.UUID getUUID() -> do
    353:353:long getTime() -> do
    357:357:long getDayLength() -> if
    361:363:long getDayTime() -> for
    371:371:int getId() -> do
    379:379:void updateLightHeightMap(nidefawl.qubes.chunk.Chunk,int,int,int,int,boolean) -> do
    382:392:nidefawl.qubes.chunk.Chunk getChunkIfNeightboursLoaded(int,int) -> if
    396:397:boolean canSeeSky(int,int,int) -> do
    401:402:boolean isTransparent(int,int,int) -> if
    414:417:int getLight(int,int,int) -> int
    430:430:void flagChunkLightUpdate(int,int) -> do
    433:433:java.lang.String getName() -> do
    441:441:nidefawl.qubes.world.IWorldSettings getSettings() -> do
    447:450:boolean isNormalBlock(int,int,int,int) -> do
    453:453:java.util.Random getRand() -> do
    java.util.List getEntityList() -> do
    463:463:int getBiomeFaceColor(int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    467:467:nidefawl.qubes.world.biomes.HexBiome getHex(int,int) -> do
    471:471:void spawnParticles(int,int,int,int,int) -> if
nidefawl.qubes.world.WorldClient -> llIjjIIj1LiJiJll:
    float dayLightIntensity -> do
    float nightNoon -> if
    float dayNoon -> for
    float lightAngleUp -> int
    nidefawl.qubes.vec.Matrix4f sunModelView -> do
    nidefawl.qubes.vec.Matrix4f moonModelView -> if
    nidefawl.qubes.vec.Vector3f sunPosition -> do
    nidefawl.qubes.vec.Vector3f moonPosition -> if
    nidefawl.qubes.vec.Vector3f lightPosition -> for
    nidefawl.qubes.vec.Vector3f lightDirection -> int
    nidefawl.qubes.vec.Vector3f tmp1 -> new
    java.util.HashMap entities -> do
    java.util.ArrayList entityList -> if
    java.util.ArrayList entityRemove -> for
    33:47:void <init>(nidefawl.qubes.world.WorldSettingsClient,nidefawl.qubes.world.biomes.IBiomeSettings) -> <init>
    55:61:nidefawl.qubes.world.biomes.IBiomeManager createBiomeManager(nidefawl.qubes.world.biomes.IBiomeSettings) -> do
    67:67:nidefawl.qubes.chunk.ChunkManager makeChunkManager() -> do
    71:103:void updateFrame(float) -> do
    105:105:nidefawl.qubes.vec.Vector3f getLightPosition() -> do
    108:108:float getLightAngleUp() -> do
    112:112:float getDayLightIntensity() -> if
    116:116:float getDayNoonFloat() -> for
    120:120:float getNightNoonFloat() -> int
    124:125:void flagBlock(int,int,int) -> if
    129:151:void tickUpdate() -> if
    156:158:void onLeave() -> for
    161:168:boolean addEntity(nidefawl.qubes.entity.Entity) -> do
    172:178:boolean removeEntity(nidefawl.qubes.entity.Entity) -> if
    183:183:nidefawl.qubes.entity.Entity getEntity(int) -> do
    187:187:java.util.List getEntityList() -> do
nidefawl.qubes.world.WorldClient$1 -> iJ1L1LIj1LiJll:
    int[] $SwitchMap$nidefawl$qubes$world$biomes$BiomeManagerType -> do
    55:55:void <clinit>() -> <clinit>
nidefawl.qubes.world.WorldServer -> iJiJll1LJiL1iJiJ:
    nidefawl.qubes.server.GameServer server -> do
    nidefawl.qubes.server.PlayerChunkTracker chunkTracker -> do
    java.util.List players -> do
    nidefawl.qubes.chunk.server.ChunkManagerServer chunkServer -> do
    nidefawl.qubes.worldgen.terrain.ITerrainGen generator -> do
    nidefawl.qubes.worldgen.populator.IChunkPopulator populator -> do
    java.util.Set generatorQueue -> do
    java.util.Set lightUpdateQueue -> if
    nidefawl.qubes.blocklight.BlockLightThread lightUpdater -> do
    java.util.HashMap entities -> do
    java.util.ArrayList entityList -> if
    java.util.ArrayList entityRemove -> for
    java.util.Iterator updateIt -> do
    37:129:void <init>(nidefawl.qubes.world.WorldSettings,nidefawl.qubes.server.GameServer) -> <init>
    67:71:void onLeave() -> if
    75:77:void onLoad() -> do
    83:83:nidefawl.qubes.worldgen.terrain.ITerrainGen getGenerator() -> do
    87:106:void tickUpdate() -> for
    109:111:void resyncTime() -> int
    114:119:void broadcastPacket(nidefawl.qubes.network.packet.Packet) -> do
    122:122:nidefawl.qubes.chunk.ChunkManager makeChunkManager() -> do
    126:126:nidefawl.qubes.server.GameServer getServer() -> do
    131:194:void updateChunks() -> new
    200:201:void unloadUnused() -> try
    204:215:void addPlayer(nidefawl.qubes.entity.PlayerServer) -> do
    218:224:void removePlayer(nidefawl.qubes.entity.PlayerServer) -> if
    228:239:boolean addEntity(nidefawl.qubes.entity.Entity) -> do
    243:254:boolean removeEntity(nidefawl.qubes.entity.Entity) -> if
    257:257:nidefawl.qubes.vec.Vector3f getSpawnPosition() -> do
    261:265:void save(boolean) -> do
    268:269:void flagBlock(int,int,int) -> if
    271:272:void flagChunk(int,int) -> if
    275:275:nidefawl.qubes.server.PlayerChunkTracker getPlayerChunkTracker() -> do
    279:281:void calcSunLight(nidefawl.qubes.chunk.Chunk) -> do
    285:312:void updateLightHeightMap(nidefawl.qubes.chunk.Chunk,int,int,int,int,boolean) -> do
    315:317:void updateLight(int,int,int) -> do
    320:321:void flagChunkLightUpdate(int,int) -> do
    326:326:nidefawl.qubes.worldgen.populator.IChunkPopulator getChunkPopulator() -> do
    332:347:int deleteAllChunks() -> if
    350:364:int regenChunks(java.util.Collection) -> do
    372:372:java.util.List getEntityList() -> do
    379:379:nidefawl.qubes.world.biomes.IBiomeManager getBiomeManager() -> do
    382:383:void queueGenTask(nidefawl.qubes.worldgen.structure.GenTask) -> do
    385:406:void genStructures() -> byte
    408:408:nidefawl.qubes.world.biomes.BiomeManagerType getBiomeType() -> do
    411:414:void spawnParticles(int,int,int,int,int) -> if
nidefawl.qubes.world.WorldSettings -> JiJiJi1LjIJijIiJ:
    long time -> do
    long dayLen -> if
    boolean isFixedTime -> do
    long seed -> for
    java.util.UUID uuid -> do
    java.io.File dir -> do
    int id -> do
    java.lang.String generatorName -> do
    java.lang.String worldName -> if
    27:27:long getDayLen() -> for
    32:32:boolean isFixedTime() -> do
    36:36:void read(java.io.DataInput) -> do
    40:49:void write(java.io.DataOutput) -> do
    15:55:void <init>(java.io.File) -> <init>
    59:64:void setDefaults() -> do
    68:76:void load() -> if
    79:79:java.io.File getWorldDirectory() -> do
    84:90:void save() -> for
    94:94:long getSeed() -> do
    99:99:java.util.UUID getUUID() -> do
    104:104:long getTime() -> if
    109:109:int getId() -> do
    113:114:void setId(int) -> do
    122:122:java.lang.String getName() -> do
    130:134:void saveFile() -> int
    138:139:void setTime(long) -> do
    143:144:void setFixedTime(boolean) -> do
    148:149:void setDayLen(long) -> if
nidefawl.qubes.world.WorldSettingsClient -> llJijIIjjIiJL1Ji:
    java.util.UUID uuid -> do
    long seed -> do
    long time -> if
    int id -> do
    java.lang.String worldName -> do
    long dayLen -> for
    boolean isFixedTime -> do
    21:28:void read(java.io.DataInput) -> do
    32:32:void write(java.io.DataOutput) -> do
    35:37:void <init>() -> <init>
    41:41:long getSeed() -> do
    46:46:java.util.UUID getUUID() -> do
    51:51:long getTime() -> if
    56:56:int getId() -> do
    61:61:java.lang.String getName() -> do
    66:66:long getDayLen() -> for
    71:71:boolean isFixedTime() -> do
    76:77:void setTime(long) -> do
    81:82:void setFixedTime(boolean) -> do
    86:87:void setDayLen(long) -> if
nidefawl.qubes.world.biomes.BiomeManagerType -> iJjI1Lll1LL1JiJi:
    nidefawl.qubes.world.biomes.BiomeManagerType SINGLE -> do
    nidefawl.qubes.world.biomes.BiomeManagerType HEX -> if
    nidefawl.qubes.world.biomes.BiomeManagerType[] $VALUES -> do
    3:3:nidefawl.qubes.world.biomes.BiomeManagerType[] values() -> values
    3:3:nidefawl.qubes.world.biomes.BiomeManagerType valueOf(java.lang.String) -> valueOf
    3:3:void <init>(java.lang.String,int) -> <init>
    7:7:nidefawl.qubes.world.biomes.BiomeManagerType fromId(int) -> do
    3:4:void <clinit>() -> <clinit>
nidefawl.qubes.world.biomes.BiomeSettingsHex -> iJ1LIj1LJiIjlljI:
    3:3:void <init>() -> <init>
    6:6:nidefawl.qubes.world.biomes.BiomeManagerType getType() -> do
nidefawl.qubes.world.biomes.BiomeSettingsStatic -> IjIjJiJi1LIjll1L:
    3:3:void <init>() -> <init>
    6:6:nidefawl.qubes.world.biomes.BiomeManagerType getType() -> do
nidefawl.qubes.world.biomes.EmptyBiomeManager -> IjiJ1LlliJIjllll:
    nidefawl.qubes.world.biomes.BiomeSettingsStatic settings -> do
    18:20:void <init>(nidefawl.qubes.world.World,long,nidefawl.qubes.world.IWorldSettings,nidefawl.qubes.world.biomes.IBiomeSettings) -> <init>
    22:24:void <init>(nidefawl.qubes.world.World,long,nidefawl.qubes.world.IWorldSettings) -> <init>
    28:28:nidefawl.qubes.biome.Biome getBiome(int,int) -> do
    33:33:int getBiomeFaceColor(nidefawl.qubes.world.World,int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    38:38:nidefawl.qubes.network.packet.PacketSWorldBiomes getPacket() -> do
    42:42:void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    46:46:void sendChanges() -> do
    50:50:void saveChanges() -> if
    53:53:nidefawl.qubes.world.biomes.HexBiome blockToHex(int,int) -> do
    58:58:void deleteAll() -> for
    62:62:nidefawl.qubes.world.biomes.IBiomeSettings getBiomeSettings() -> do
nidefawl.qubes.world.biomes.HexBiome -> iJIjL1jIJiJiIj:
    boolean needsSave -> do
    int version -> for
    nidefawl.qubes.biome.Biome biome -> do
    nidefawl.qubes.world.structure.StructureMap trees -> do
    nidefawl.qubes.world.structure.StructureMap mines -> if
    int subtype -> int
    26:45:void <init>(nidefawl.qubes.hex.HexagonGridStorage,int,int) -> <init>
    53:79:void load(java.io.File) -> do
    85:115:void save(java.io.File) -> if
    118:120:void registerTree(nidefawl.qubes.world.structure.tree.Tree) -> do
    123:125:void registerMine(nidefawl.qubes.world.structure.mine.Mine) -> do
    128:138:nidefawl.qubes.world.structure.tree.Tree getTree(int,int,int) -> do
    142:148:nidefawl.qubes.world.biomes.HexBiome[] getClosest3(double,double) -> do
    153:153:nidefawl.qubes.world.structure.StructureMap getTrees() -> do
    156:156:nidefawl.qubes.world.structure.StructureMap getMines() -> if
nidefawl.qubes.world.biomes.HexBiome$1 -> llL1L1L1jIL1L11L:
    nidefawl.qubes.world.biomes.HexBiome this$0 -> do
    29:29:void <init>(nidefawl.qubes.world.biomes.HexBiome) -> <init>
    32:32:nidefawl.qubes.world.structure.tree.Tree newInstance() -> do
    29:29:java.lang.Object newInstance() -> do
nidefawl.qubes.world.biomes.HexBiome$2 -> L11LJiiJL11LJi1L:
    nidefawl.qubes.world.biomes.HexBiome this$0 -> do
    35:35:void <init>(nidefawl.qubes.world.biomes.HexBiome) -> <init>
    38:38:nidefawl.qubes.world.structure.mine.Mine newInstance() -> do
    35:35:java.lang.Object newInstance() -> do
nidefawl.qubes.world.biomes.HexBiomeEnd -> jIiJIjIjllJill1L:
    12:14:void <init>(nidefawl.qubes.hex.HexagonGridStorage,int,int) -> <init>
    17:17:void save(java.io.File) -> if
    20:20:void registerTree(nidefawl.qubes.world.structure.tree.Tree) -> do
    23:23:void load(java.io.File) -> do
nidefawl.qubes.world.biomes.HexBiomes -> jIL1L1jIjIiJIjL1:
    nidefawl.qubes.world.World world -> do
    22:24:void <init>(nidefawl.qubes.world.World,long,nidefawl.qubes.world.IWorldSettings) -> <init>
    27:28:nidefawl.qubes.biome.Biome getBiome(int,int) -> do
    35:91:int getBiomeFaceColor(nidefawl.qubes.world.World,int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    18:18:nidefawl.qubes.world.biomes.HexBiome blockToHex(int,int) -> do
nidefawl.qubes.world.biomes.HexBiomesClient -> jIjIIjIj1LiJll:
    18:19:void <init>(nidefawl.qubes.world.World,long,nidefawl.qubes.world.IWorldSettings,nidefawl.qubes.world.biomes.IBiomeSettings) -> <init>
    22:22:nidefawl.qubes.world.biomes.HexBiome loadCell(int,int) -> if
    26:26:nidefawl.qubes.world.biomes.HexBiome oobCell(int,int) -> for
    31:31:nidefawl.qubes.network.packet.PacketSWorldBiomes getPacket() -> do
    35:42:void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    46:46:void sendChanges() -> do
    49:49:void saveChanges() -> if
    53:53:void deleteAll() -> for
    56:56:nidefawl.qubes.world.biomes.IBiomeSettings getBiomeSettings() -> do
    15:15:java.lang.Object oobCell(int,int) -> for
    15:15:java.lang.Object loadCell(int,int) -> if
nidefawl.qubes.world.biomes.HexBiomesServer -> JiiJJiJilljI1LjI:
    java.util.regex.Pattern FILE_PATTERN -> do
    boolean SAVE_LOAD -> do
    java.io.File dir -> do
    java.util.Set flaggedInstances -> do
    java.util.Set flaggedInstances2 -> if
    nidefawl.qubes.world.biomes.BiomeSettingsHex biomesettings -> do
    32:44:void <init>(nidefawl.qubes.world.World,long,nidefawl.qubes.world.IWorldSettings) -> <init>
    47:48:java.io.File getFile(int,int) -> do
    55:81:void loadFiles() -> int
    32:89:void <init>(java.io.File) -> <init>
    94:104:nidefawl.qubes.world.biomes.HexBiome loadCell(int,int) -> if
    108:111:void flagBiome(int,int) -> if
    116:121:nidefawl.qubes.network.packet.PacketSWorldBiomes getPacket() -> do
    128:141:nidefawl.qubes.network.packet.PacketSWorldBiomes makePacket(java.util.ArrayList) -> do
    146:146:void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    152:162:void sendChanges() -> do
    165:165:nidefawl.qubes.world.biomes.HexBiome oobCell(int,int) -> for
    169:183:void saveChanges() -> if
    186:187:void flag(int,int) -> do
    191:216:void deleteAll() -> for
    219:219:nidefawl.qubes.world.biomes.IBiomeSettings getBiomeSettings() -> do
    27:27:java.lang.Object oobCell(int,int) -> for
    27:27:java.lang.Object loadCell(int,int) -> if
    29:30:void <clinit>() -> <clinit>
nidefawl.qubes.world.biomes.HexBiomesServer$1 -> JiL1JiL1L1JijIll:
    nidefawl.qubes.world.biomes.HexBiomesServer this$0 -> do
    56:56:void <init>(nidefawl.qubes.world.biomes.HexBiomesServer) -> <init>
    60:60:boolean accept(java.io.File) -> accept
nidefawl.qubes.world.biomes.IBiomeManager -> iJjIJiIj1LIjiJIj:
    nidefawl.qubes.biome.Biome getBiome(int,int) -> do
    nidefawl.qubes.world.biomes.IBiomeSettings getBiomeSettings() -> do
    int getBiomeFaceColor(nidefawl.qubes.world.World,int,int,int,int,int,nidefawl.qubes.biome.BiomeColor) -> do
    nidefawl.qubes.network.packet.PacketSWorldBiomes getPacket() -> do
    void recvData(nidefawl.qubes.network.packet.PacketSWorldBiomes) -> do
    void sendChanges() -> do
    void saveChanges() -> if
    nidefawl.qubes.world.biomes.HexBiome blockToHex(int,int) -> do
    void deleteAll() -> for
nidefawl.qubes.world.biomes.IBiomeSettings -> IjIjL1JiIjiJjIJi:
    6:6:void <init>() -> <init>
    8:15:nidefawl.qubes.world.biomes.IBiomeSettings fromId(int) -> do
    18:25:int getId(nidefawl.qubes.world.biomes.IBiomeSettings) -> do
    nidefawl.qubes.world.biomes.BiomeManagerType getType() -> do
    29:29:void read(java.io.DataInput) -> do
    31:31:void write(java.io.DataOutput) -> do
nidefawl.qubes.world.biomes.IBiomeSettings$1 -> L1L1lljIiJ1LL1Ij:
    int[] $SwitchMap$nidefawl$qubes$world$biomes$BiomeManagerType -> do
    9:9:void <clinit>() -> <clinit>
nidefawl.qubes.world.structure.Structure -> jIJiL1llIjjIll1L:
    java.util.Set keys -> do
    nidefawl.qubes.vec.AABBInt bb -> do
    int[] blocks -> do
    16:19:void <init>() -> <init>
    27:29:void addKey(int) -> do
    39:39:int getMinX() -> do
    44:44:int getMinZ() -> if
    49:49:int getMaxX() -> for
    54:54:int getMaxZ() -> int
    63:69:nidefawl.qubes.nbt.Tag$Compound save() -> do
    73:80:void load(nidefawl.qubes.nbt.Tag$Compound) -> do
    83:90:byte[] intToByteArray(int[],byte[]) -> do
    94:102:int[] byteToIntArray(byte[],int[]) -> do
    110:110:java.util.Iterator iterator() -> do
    113:122:void setBlocks(long[]) -> do
    125:127:boolean has(int,int,int) -> do
nidefawl.qubes.world.structure.StructureBlockIterator -> IjL1jIjIL11LIj1L:
    nidefawl.qubes.world.structure.Structure tree -> do
    int pos -> do
    int[] blocks -> do
    nidefawl.qubes.vec.BlockPos bPos -> do
    nidefawl.qubes.vec.AABBInt bb -> do
    15:39:void <init>(nidefawl.qubes.world.structure.Structure,nidefawl.qubes.vec.AABBInt) -> <init>
    43:43:boolean hasNext() -> hasNext
    48:52:nidefawl.qubes.vec.BlockPos next() -> do
    57:57:void remove() -> remove
    10:10:java.lang.Object next() -> next
nidefawl.qubes.world.structure.StructureFactory -> ll1LllJi1LJijIL1:
    3:3:void <init>() -> <init>
    java.lang.Object newInstance() -> do
nidefawl.qubes.world.structure.StructureMap -> iJ1LiJ1LJijIiJ:
    nidefawl.qubes.world.structure.StructureFactory fac -> do
    nidefawl.qubes.util.RegionMap structures -> do
    16:19:void <init>(nidefawl.qubes.world.structure.StructureFactory) -> <init>
    22:30:void load(nidefawl.qubes.nbt.Tag$Compound) -> do
    33:43:nidefawl.qubes.nbt.Tag$Compound save() -> do
    54:55:boolean add(nidefawl.qubes.world.structure.Structure) -> do
    83:83:java.util.Collection getRegions(int,int,int) -> do
    95:96:void clear() -> do
nidefawl.qubes.world.structure.mine.Mine -> IjiJllllIjjIL1ll:
    int dir -> do
    nidefawl.qubes.vec.BlockPos pos -> do
    14:15:void <init>() -> <init>
    22:25:nidefawl.qubes.nbt.Tag$Compound save() -> do
    30:33:void load(nidefawl.qubes.nbt.Tag$Compound) -> do
    36:50:void regen(nidefawl.qubes.world.WorldServer) -> do
nidefawl.qubes.world.structure.tree.Tree -> iJJi1LiJIjIjiJll:
    nidefawl.qubes.vec.AABBInt trunkBB -> if
    20:22:void <init>() -> <init>
    24:27:nidefawl.qubes.nbt.Tag$Compound save() -> do
    31:34:void load(nidefawl.qubes.nbt.Tag$Compound) -> do
    37:37:java.util.Iterator trunkIterator() -> if
    41:108:void onMine(nidefawl.qubes.world.BlockPlacer,nidefawl.qubes.block.Block,nidefawl.qubes.world.World,nidefawl.qubes.vec.BlockPos,nidefawl.qubes.entity.PlayerServer,nidefawl.qubes.item.ItemStack) -> do
nidefawl.qubes.worldgen.TerrainGen -> JiIjllJiIjllIjIj:
    17:28:void init() -> do
nidefawl.qubes.worldgen.WorldGenInit -> lliJjI1L1LL1iJjI:
    nidefawl.qubes.worldgen.terrain.ITerrainGen generator -> do
    nidefawl.qubes.world.biomes.IBiomeManager biomeManager -> do
    nidefawl.qubes.worldgen.populator.IChunkPopulator populator -> do
    7:7:void <init>() -> <init>
    14:14:nidefawl.qubes.worldgen.terrain.ITerrainGen getGenerator() -> do
    18:18:nidefawl.qubes.world.biomes.IBiomeManager getBiomeManager() -> do
    22:22:nidefawl.qubes.worldgen.populator.IChunkPopulator getPopulator() -> do
nidefawl.qubes.worldgen.populator.ChunkPopulator -> L1iJIjll1L1L1L:
    nidefawl.qubes.world.WorldServer world -> do
    nidefawl.qubes.worldgen.populator.TreeGen1 tree -> do
    31:35:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    40:260:void populate(nidefawl.qubes.chunk.Chunk) -> do
    266:266:boolean isSoil(int) -> do
nidefawl.qubes.worldgen.populator.EmptyChunkPopulator -> iJ1LL1jIL1L11LL1:
    17:19:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    24:24:void populate(nidefawl.qubes.chunk.Chunk) -> do
nidefawl.qubes.worldgen.populator.IChunkPopulator -> llIjJiIj1LiJJiIj:
    void populate(nidefawl.qubes.chunk.Chunk) -> do
nidefawl.qubes.worldgen.populator.TreeGen1 -> IjjIL1iJjIIjJill:
    int log -> do
    int leaves -> if
    23:26:void <init>() -> <init>
nidefawl.qubes.worldgen.populator.TreeGeneratorLSystem -> llJiiJiJL11L1Lll:
    float MAX_ANGLE_OFFSET -> do
    int maxDepth -> do
    float angle -> if
    int leaves -> if
    int log -> for
    java.lang.String initialAxiom -> do
    java.util.Map ruleSet -> for
    java.util.Map blocks -> do
    java.util.Map trunk -> if
    int variation -> int
    nidefawl.qubes.block.Block vines -> do
    nidefawl.qubes.vec.Matrix4f tempRotation -> do
    nidefawl.qubes.vec.Vector3f dir -> do
    nidefawl.qubes.vec.Vector3f dir2 -> if
    36:37:void setVines(nidefawl.qubes.block.Block) -> do
    45:147:void <init>(java.lang.String,java.util.Map,int,float) -> <init>
    61:62:nidefawl.qubes.worldgen.populator.TreeGeneratorLSystem setLeafType(int) -> do
    70:71:nidefawl.qubes.worldgen.populator.TreeGeneratorLSystem setBarkType(int) -> if
    78:89:boolean generate(nidefawl.qubes.world.IBlockWorld,int,int,int,java.util.Random) -> do
    92:144:void postGenerate(nidefawl.qubes.world.IBlockWorld,int,int,int,java.util.Random) -> do
    152:367:void recurse(nidefawl.qubes.world.IBlockWorld,java.util.Random,int,int,int,float,nidefawl.qubes.util.CharSequenceIterator,nidefawl.qubes.vec.Vector3f,nidefawl.qubes.vec.Matrix4f,int,int) -> do
    370:371:void safelySetBlock(nidefawl.qubes.world.IBlockWorld,int,int,int,int) -> do
    373:382:void safelySetBlock(nidefawl.qubes.world.IBlockWorld,int,int,int,int,int,int) -> do
    385:440:nidefawl.qubes.world.structure.tree.Tree getTree() -> do
    22:22:void <clinit>() -> <clinit>
nidefawl.qubes.worldgen.populator.TreeGenerators -> jIlliJ1L1LIjjIll:
    20:93:nidefawl.qubes.worldgen.populator.TreeGeneratorLSystem get(int,java.util.Random) -> do
nidefawl.qubes.worldgen.populator.TreeRule -> llJijIiJjIiJjI1L:
    java.lang.String string -> do
    float weight -> do
    18:21:void <init>(java.lang.String,float) -> <init>
    27:27:java.lang.String getRule() -> do
    34:34:float getWeight() -> do
nidefawl.qubes.worldgen.structure.GenTask -> IjJiiJJiiJiJIjJi:
    nidefawl.qubes.worldgen.structure.StructureGen generator -> do
    int chunkX -> do
    int chunkZ -> if
    nidefawl.qubes.world.WorldServer world -> do
    java.util.List neededChunks -> do
    boolean prepared -> do
    17:23:void <init>(nidefawl.qubes.world.World,int,int,nidefawl.qubes.worldgen.structure.StructureGen) -> <init>
    27:51:boolean run() -> do
nidefawl.qubes.worldgen.structure.MineGen -> JijIL11L1LJi1LJi:
    nidefawl.qubes.vec.BlockPos pos -> do
    int[] lvl -> do
    int height -> do
    int max -> if
    int min -> for
    int dir -> int
    java.util.Random rand -> do
    int chunkX -> new
    int chunkZ -> try
    java.util.Set blocks -> do
    nidefawl.qubes.vec.BlockPos minePos -> if
    32:37:void <init>() -> <init>
    42:49:java.util.List prepare(nidefawl.qubes.world.WorldServer,int,int) -> do
    53:109:int generate(nidefawl.qubes.world.WorldServer) -> do
    113:183:boolean canBuild(nidefawl.qubes.world.World) -> do
    188:316:int gen(nidefawl.qubes.world.WorldServer) -> if
    320:355:nidefawl.qubes.world.structure.mine.Mine getMine() -> do
nidefawl.qubes.worldgen.structure.StructureGen -> L1jIjIiJiJIj1LJi:
    8:8:void <init>() -> <init>
    java.util.List prepare(nidefawl.qubes.world.WorldServer,int,int) -> do
    int generate(nidefawl.qubes.world.WorldServer) -> do
nidefawl.qubes.worldgen.terrain.ITerrainGen -> L1jIjIiJiJjI1LjI:
    nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.TerrainGenBlockTest -> IjJiL1IjjIJiJiJi:
    nidefawl.qubes.world.WorldServer world -> do
    long seed -> do
    18:21:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    25:33:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    37:58:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    62:66:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.TerrainGenFlatSand128 -> L1iJllJiIjjIllL1:
    nidefawl.qubes.world.WorldServer world -> do
    16:18:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    22:27:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    31:38:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    42:46:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.TerrainGenMines -> Ji1L1LllllJijI1L:
    nidefawl.qubes.world.WorldServer world -> do
    long seed -> do
    20:23:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    27:35:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    39:40:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    45:49:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.TerrainGenQTest -> llllllIjiJiJiJL1:
    nidefawl.qubes.world.WorldServer world -> do
    long seed -> do
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    31:42:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    46:59:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    63:262:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    265:297:double[] generateNoise(int,int) -> do
    362:362:double clamp10(double) -> do
    384:388:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.TerrainGeneratorIsland -> JiL1llL11LJiL1ll:
    nidefawl.qubes.world.WorldServer world -> do
    nidefawl.qubes.noise.TerrainNoiseMap2D test2d -> do
    21:23:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    27:38:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    68:68:double clamp10(double) -> do
    88:183:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[],byte[]) -> do
    187:191:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.TerrainGeneratorOther -> JilljIIjllL1JijI:
    nidefawl.qubes.world.WorldServer world -> do
    long seed -> do
    nidefawl.qubes.noise.TerrainNoise noise3 -> do
    nidefawl.qubes.noise.TerrainNoise noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseCustom1 noise2 -> do
    nidefawl.qubes.noise.TerrainNoise noise4 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.RiverNoise2D r2D -> do
    nidefawl.qubes.noise.RiverNoise2D r2D2 -> if
    nidefawl.qubes.noise.TerrainNoiseCustom1 noise5 -> if
    32:59:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    63:71:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    155:263:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[]) -> do
    265:278:double func2(double,double,double) -> do
    291:291:double clamp10(double) -> do
    313:317:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen -> lljIllllJi1LllIj:
    12:12:void <init>() -> <init>
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData -> llL11LjIjIJillll:
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGen this$0 -> do
    13:13:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGen) -> <init>
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen4 -> L1Ji1LiJiJjIJiL1:
    nidefawl.qubes.noise.TerrainNoiseScale noise3 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.RiverNoise2D r2D -> do
    nidefawl.qubes.noise.RiverNoise2D r2D2 -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> int
    nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain main -> do
    45:85:void <init>(nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain) -> <init>
    89:96:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    100:181:double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen4$NoiseData -> llL1jIIjllJi1L1L:
    nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult r2Dn -> do
    nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult r2Dn2 -> if
    double[] dNoise2_ -> do
    double[] dnoise5_ -> if
    double[] dnoise_ -> for
    double[] dnoise3_ -> int
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGen4 this$0 -> do
    26:26:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGen4) -> <init>
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen5 -> IjlljIL11LiJIjll:
    nidefawl.qubes.noise.TerrainNoiseScale noise3 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> int
    nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain main -> do
    nidefawl.qubes.noise.TerrainNoiseMap2D test2d -> do
    40:79:void <init>(nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain) -> <init>
    83:104:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    108:193:double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen5$NoiseData -> L1lliJL1ll1LJiL1:
    double[] dNoise2_ -> do
    double[] dnoise5_ -> if
    double[] dnoise_ -> for
    double[] dnoise3_ -> int
    nidefawl.qubes.noise.TerrainNoiseMap2DResult dnoise2da -> do
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGen5 this$0 -> do
    19:19:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGen5) -> <init>
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen6 -> JillJiJiIjiJJiJi:
    nidefawl.qubes.noise.TerrainNoiseScale noise3 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> int
    nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain main -> do
    nidefawl.qubes.noise.TerrainNoiseMap2D test2d -> do
    40:79:void <init>(nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain) -> <init>
    83:104:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    108:193:double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen6$NoiseData -> Ij1L1LIjiJL1llL1:
    double[] dNoise2_ -> do
    double[] dnoise5_ -> if
    double[] dnoise_ -> for
    double[] dnoise3_ -> int
    nidefawl.qubes.noise.TerrainNoiseMap2DResult dnoise2da -> do
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGen6 this$0 -> do
    19:19:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGen6) -> <init>
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen7 -> llIj1LiJ1L1LJiL1:
    nidefawl.qubes.noise.TerrainNoiseScale noise3 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> int
    nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain main -> do
    nidefawl.qubes.noise.TerrainNoiseMap2D test2d -> do
    40:78:void <init>(nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain) -> <init>
    81:108:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    112:200:double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGen7$NoiseData -> ll1L1LjIiJjIJiiJ:
    double[] dNoise2_ -> do
    double[] dnoise5_ -> if
    double[] dnoise_ -> for
    double[] dnoise3_ -> int
    nidefawl.qubes.noise.TerrainNoiseMap2DResult dnoise2da -> do
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGen7 this$0 -> do
    19:19:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGen7) -> <init>
nidefawl.qubes.worldgen.terrain.main.SubTerrainGenDesert -> llJijIllL1lliJJi:
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> do
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> if
    nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain main -> do
    39:58:void <init>(nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain) -> <init>
    61:73:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    77:122:double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGenDesert$NoiseData -> JiL11LiJIjiJjI1L:
    double[] dNoise -> do
    double[] dNoise2 -> if
    double[] dNoise2_ -> for
    double[] dnoise5_ -> int
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGenDesert this$0 -> do
    26:26:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGenDesert) -> <init>
nidefawl.qubes.worldgen.terrain.main.SubTerrainGenFlattish -> IjIj1LIjIjL1Ij:
    nidefawl.qubes.noise.TerrainNoiseScale noise3 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.RiverNoise2D r2D -> do
    nidefawl.qubes.noise.RiverNoise2D r2D2 -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> int
    nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorLight main -> do
    43:82:void <init>(nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorLight) -> <init>
    96:120:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    124:235:double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGenFlattish$NoiseData -> IjlliJllJillJi1L:
    nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult r2Dn -> do
    nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult r2Dn2 -> if
    double[] dNoise2_ -> do
    double[] dnoise5_ -> if
    double[] dnoise_ -> for
    double[] dnoise3_ -> int
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGenFlattish this$0 -> do
    24:24:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGenFlattish) -> <init>
nidefawl.qubes.worldgen.terrain.main.SubTerrainGenMeadow -> IjiJL1ll1LjIL11L:
    nidefawl.qubes.noise.TerrainNoiseScale noise3 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.RiverNoise2D r2D -> do
    nidefawl.qubes.noise.RiverNoise2D r2D2 -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> int
    nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain main -> do
    43:82:void <init>(nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain) -> <init>
    96:120:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    124:235:double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGenMeadow$NoiseData -> JiJiJilljIJiL1Ji:
    nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult r2Dn -> do
    nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult r2Dn2 -> if
    double[] dNoise2_ -> do
    double[] dnoise5_ -> if
    double[] dnoise_ -> for
    double[] dnoise3_ -> int
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGenMeadow this$0 -> do
    24:24:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGenMeadow) -> <init>
nidefawl.qubes.worldgen.terrain.main.SubTerrainGenSnowHills -> jIjIllL1Ij1LiJ:
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> do
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> if
    nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain main -> do
    39:58:void <init>(nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain) -> <init>
    61:73:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData prepare(int,int,nidefawl.qubes.world.biomes.HexBiome) -> do
    77:122:double generate(int,int,int,int,int,int,nidefawl.qubes.world.biomes.HexBiome,nidefawl.qubes.worldgen.terrain.main.SubTerrainGen$SubTerrainData,double[],double[]) -> do
nidefawl.qubes.worldgen.terrain.main.SubTerrainGenSnowHills$NoiseData -> L1iJIj1LL1Ji1LJi:
    double[] dNoise -> do
    double[] dNoise2 -> if
    double[] dNoise2_ -> for
    double[] dnoise5_ -> int
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGenSnowHills this$0 -> do
    26:26:void <init>(nidefawl.qubes.worldgen.terrain.main.SubTerrainGenSnowHills) -> <init>
nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorLight -> jIJiL1ll1LiJ1LJi:
    nidefawl.qubes.world.WorldServer world -> do
    long seed -> do
    nidefawl.qubes.world.biomes.HexBiomesServer biomes -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j2 -> if
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j4 -> for
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j5 -> int
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j6 -> new
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j7 -> try
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGenFlattish gen -> do
    41:52:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    56:76:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    79:79:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen getTerrainGenInstance(nidefawl.qubes.world.biomes.HexBiome) -> do
    83:311:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[],byte[],nidefawl.qubes.world.biomes.HexBiome[],java.util.ArrayList) -> do
    316:338:int getStone(nidefawl.qubes.world.WorldServer,int,int,int,nidefawl.qubes.world.biomes.HexBiome,java.util.Random) -> do
    359:364:double mix(double,double,double) -> do
    368:368:double clamp10(double) -> do
    390:394:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorMain -> L1lljIIjjIL1L1jI:
    nidefawl.qubes.world.WorldServer world -> do
    long seed -> do
    nidefawl.qubes.world.biomes.HexBiomesServer biomes -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j2 -> if
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j4 -> for
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j5 -> int
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j6 -> new
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j7 -> try
    nidefawl.qubes.worldgen.terrain.main.SubTerrainGen[] gens -> do
    40:72:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    76:96:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    99:123:nidefawl.qubes.worldgen.terrain.main.SubTerrainGen getTerrainGenInstance(nidefawl.qubes.world.biomes.HexBiome) -> do
    127:344:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[],byte[],nidefawl.qubes.world.biomes.HexBiome[],java.util.ArrayList) -> do
    347:360:double func2(double,double,double) -> do
    364:369:double mix(double,double,double) -> if
    373:373:double clamp10(double) -> do
    394:398:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorTest2 -> Ij1LjIL1L1jIIj1L:
    nidefawl.qubes.world.WorldServer world -> do
    long seed -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j -> do
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j2 -> if
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j4 -> for
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j5 -> int
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j6 -> new
    nidefawl.qubes.noise.opennoise.OpenSimplexNoise j7 -> try
    nidefawl.qubes.noise.TerrainNoiseScale noise3 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise -> if
    nidefawl.qubes.noise.TerrainNoise2D noiseM2 -> do
    nidefawl.qubes.noise.TerrainNoiseScale noise2 -> for
    nidefawl.qubes.noise.TerrainNoise2D noise2D -> if
    nidefawl.qubes.noise.RiverNoise2D r2D -> do
    nidefawl.qubes.noise.RiverNoise2D r2D2 -> if
    nidefawl.qubes.noise.TerrainNoiseScale noise5 -> int
    48:94:void <init>(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> <init>
    98:104:nidefawl.qubes.chunk.Chunk generateChunk(int,int) -> do
    118:407:void generateTerrain(nidefawl.qubes.chunk.Chunk,short[],byte[]) -> do
    413:426:double func2(double,double,double) -> do
    430:435:double mix(double,double,double) -> if
    439:439:double clamp10(double) -> do
    461:465:nidefawl.qubes.worldgen.WorldGenInit getWorldGen(nidefawl.qubes.world.WorldServer,long,nidefawl.qubes.world.WorldSettings) -> do
nidefawl.qubes.worldgen.terrain.main.TerrainGeneratorTest2$NoiseData -> IjlliJiJ1LIjjIL1:
    nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult r2Dn -> do
    nidefawl.qubes.noise.RiverNoise2D$RiverNoiseResult r2Dn2 -> if
    double[] dNoise2_ -> do
    double[] dnoise5_ -> if
    double[] dnoise_ -> for
    double[] dnoise3_ -> int
    106:106:void <init>() -> <init>
test.game.EmptyGame -> test.game.EmptyGame:
    8:11:void <init>() -> <init>
    14:15:void main(java.lang.String[]) -> main
    20:21:void onStatsUpdated() -> onStatsUpdated
    27:27:void onTextInput(long,int) -> onTextInput
    33:33:void onKeyPress(long,int,int,int,int) -> onKeyPress
    39:39:void render(float) -> render
    45:45:void preRenderUpdate(float) -> preRenderUpdate
    51:51:void postRenderUpdate(float) -> postRenderUpdate
    57:57:void setRenderResolution(int,int) -> setRenderResolution
    63:63:void tick() -> tick
    68:69:void initGame() -> initGame
    75:75:void lateInitGame() -> lateInitGame
    85:85:void onWheelScroll(long,double,double) -> onWheelScroll
test.game.FrameBufferChainTest -> test.game.FrameBufferChainTest:
    nidefawl.qubes.util.SimpleResourceManager resMgr -> resMgr
    int NUM_FRAMEBUFFERS -> NUM_FRAMEBUFFERS
    int ticks -> ticks
    nidefawl.qubes.shader.Shader shader -> shader
    nidefawl.qubes.shader.Shader shader2 -> shader2
    nidefawl.qubes.gl.FrameBuffer[] buffers -> buffers
    18:33:void <init>() -> <init>
    24:27:void main(java.lang.String[]) -> main
    38:51:void onStatsUpdated() -> onStatsUpdated
    60:75:void reloadShaders() -> reloadShaders
    81:81:void onTextInput(long,int) -> onTextInput
    87:87:void onKeyPress(long,int,int,int,int) -> onKeyPress
    91:119:void render(float) -> render
    123:124:void preRenderUpdate(float) -> preRenderUpdate
    130:130:void postRenderUpdate(float) -> postRenderUpdate
    134:145:void setRenderResolution(int,int) -> setRenderResolution
    151:151:void tick() -> tick
    155:160:void initGame() -> initGame
    164:164:void lateInitGame() -> lateInitGame
    174:174:void onWheelScroll(long,double,double) -> onWheelScroll
test.game.FrustumTest -> test.game.FrustumTest:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    int tick -> tick
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    boolean startup -> startup
    nidefawl.qubes.shader.Shader modelShader -> modelShader
    int action -> action
    boolean once -> once
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    boolean hadContext -> hadContext
    nidefawl.qubes.gl.VertexBuffer vertexBuf -> vertexBuf
    nidefawl.qubes.gl.GLTriBuffer buf -> buf
    23:163:void <init>() -> <init>
    30:33:void main(java.lang.String[]) -> main
    47:65:void initShaders() -> initShaders
    70:84:void onStatsUpdated() -> onStatsUpdated
    88:88:void onTextInput(long,int) -> onTextInput
    92:92:void onKeyPress(long,int,int,int,int) -> onKeyPress
    98:143:void render(float) -> render
    148:157:void preRenderUpdate(float) -> preRenderUpdate
    161:161:void postRenderUpdate(float) -> postRenderUpdate
    169:188:void setRenderResolution(int,int) -> setRenderResolution
    192:193:void tick() -> tick
    197:202:void initGame() -> initGame
    205:209:void redraw() -> redraw
    213:219:void lateInitGame() -> lateInitGame
    224:224:void onWheelScroll(long,double,double) -> onWheelScroll
    37:38:void <clinit>() -> <clinit>
test.game.GuiModelViewer -> test.game.GuiModelViewer:
    int nextID -> nextID
    nidefawl.qubes.gui.controls.Button back -> back
    java.util.List list -> list
    java.util.List listDyn -> listDyn
    test.game.GuiModelViewer$Setting testSetting -> testSetting
    test.game.ModelViewer viewer -> viewer
    nidefawl.qubes.gui.controls.CheckBox checkBoxRenderMode -> checkBoxRenderMode
    nidefawl.qubes.gui.controls.CheckBox checkboxWireframe -> checkboxWireframe
    nidefawl.qubes.gui.controls.CheckBox checkboxNormals -> checkboxNormals
    nidefawl.qubes.gui.controls.CheckBox checkboxBones -> checkboxBones
    116:128:void <init>() -> <init>
    131:146:void setModel(nidefawl.qubes.models.EntityModel,nidefawl.qubes.models.render.QModelRender,nidefawl.qubes.models.qmodel.QModelProperties) -> setModel
    150:182:void initGui(boolean) -> initGui
    185:227:int layout() -> layout
    231:235:void render(float,double,double) -> render
    238:238:java.lang.String getTitle() -> getTitle
    242:299:boolean onGuiClicked(nidefawl.qubes.gui.AbstractUI) -> onGuiClicked
    18:18:test.game.ModelViewer access$000(test.game.GuiModelViewer) -> access$000
    19:19:void <clinit>() -> <clinit>
test.game.GuiModelViewer$1 -> test.game.GuiModelViewer$1:
    java.util.List val$l -> val$l
    test.game.GuiModelViewer this$0 -> this$0
    162:162:void <init>(test.game.GuiModelViewer,nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[],java.util.List) -> <init>
    164:169:void callback(int) -> callback
test.game.GuiModelViewer$2 -> test.game.GuiModelViewer$2:
    test.game.GuiModelViewer$Setting val$s -> val$s
    test.game.GuiModelViewer this$0 -> this$0
    282:282:void <init>(test.game.GuiModelViewer,test.game.GuiModelViewer$Setting) -> <init>
    286:291:void call(nidefawl.qubes.gui.controls.ComboBox$ComboBoxList,int) -> call
test.game.GuiModelViewer$ModelActionList -> test.game.GuiModelViewer$ModelActionList:
    nidefawl.qubes.models.EntityModel entityModel -> entityModel
    int idx -> idx
    81:98:void <init>(nidefawl.qubes.gui.Gui,nidefawl.qubes.models.EntityModel,int) -> <init>
    101:112:void callback(int) -> callback
test.game.GuiModelViewer$ModelSettingControl -> test.game.GuiModelViewer$ModelSettingControl:
    nidefawl.qubes.models.ModelOption option -> option
    51:61:void <init>(nidefawl.qubes.gui.Gui,nidefawl.qubes.models.ModelOption) -> <init>
    64:69:void callback(int) -> callback
test.game.GuiModelViewer$Setting -> test.game.GuiModelViewer$Setting:
    java.lang.Object[] vals -> vals
    nidefawl.qubes.gui.controls.ComboBox box -> box
    nidefawl.qubes.gui.controls.Button button1 -> button1
    nidefawl.qubes.gui.controls.Button button2 -> button2
    int curVal -> curVal
    22:29:void <init>() -> <init>
    22:37:void <init>(nidefawl.qubes.gui.Gui,java.lang.String,java.lang.Object,java.lang.Object[]) -> <init>
    40:40:void callback(int) -> callback
test.game.Hex -> test.game.Hex:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.PositionMouseOver mouseOverRight -> mouseOverRight
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    boolean ortho -> ortho
    int tick -> tick
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    boolean startup -> startup
    double halfLen -> halfLen
    nidefawl.qubes.shader.Shader modelShader -> modelShader
    int action -> action
    boolean drag -> drag
    java.util.Stack stack -> stack
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    boolean once -> once
    nidefawl.qubes.world.biomes.HexBiomesServer biomes -> biomes
    boolean update -> update
    float mapOffsetX -> mapOffsetX
    float mapOffsetZ -> mapOffsetZ
    float scale2 -> scale2
    float inOffsetX -> inOffsetX
    float inOffsetZ -> inOffsetZ
    float scaleWidth -> scaleWidth
    float scaleHeight -> scaleHeight
    float floatzpos1 -> floatzpos1
    int zPos1 -> zPos1
    int zPos -> zPos
    float rOffsetZ -> rOffsetZ
    float floatxpos1 -> floatxpos1
    int xPos1 -> xPos1
    int xPos -> xPos
    float rOffsetX -> rOffsetX
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    nidefawl.qubes.vec.Vector3f hit -> hit
    float left -> left
    float top -> top
    float rWidth -> rWidth
    float rHeight -> rHeight
    boolean hadContext -> hadContext
    int tex -> tex
    double zoom -> zoom
    boolean diddrag -> diddrag
    32:582:void <init>() -> <init>
    41:44:void main(java.lang.String[]) -> main
    57:75:void initShaders() -> initShaders
    80:92:void onStatsUpdated() -> onStatsUpdated
    96:96:void onTextInput(long,int) -> onTextInput
    100:125:void onKeyPress(long,int,int,int,int) -> onKeyPress
    130:166:void onMouseClick(long,int,int,int) -> onMouseClick
    192:210:void updateOffset() -> updateOffset
    214:341:void render(float) -> render
    343:345:double mousePosX() -> mousePosX
    348:350:double mousePosY() -> mousePosY
    353:456:void render2(float) -> render2
    465:499:int getBlockColor(int,int) -> getBlockColor
    511:574:void preRenderUpdate(float) -> preRenderUpdate
    578:578:void postRenderUpdate(float) -> postRenderUpdate
    586:605:void setRenderResolution(int,int) -> setRenderResolution
    609:610:void tick() -> tick
    614:619:void initGame() -> initGame
    623:637:void lateInitGame() -> lateInitGame
    643:653:void renderQuad() -> renderQuad
    657:667:void input(float) -> input
    669:671:double mousePosX2() -> mousePosX2
    674:676:double mousePosY2() -> mousePosY2
    680:707:void onWheelScroll(long,double,double) -> onWheelScroll
    48:51:void <clinit>() -> <clinit>
test.game.LinkedList -> test.game.LinkedList:
    int size -> size
    test.game.LinkedList$Node first -> first
    test.game.LinkedList$Node last -> last
    long serialVersionUID -> serialVersionUID
    88:108:void <init>() -> <init>
    119:121:void <init>(java.util.Collection) -> <init>
    127:136:void linkFirst(java.lang.Object) -> linkFirst
    142:151:void linkLast(java.lang.Object) -> linkLast
    158:167:void linkBefore(java.lang.Object,test.game.LinkedList$Node) -> linkBefore
    174:185:java.lang.Object unlinkFirst(test.game.LinkedList$Node) -> unlinkFirst
    193:204:java.lang.Object unlinkLast(test.game.LinkedList$Node) -> unlinkLast
    212:233:java.lang.Object unlink(test.game.LinkedList$Node) -> unlink
    243:246:java.lang.Object getFirst() -> getFirst
    256:259:java.lang.Object getLast() -> getLast
    269:272:java.lang.Object removeFirst() -> removeFirst
    282:285:java.lang.Object removeLast() -> removeLast
    294:295:void addFirst(java.lang.Object) -> addFirst
    305:306:void addLast(java.lang.Object) -> addLast
    318:318:boolean contains(java.lang.Object) -> contains
    327:327:int size() -> size
    339:340:boolean add(java.lang.Object) -> add
    357:372:boolean remove(java.lang.Object) -> remove
    388:388:boolean addAll(java.util.Collection) -> addAll
    407:442:boolean addAll(int,java.util.Collection) -> addAll
    454:464:void clear() -> clear
    477:478:java.lang.Object get(int) -> get
    491:495:java.lang.Object set(int,java.lang.Object) -> set
    508:514:void add(int,java.lang.Object) -> add
    526:527:java.lang.Object remove(int) -> remove
    534:534:boolean isElementIndex(int) -> isElementIndex
    542:542:boolean isPositionIndex(int) -> isPositionIndex
    551:551:java.lang.String outOfBoundsMsg(int) -> outOfBoundsMsg
    555:557:void checkElementIndex(int) -> checkElementIndex
    560:562:void checkPositionIndex(int) -> checkPositionIndex
    570:579:test.game.LinkedList$Node node(int) -> node
    597:611:int indexOf(java.lang.Object) -> indexOf
    626:640:int lastIndexOf(java.lang.Object) -> lastIndexOf
    652:653:java.lang.Object peek() -> peek
    664:664:java.lang.Object element() -> element
    674:675:java.lang.Object poll() -> poll
    686:686:java.lang.Object remove() -> remove
    697:697:boolean offer(java.lang.Object) -> offer
    709:710:boolean offerFirst(java.lang.Object) -> offerFirst
    721:722:boolean offerLast(java.lang.Object) -> offerLast
    734:735:java.lang.Object peekFirst() -> peekFirst
    747:748:java.lang.Object peekLast() -> peekLast
    760:761:java.lang.Object pollFirst() -> pollFirst
    773:774:java.lang.Object pollLast() -> pollLast
    787:788:void push(java.lang.Object) -> push
    802:802:java.lang.Object pop() -> pop
    815:815:boolean removeFirstOccurrence(java.lang.Object) -> removeFirstOccurrence
    828:843:boolean removeLastOccurrence(java.lang.Object) -> removeLastOccurrence
    868:869:java.util.ListIterator listIterator(int) -> listIterator
    987:987:java.util.Iterator descendingIterator() -> descendingIterator
    1009:1011:test.game.LinkedList superClone() -> superClone
    1022:1033:java.lang.Object clone() -> clone
    1051:1055:java.lang.Object[] toArray() -> toArray
    1098:1109:java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    1125:1133:void writeObject(java.io.ObjectOutputStream) -> writeObject
    1143:1151:void readObject(java.io.ObjectInputStream) -> readObject
    1171:1171:java.util.Spliterator spliterator() -> spliterator
    84:84:int access$000(test.game.LinkedList) -> access$000
    84:84:int access$100(test.game.LinkedList) -> access$100
    84:84:int access$200(test.game.LinkedList) -> access$200
    84:84:int access$400(test.game.LinkedList) -> access$400
    84:84:int access$500(test.game.LinkedList) -> access$500
    84:84:int access$600(test.game.LinkedList) -> access$600
test.game.LinkedList$1 -> test.game.LinkedList$1:
test.game.LinkedList$DescendingIterator -> test.game.LinkedList$DescendingIterator:
    test.game.LinkedList$ListItr itr -> itr
    test.game.LinkedList this$0 -> this$0
    993:994:void <init>(test.game.LinkedList) -> <init>
    996:996:boolean hasNext() -> hasNext
    999:999:java.lang.Object next() -> next
    1002:1003:void remove() -> remove
    993:993:void <init>(test.game.LinkedList,test.game.LinkedList$1) -> <init>
test.game.LinkedList$LLSpliterator -> test.game.LinkedList$LLSpliterator:
    int BATCH_UNIT -> BATCH_UNIT
    int MAX_BATCH -> MAX_BATCH
    test.game.LinkedList list -> list
    test.game.LinkedList$Node current -> current
    int est -> est
    int expectedModCount -> expectedModCount
    int batch -> batch
    1184:1188:void <init>(test.game.LinkedList,int,int) -> <init>
    1193:1202:int getEst() -> getEst
    1205:1205:long estimateSize() -> estimateSize
    1209:1224:java.util.Spliterator trySplit() -> trySplit
    1229:1241:void forEachRemaining(java.util.function.Consumer) -> forEachRemaining
    1245:1255:boolean tryAdvance(java.util.function.Consumer) -> tryAdvance
    1259:1259:int characteristics() -> characteristics
test.game.LinkedList$ListItr -> test.game.LinkedList$ListItr:
    test.game.LinkedList$Node lastReturned -> lastReturned
    test.game.LinkedList$Node next -> next
    int nextIndex -> nextIndex
    int expectedModCount -> expectedModCount
    test.game.LinkedList this$0 -> this$0
    876:882:void <init>(test.game.LinkedList,int) -> <init>
    885:885:boolean hasNext() -> hasNext
    889:896:java.lang.Object next() -> next
    900:900:boolean hasPrevious() -> hasPrevious
    904:910:java.lang.Object previous() -> previous
    914:914:int nextIndex() -> nextIndex
    918:918:int previousIndex() -> previousIndex
    922:934:void remove() -> remove
    937:941:void set(java.lang.Object) -> set
    944:952:void add(java.lang.Object) -> add
    955:963:void forEachRemaining(java.util.function.Consumer) -> forEachRemaining
    966:968:void checkForComodification() -> checkForComodification
test.game.LinkedList$Node -> test.game.LinkedList$Node:
    java.lang.Object item -> item
    test.game.LinkedList$Node next -> next
    test.game.LinkedList$Node prev -> prev
    976:980:void <init>(test.game.LinkedList$Node,java.lang.Object,test.game.LinkedList$Node) -> <init>
test.game.ModelAdjuster -> test.game.ModelAdjuster:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    boolean wasGrabbed -> wasGrabbed
    test.game.ModelAdjuster instance -> instance
    int tick -> tick
    boolean startup -> startup
    boolean once -> once
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    37:73:void <init>() -> <init>
    48:52:void main(java.lang.String[]) -> main
    60:69:void onStatsUpdated() -> onStatsUpdated
    77:77:void onTextInput(long,int) -> onTextInput
    81:85:void onKeyPress(long,int,int,int,int) -> onKeyPress
    89:124:void render(float) -> render
    127:153:void showGUI(nidefawl.qubes.gui.Gui) -> showGUI
    157:165:void preRenderUpdate(float) -> preRenderUpdate
    169:169:void postRenderUpdate(float) -> postRenderUpdate
    174:201:void setRenderResolution(int,int) -> setRenderResolution
    205:211:void tick() -> tick
    215:223:void initGame() -> initGame
    227:234:void lateInitGame() -> lateInitGame
    239:239:void onWheelScroll(long,double,double) -> onWheelScroll
test.game.ModelViewer -> test.game.ModelViewer:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer buf -> buf
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.TesselatorState tessState -> tessState
    nidefawl.qubes.shader.Shader shaderModelSingle -> shaderModelSingle
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    int action -> action
    nidefawl.qubes.gui.Gui gui -> gui
    boolean wasGrabbed -> wasGrabbed
    test.game.ModelViewer instance -> instance
    int tick -> tick
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    boolean startup -> startup
    boolean showNormals -> showNormals
    boolean showBones -> showBones
    boolean showWireframe -> showWireframe
    boolean renderBatchedMode -> renderBatchedMode
    nidefawl.qubes.models.render.QModelBatchedRender renderBatched -> renderBatched
    nidefawl.qubes.models.render.QModelRender renderSingle -> renderSingle
    nidefawl.qubes.models.render.QModelRender curRender -> curRender
    nidefawl.qubes.models.EntityModel entityModel -> entityModel
    int modelidx -> modelidx
    boolean once -> once
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    boolean hadContext -> hadContext
    nidefawl.qubes.gl.FrameBuffer buf2 -> buf2
    nidefawl.qubes.models.qmodel.QModelProperties config -> config
    java.util.Stack stack -> stack
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    44:151:void <init>() -> <init>
    62:68:void main(java.lang.String[]) -> main
    82:124:void initShaders() -> initShaders
    127:136:void onStatsUpdated() -> onStatsUpdated
    155:165:void reloadModel() -> reloadModel
    169:169:void onTextInput(long,int) -> onTextInput
    173:186:void onKeyPress(long,int,int,int,int) -> onKeyPress
    189:198:void setModel(int) -> setModel
    202:352:void render(float) -> render
    355:381:void showGUI(nidefawl.qubes.gui.Gui) -> showGUI
    389:460:void renderBones(nidefawl.qubes.models.qmodel.ModelRigged,nidefawl.qubes.gl.BufferedMatrix) -> renderBones
    464:478:void preRenderUpdate(float) -> preRenderUpdate
    482:482:void postRenderUpdate(float) -> postRenderUpdate
    487:552:void setRenderResolution(int,int) -> setRenderResolution
    556:562:void tick() -> tick
    566:577:void initGame() -> initGame
    581:632:void lateInitGame() -> lateInitGame
    637:637:void onWheelScroll(long,double,double) -> onWheelScroll
    73:384:void <clinit>() -> <clinit>
test.game.ModelViewer$1 -> test.game.ModelViewer$1:
    test.game.ModelViewer this$0 -> this$0
    86:86:void <init>(test.game.ModelViewer) -> <init>
    89:92:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest -> test.game.ParticlePerformanceTest:
    int MAX_PARTICLES -> MAX_PARTICLES
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes -> ssbo_particle_cubes
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes_blockinfo -> ssbo_particle_cubes_blockinfo
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes_persist -> ssbo_particle_cubes_persist
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes_blockinfo_persist -> ssbo_particle_cubes_blockinfo_persist
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_structs -> ssbo_particle_structs
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_arrays -> ssbo_particle_arrays
    int MAX_SPRITES -> MAX_SPRITES
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    boolean startup -> startup
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.font.FontRenderer font -> font
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> fbDeferred
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.GLTriBuffer cubeFormat1 -> cubeFormat1
    nidefawl.qubes.gl.GLTriBuffer cubeFormat2 -> cubeFormat2
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    nidefawl.qubes.shader.Shader skybox -> skybox
    nidefawl.qubes.shader.Shader particleShaderStruct -> particleShaderStruct
    nidefawl.qubes.shader.Shader particleShaderSeperateBuffer -> particleShaderSeperateBuffer
    nidefawl.qubes.shader.Shader particleShaderSeperateBufferPersist -> particleShaderSeperateBufferPersist
    nidefawl.qubes.shader.Shader particleShaderArrays -> particleShaderArrays
    nidefawl.qubes.gl.TesselatorState tessState -> tessState
    boolean once -> once
    boolean hadContext -> hadContext
    int fireUpdate -> fireUpdate
    float lastUpdate -> lastUpdate
    boolean pause -> pause
    float pauseTime -> pauseTime
    int totalSpritesRendered -> totalSpritesRendered
    int storedSprites -> storedSprites
    int tick -> tick
    int renderMode -> renderMode
    int selFormat -> selFormat
    int selShader -> selShader
    java.lang.String error -> error
    java.lang.String stats -> stats
    int maxSprites -> maxSprites
    java.util.List particles -> particles
    java.util.Random r -> r
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    float SPEED -> SPEED
    216:271:void <init>() -> <init>
    224:227:void main(java.lang.String[]) -> main
    278:288:void initGame() -> initGame
    292:412:void initShaders() -> initShaders
    415:515:void lateInitGame() -> lateInitGame
    518:609:void onKeyPress(long,int,int,int,int) -> onKeyPress
    612:617:void onWindowResize(int,int) -> onWindowResize
    620:644:void setRenderResolution(int,int) -> setRenderResolution
    647:672:void onStatsUpdated() -> onStatsUpdated
    675:675:void onTextInput(long,int) -> onTextInput
    679:679:void onWheelScroll(long,double,double) -> onWheelScroll
    682:686:void postRenderUpdate(float) -> postRenderUpdate
    690:712:void preRenderUpdate(float) -> preRenderUpdate
    715:720:void preRenderUpdateParticles(float) -> preRenderUpdateParticles
    722:730:void redraw() -> redraw
    733:850:void render(float) -> render
    852:889:void renderParticles(float) -> renderParticles
    892:926:void spawnParticles(int) -> spawnParticles
    929:978:void storeParticles(float,int) -> storeParticles
    982:1008:void tick() -> tick
    1011:1018:void updateTickParticles() -> updateTickParticles
    38:38:float access$000() -> access$000
    41:273:void <clinit>() -> <clinit>
test.game.ParticlePerformanceTest$1 -> test.game.ParticlePerformanceTest$1:
    test.game.ParticlePerformanceTest this$0 -> this$0
    293:293:void <init>(test.game.ParticlePerformanceTest) -> <init>
    296:305:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest$2 -> test.game.ParticlePerformanceTest$2:
    test.game.ParticlePerformanceTest this$0 -> this$0
    308:308:void <init>(test.game.ParticlePerformanceTest) -> <init>
    311:320:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest$3 -> test.game.ParticlePerformanceTest$3:
    test.game.ParticlePerformanceTest this$0 -> this$0
    323:323:void <init>(test.game.ParticlePerformanceTest) -> <init>
    326:335:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest$4 -> test.game.ParticlePerformanceTest$4:
    test.game.ParticlePerformanceTest this$0 -> this$0
    338:338:void <init>(test.game.ParticlePerformanceTest) -> <init>
    341:350:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest$5 -> test.game.ParticlePerformanceTest$5:
    test.game.ParticlePerformanceTest this$0 -> this$0
    353:353:void <init>(test.game.ParticlePerformanceTest) -> <init>
    356:359:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest$6 -> test.game.ParticlePerformanceTest$6:
    nidefawl.qubes.texture.array.TextureArray val$arr -> val$arr
    test.game.ParticlePerformanceTest this$0 -> this$0
    429:429:void <init>(test.game.ParticlePerformanceTest,nidefawl.qubes.texture.array.TextureArray) -> <init>
    433:437:void pre() -> pre
    440:441:void post() -> post
    445:449:java.lang.Void call() -> call
    453:453:nidefawl.qubes.async.AsyncTask$TaskType getType() -> getType
    429:429:java.lang.Object call() -> call
test.game.ParticlePerformanceTest$Particle -> test.game.ParticlePerformanceTest$Particle:
    boolean dead -> dead
    int maxLive -> maxLive
    nidefawl.qubes.vec.Vector3f mot -> mot
    nidefawl.qubes.vec.Vector3f lastMot -> lastMot
    nidefawl.qubes.vec.Vector3f pos -> pos
    nidefawl.qubes.vec.Vector3f lastPos -> lastPos
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    nidefawl.qubes.vec.Vector3f renderRot -> renderRot
    nidefawl.qubes.vec.Vector3f rot -> rot
    nidefawl.qubes.vec.Vector3f lastRot -> lastRot
    nidefawl.qubes.vec.Vector3f rotspeed -> rotspeed
    nidefawl.qubes.vec.Vector2f texOffset -> texOffset
    float size -> size
    float initSize -> initSize
    float lastSize -> lastSize
    float renderSize -> renderSize
    int tick -> tick
    int tex -> tex
    int normalMap -> normalMap
    int type -> type
    int pass -> pass
    55:82:void <init>() -> <init>
    85:86:void setTex(int) -> setTex
    88:89:void setType(int) -> setType
    92:93:void die() -> die
    96:98:void setMotion(float,float,float) -> setMotion
    101:103:void setPos(float,float,float) -> setPos
    106:108:void setRot(float,float,float) -> setRot
    111:112:void setRotSpeed(float,float,float) -> setRotSpeed
    115:116:void setSize(float) -> setSize
    120:133:int store(int,java.nio.FloatBuffer,java.nio.IntBuffer) -> store
    137:156:int storeInterlacedStruct(int,nidefawl.qubes.shader.ShaderBuffer) -> storeInterlacedStruct
    159:177:int storeArrays(int,nidefawl.qubes.shader.ShaderBuffer) -> storeArrays
    181:197:void tick() -> tick
    200:204:void update(float) -> update
    207:208:void setTextureOffset(float,float) -> setTextureOffset
test.game.ParticlePerformanceTest2 -> test.game.ParticlePerformanceTest2:
    int MAX_PARTICLES -> MAX_PARTICLES
    int MAX_PARTICLES_PER_DRAW_CALL -> MAX_PARTICLES_PER_DRAW_CALL
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes_persistent_pooled -> ssbo_particle_cubes_persistent_pooled
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes2 -> ssbo_particle_cubes2
    int MAX_SPRITES -> MAX_SPRITES
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    boolean startup -> startup
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    int VERT_LEN1 -> VERT_LEN1
    int VERT_LEN2 -> VERT_LEN2
    nidefawl.qubes.font.FontRenderer font -> font
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> fbDeferred
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    nidefawl.qubes.shader.Shader skybox -> skybox
    nidefawl.qubes.shader.Shader particleShaderSSBO -> particleShaderSSBO
    nidefawl.qubes.shader.Shader particleShaderAttrBinding -> particleShaderAttrBinding
    int vao -> vao
    nidefawl.qubes.gl.GLTriBuffer cubeFormat1 -> cubeFormat1
    nidefawl.qubes.gl.GLAttrBuffer faceAttrBuffer -> faceAttrBuffer
    boolean once -> once
    boolean hadContext -> hadContext
    int fireUpdate -> fireUpdate
    float lastUpdate -> lastUpdate
    boolean pause -> pause
    float pauseTime -> pauseTime
    int totalSpritesRendered -> totalSpritesRendered
    int storedSprites -> storedSprites
    int tick -> tick
    int renderMode -> renderMode
    int selDrawMode -> selDrawMode
    boolean updateBuffers -> updateBuffers
    java.lang.String error -> error
    java.lang.String stats -> stats
    int maxSprites -> maxSprites
    int maxSpritesPerDraw -> maxSpritesPerDraw
    test.game.LinkedList particlesAlive -> particlesAlive
    test.game.LinkedList particlesDead -> particlesDead
    java.util.Random r -> r
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    nidefawl.qubes.gl.VertexBuffer bufferDataFace -> bufferDataFace
    int drawCalls -> drawCalls
    float SPEED -> SPEED
    long s -> s
    long lAvg10 -> lAvg10
    int spawnTicks -> spawnTicks
    195:990:void <init>() -> <init>
    203:206:void main(java.lang.String[]) -> main
    264:274:void initGame() -> initGame
    278:352:void initShaders() -> initShaders
    355:458:void lateInitGame() -> lateInitGame
    462:570:void onKeyPress(long,int,int,int,int) -> onKeyPress
    573:578:void onWindowResize(int,int) -> onWindowResize
    581:605:void setRenderResolution(int,int) -> setRenderResolution
    608:633:void onStatsUpdated() -> onStatsUpdated
    636:636:void onTextInput(long,int) -> onTextInput
    640:640:void onWheelScroll(long,double,double) -> onWheelScroll
    643:647:void postRenderUpdate(float) -> postRenderUpdate
    651:673:void preRenderUpdate(float) -> preRenderUpdate
    676:680:void preRenderUpdateParticles(float) -> preRenderUpdateParticles
    683:688:void redraw() -> redraw
    691:822:void render(float) -> render
    824:900:void renderParticles(float) -> renderParticles
    903:947:void spawnParticles(int) -> spawnParticles
    949:986:int storeParticles(float,int) -> storeParticles
    994:1044:void tick() -> tick
    1047:1057:void updateTickParticles() -> updateTickParticles
    36:36:float access$000() -> access$000
    40:259:void <clinit>() -> <clinit>
test.game.ParticlePerformanceTest2$1 -> test.game.ParticlePerformanceTest2$1:
    test.game.ParticlePerformanceTest2 this$0 -> this$0
    279:279:void <init>(test.game.ParticlePerformanceTest2) -> <init>
    282:288:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest2$2 -> test.game.ParticlePerformanceTest2$2:
    test.game.ParticlePerformanceTest2 this$0 -> this$0
    291:291:void <init>(test.game.ParticlePerformanceTest2) -> <init>
    294:300:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest2$3 -> test.game.ParticlePerformanceTest2$3:
    test.game.ParticlePerformanceTest2 this$0 -> this$0
    303:303:void <init>(test.game.ParticlePerformanceTest2) -> <init>
    306:309:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticlePerformanceTest2$4 -> test.game.ParticlePerformanceTest2$4:
    nidefawl.qubes.texture.array.TextureArray val$arr -> val$arr
    test.game.ParticlePerformanceTest2 this$0 -> this$0
    369:369:void <init>(test.game.ParticlePerformanceTest2,nidefawl.qubes.texture.array.TextureArray) -> <init>
    373:377:void pre() -> pre
    380:381:void post() -> post
    385:389:java.lang.Void call() -> call
    393:393:nidefawl.qubes.async.AsyncTask$TaskType getType() -> getType
    369:369:java.lang.Object call() -> call
test.game.ParticlePerformanceTest2$Particle -> test.game.ParticlePerformanceTest2$Particle:
    boolean dead -> dead
    int maxLive -> maxLive
    nidefawl.qubes.vec.Vector3f mot -> mot
    nidefawl.qubes.vec.Vector3f lastMot -> lastMot
    nidefawl.qubes.vec.Vector3f pos -> pos
    nidefawl.qubes.vec.Vector3f lastPos -> lastPos
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    nidefawl.qubes.vec.Vector3f renderRot -> renderRot
    nidefawl.qubes.vec.Vector3f rot -> rot
    nidefawl.qubes.vec.Vector3f lastRot -> lastRot
    nidefawl.qubes.vec.Vector3f rotspeed -> rotspeed
    nidefawl.qubes.vec.Vector2f texOffset -> texOffset
    float size -> size
    float initSize -> initSize
    float lastSize -> lastSize
    float renderSize -> renderSize
    int tick -> tick
    int tex -> tex
    int normalMap -> normalMap
    int type -> type
    int pass -> pass
    int color -> color
    46:74:void <init>() -> <init>
    76:78:void reset() -> reset
    81:82:void setTex(int) -> setTex
    84:85:void setType(int) -> setType
    88:89:void die() -> die
    92:94:void setMotion(float,float,float) -> setMotion
    97:99:void setPos(float,float,float) -> setPos
    102:104:void setRot(float,float,float) -> setRot
    107:108:void setRotSpeed(float,float,float) -> setRotSpeed
    111:112:void setSize(float) -> setSize
    115:141:int store(int,java.nio.FloatBuffer,java.nio.IntBuffer) -> store
    144:148:int store(int,nidefawl.qubes.gl.VertexBuffer) -> store
    152:170:void tick() -> tick
    173:178:void update(float) -> update
    181:182:void setTextureOffset(float,float) -> setTextureOffset
    45:45:int access$102(test.game.ParticlePerformanceTest2$Particle,int) -> access$102
test.game.ParticleTest -> test.game.ParticleTest:
    int MAX_PARTICLES -> MAX_PARTICLES
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes -> ssbo_particle_cubes
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes_blockinfo -> ssbo_particle_cubes_blockinfo
    int MAX_SPRITES -> MAX_SPRITES
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    boolean startup -> startup
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.font.FontRenderer font -> font
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> fbDeferred
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.GLTriBuffer cubeFormat1 -> cubeFormat1
    nidefawl.qubes.gl.GLTriBuffer cubeFormat2 -> cubeFormat2
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    nidefawl.qubes.shader.Shader skybox -> skybox
    nidefawl.qubes.shader.Shader spriteShader -> spriteShader
    nidefawl.qubes.gl.TesselatorState tessState -> tessState
    int texNoise -> texNoise
    boolean once -> once
    boolean hadContext -> hadContext
    int fireUpdate -> fireUpdate
    float lastUpdate -> lastUpdate
    boolean pause -> pause
    float pauseTime -> pauseTime
    int totalSpritesRendered -> totalSpritesRendered
    int storedSprites -> storedSprites
    int tick -> tick
    int renderMode -> renderMode
    int selFormat -> selFormat
    java.lang.String error -> error
    java.lang.String stats -> stats
    int maxSprites -> maxSprites
    java.util.List particles -> particles
    java.util.Random r -> r
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    136:185:void <init>() -> <init>
    141:144:void main(java.lang.String[]) -> main
    190:195:void initGame() -> initGame
    199:243:void initShaders() -> initShaders
    248:297:void lateInitGame() -> lateInitGame
    300:377:void onKeyPress(long,int,int,int,int) -> onKeyPress
    380:402:void setRenderResolution(int,int) -> setRenderResolution
    405:418:void onStatsUpdated() -> onStatsUpdated
    421:421:void onTextInput(long,int) -> onTextInput
    425:425:void onWheelScroll(long,double,double) -> onWheelScroll
    428:428:void postRenderUpdate(float) -> postRenderUpdate
    432:449:void preRenderUpdate(float) -> preRenderUpdate
    452:457:void preRenderUpdateParticles(float) -> preRenderUpdateParticles
    459:467:void redraw() -> redraw
    471:535:void render(float) -> render
    537:562:void renderParticles(float) -> renderParticles
    565:583:void spawnParticles(int) -> spawnParticles
    586:597:void storeParticles(float,int) -> storeParticles
    601:612:void tick() -> tick
    615:622:void updateTickParticles() -> updateTickParticles
    35:135:void <clinit>() -> <clinit>
test.game.ParticleTest$1 -> test.game.ParticleTest$1:
    test.game.ParticleTest this$0 -> this$0
    201:201:void <init>(test.game.ParticleTest) -> <init>
    204:207:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticleTest$Particle -> test.game.ParticleTest$Particle:
    boolean dead -> dead
    int maxLive -> maxLive
    nidefawl.qubes.vec.Vector3f mot -> mot
    nidefawl.qubes.vec.Vector3f lastMot -> lastMot
    nidefawl.qubes.vec.Vector3f pos -> pos
    nidefawl.qubes.vec.Vector3f lastPos -> lastPos
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    nidefawl.qubes.vec.Vector3f renderRot -> renderRot
    nidefawl.qubes.vec.Vector3f rot -> rot
    nidefawl.qubes.vec.Vector3f lastRot -> lastRot
    nidefawl.qubes.vec.Vector3f rotspeed -> rotspeed
    float size -> size
    float initSize -> initSize
    float lastSize -> lastSize
    float renderSize -> renderSize
    int texture -> texture
    int tick -> tick
    40:62:void <init>() -> <init>
    65:66:void die() -> die
    69:71:void setMotion(float,float,float) -> setMotion
    74:76:void setPos(float,float,float) -> setPos
    79:81:void setRot(float,float,float) -> setRot
    84:85:void setRotSpeed(float,float,float) -> setRotSpeed
    88:89:void setSize(float) -> setSize
    93:101:int store(java.nio.FloatBuffer) -> store
    105:121:void tick() -> tick
    124:128:void update(float) -> update
test.game.ParticleTextured -> test.game.ParticleTextured:
    int MAX_PARTICLES -> MAX_PARTICLES
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes -> ssbo_particle_cubes
    nidefawl.qubes.shader.ShaderBuffer ssbo_particle_cubes_blockinfo -> ssbo_particle_cubes_blockinfo
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    boolean startup -> startup
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.font.FontRenderer font -> font
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> fbDeferred
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.GLTriBuffer cubeFormat1 -> cubeFormat1
    nidefawl.qubes.gl.GLTriBuffer cubeFormat2 -> cubeFormat2
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    nidefawl.qubes.shader.Shader skybox -> skybox
    nidefawl.qubes.shader.Shader particleShaderSeperateBuffer -> particleShaderSeperateBuffer
    nidefawl.qubes.gl.TesselatorState tessState -> tessState
    boolean once -> once
    boolean hadContext -> hadContext
    int fireUpdate -> fireUpdate
    float lastUpdate -> lastUpdate
    boolean pause -> pause
    float pauseTime -> pauseTime
    int totalSpritesRendered -> totalSpritesRendered
    int storedSprites -> storedSprites
    int tick -> tick
    int renderMode -> renderMode
    int selFormat -> selFormat
    java.lang.String error -> error
    java.lang.String stats -> stats
    int maxSprites -> maxSprites
    java.util.List particles -> particles
    java.util.Random r -> r
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    boolean init -> init
    162:210:void <init>() -> <init>
    167:170:void main(java.lang.String[]) -> main
    216:226:void initGame() -> initGame
    230:282:void initShaders() -> initShaders
    286:385:void lateInitGame() -> lateInitGame
    388:465:void onKeyPress(long,int,int,int,int) -> onKeyPress
    468:490:void setRenderResolution(int,int) -> setRenderResolution
    493:506:void onStatsUpdated() -> onStatsUpdated
    509:509:void onTextInput(long,int) -> onTextInput
    513:513:void onWheelScroll(long,double,double) -> onWheelScroll
    516:516:void postRenderUpdate(float) -> postRenderUpdate
    520:537:void preRenderUpdate(float) -> preRenderUpdate
    540:545:void preRenderUpdateParticles(float) -> preRenderUpdateParticles
    547:555:void redraw() -> redraw
    559:623:void render(float) -> render
    625:650:void renderParticles(float) -> renderParticles
    653:679:void spawnParticles(int) -> spawnParticles
    682:702:void storeParticles(float,int) -> storeParticles
    706:722:void tick() -> tick
    725:732:void updateTickParticles() -> updateTickParticles
    39:161:void <clinit>() -> <clinit>
test.game.ParticleTextured$1 -> test.game.ParticleTextured$1:
    test.game.ParticleTextured this$0 -> this$0
    232:232:void <init>(test.game.ParticleTextured) -> <init>
    235:235:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticleTextured$2 -> test.game.ParticleTextured$2:
    test.game.ParticleTextured this$0 -> this$0
    238:238:void <init>(test.game.ParticleTextured) -> <init>
    241:244:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.ParticleTextured$3 -> test.game.ParticleTextured$3:
    nidefawl.qubes.texture.array.TextureArray val$arr -> val$arr
    test.game.ParticleTextured this$0 -> this$0
    300:300:void <init>(test.game.ParticleTextured,nidefawl.qubes.texture.array.TextureArray) -> <init>
    304:308:void pre() -> pre
    311:312:void post() -> post
    316:320:java.lang.Void call() -> call
    324:324:nidefawl.qubes.async.AsyncTask$TaskType getType() -> getType
    300:300:java.lang.Object call() -> call
test.game.ParticleTextured$Particle -> test.game.ParticleTextured$Particle:
    boolean dead -> dead
    int maxLive -> maxLive
    nidefawl.qubes.vec.Vector3f mot -> mot
    nidefawl.qubes.vec.Vector3f lastMot -> lastMot
    nidefawl.qubes.vec.Vector3f pos -> pos
    nidefawl.qubes.vec.Vector3f lastPos -> lastPos
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    nidefawl.qubes.vec.Vector3f renderRot -> renderRot
    nidefawl.qubes.vec.Vector3f rot -> rot
    nidefawl.qubes.vec.Vector3f lastRot -> lastRot
    nidefawl.qubes.vec.Vector3f rotspeed -> rotspeed
    nidefawl.qubes.vec.Vector2f texOffset -> texOffset
    float size -> size
    float initSize -> initSize
    float lastSize -> lastSize
    float renderSize -> renderSize
    int tick -> tick
    int tex -> tex
    int normalMap -> normalMap
    int type -> type
    int pass -> pass
    45:72:void <init>() -> <init>
    75:76:void setTex(int) -> setTex
    78:79:void setType(int) -> setType
    82:83:void die() -> die
    86:88:void setMotion(float,float,float) -> setMotion
    91:93:void setPos(float,float,float) -> setPos
    96:98:void setRot(float,float,float) -> setRot
    101:102:void setRotSpeed(float,float,float) -> setRotSpeed
    105:106:void setSize(float) -> setSize
    110:123:int store(int,java.nio.FloatBuffer,java.nio.IntBuffer) -> store
    128:144:void tick() -> tick
    147:151:void update(float) -> update
    154:155:void setTextureOffset(float,float) -> setTextureOffset
test.game.SkyboxSpriteTest -> test.game.SkyboxSpriteTest:
    int MAX_SPRITES -> MAX_SPRITES
    int SKYBOX_RES -> SKYBOX_RES
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> fbDeferred
    nidefawl.qubes.gl.FrameBuffer fbSkybox -> fbSkybox
    int tick -> tick
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    boolean startup -> startup
    nidefawl.qubes.gl.GLVBO vboAttr -> vboAttr
    nidefawl.qubes.gl.GLVBO vboStaticQuad -> vboStaticQuad
    nidefawl.qubes.gl.GLVBO vboIdx -> vboIdx
    nidefawl.qubes.shader.Shader spriteShader -> spriteShader
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    nidefawl.qubes.shader.Shader skyShader -> skyShader
    nidefawl.qubes.shader.Shader cloudsShader -> cloudsShader
    nidefawl.qubes.shader.Shader skybox -> skybox
    nidefawl.qubes.gl.TesselatorState skybox1 -> skybox1
    nidefawl.qubes.gl.TesselatorState skybox2 -> skybox2
    nidefawl.qubes.vec.Vector3f skyColor -> skyColor
    nidefawl.qubes.vec.Vector3f fogColor -> fogColor
    java.lang.String error -> error
    nidefawl.qubes.gl.CubeMapCamera cubeMatrix -> cubeMatrix
    int action -> action
    java.lang.String stats -> stats
    boolean once -> once
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    float curWeather -> curWeather
    float lastWeather -> lastWeather
    boolean renderIntoCubemap -> renderIntoCubemap
    boolean hadContext -> hadContext
    nidefawl.qubes.gl.VertexBuffer vertexBuf -> vertexBuf
    nidefawl.qubes.meshing.BlockFaceAttr attr -> attr
    int vaoPos -> vaoPos
    java.util.List clouds -> clouds
    java.nio.ByteBuffer bufMat -> bufMat
    java.nio.FloatBuffer bufMatFloat -> bufMatFloat
    nidefawl.qubes.gl.ReallocIntBuffer vertexUploadDirectBuf -> vertexUploadDirectBuf
    nidefawl.qubes.font.FontRenderer font -> font
    int storedSprites -> storedSprites
    int totalSpritesRendered -> totalSpritesRendered
    int[] texClouds -> texClouds
    int texNoise -> texNoise
    float WEATHER -> WEATHER
    int TIME -> TIME
    34:396:void <init>() -> <init>
    43:46:void main(java.lang.String[]) -> main
    77:128:void initShaders() -> initShaders
    142:165:void onStatsUpdated() -> onStatsUpdated
    169:169:void onTextInput(long,int) -> onTextInput
    173:207:void onKeyPress(long,int,int,int,int) -> onKeyPress
    214:267:void render(float) -> render
    270:303:void renderSky(float) -> renderSky
    312:326:void preRenderUpdate(float) -> preRenderUpdate
    330:330:void postRenderUpdate(float) -> postRenderUpdate
    337:364:void setRenderResolution(int,int) -> setRenderResolution
    368:375:void tick() -> tick
    379:385:void initGame() -> initGame
    398:403:void updateSprites(float) -> updateSprites
    405:418:void storeSprites(float,int) -> storeSprites
    422:426:void updateSpritesTick() -> updateSpritesTick
    428:510:void redraw() -> redraw
    512:516:void buildQuad(nidefawl.qubes.gl.VertexBuffer) -> buildQuad
    620:681:void lateInitGame() -> lateInitGame
    686:686:void onWheelScroll(long,double,double) -> onWheelScroll
    50:617:void <clinit>() -> <clinit>
test.game.SkyboxSpriteTest$1 -> test.game.SkyboxSpriteTest$1:
    test.game.SkyboxSpriteTest this$0 -> this$0
    82:82:void <init>(test.game.SkyboxSpriteTest) -> <init>
    85:88:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.SkyboxSpriteTest$Cloud -> test.game.SkyboxSpriteTest$Cloud:
    int texture -> texture
    java.util.List sprites -> sprites
    nidefawl.qubes.vec.Vector3f mot -> mot
    nidefawl.qubes.vec.Vector3f pos -> pos
    nidefawl.qubes.vec.Vector3f lastPos -> lastPos
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    520:529:void <init>() -> <init>
    531:539:int store(java.nio.FloatBuffer) -> store
    542:547:void update(float) -> update
    550:555:void tick() -> tick
test.game.SkyboxSpriteTest$PointSprite -> test.game.SkyboxSpriteTest$PointSprite:
    float size -> size
    float initSize -> initSize
    float lastSize -> lastSize
    float renderSize -> renderSize
    float rotspeed -> rotspeed
    float rot -> rot
    float lastRot -> lastRot
    float renderRot -> renderRot
    float xoffset -> xoffset
    float yoffset -> yoffset
    nidefawl.qubes.vec.Vector3f posOffset -> posOffset
    nidefawl.qubes.vec.Vector3f col -> col
    nidefawl.qubes.vec.Vector3f lastCol -> lastCol
    nidefawl.qubes.vec.Vector3f initCol -> initCol
    nidefawl.qubes.vec.Vector3f renderCol -> renderCol
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    int tick -> tick
    566:574:void <init>() -> <init>
    576:577:void setSize(float) -> setSize
    579:583:void setCol(float,float,float) -> setCol
    585:600:void update(float) -> update
    603:614:void tick() -> tick
    557:557:nidefawl.qubes.vec.Vector3f access$000(test.game.SkyboxSpriteTest$PointSprite) -> access$000
test.game.SkyboxTest -> test.game.SkyboxTest:
    int MAX_SPRITES -> MAX_SPRITES
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> fbDeferred
    int tick -> tick
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    boolean startup -> startup
    nidefawl.qubes.gl.GLVBO vboMat -> vboMat
    nidefawl.qubes.gl.GLVBO vboQuad -> vboQuad
    nidefawl.qubes.gl.GLVBO vboIdx -> vboIdx
    nidefawl.qubes.shader.Shader spriteShader -> spriteShader
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    nidefawl.qubes.shader.Shader skyShader -> skyShader
    nidefawl.qubes.shader.Shader cloudsShader -> cloudsShader
    nidefawl.qubes.gl.TesselatorState skybox1 -> skybox1
    nidefawl.qubes.gl.TesselatorState skybox2 -> skybox2
    nidefawl.qubes.vec.Vector3f skyColor -> skyColor
    nidefawl.qubes.vec.Vector3f fogColor -> fogColor
    java.lang.String error -> error
    int action -> action
    java.lang.String stats -> stats
    boolean once -> once
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    boolean hadContext -> hadContext
    nidefawl.qubes.gl.VertexBuffer vertexBuf -> vertexBuf
    nidefawl.qubes.meshing.BlockFaceAttr attr -> attr
    int vaoPos -> vaoPos
    java.util.List clouds -> clouds
    java.nio.ByteBuffer bufMat -> bufMat
    java.nio.FloatBuffer bufMatFloat -> bufMatFloat
    nidefawl.qubes.gl.ReallocIntBuffer vertexUploadDirectBuf -> vertexUploadDirectBuf
    int texCloud -> texCloud
    nidefawl.qubes.font.FontRenderer font -> font
    int totalSprites -> totalSprites
    int image -> image
    31:338:void <init>() -> <init>
    37:42:void main(java.lang.String[]) -> main
    68:117:void initShaders() -> initShaders
    122:150:void onStatsUpdated() -> onStatsUpdated
    154:154:void onTextInput(long,int) -> onTextInput
    158:168:void onKeyPress(long,int,int,int,int) -> onKeyPress
    174:262:void render(float) -> render
    267:280:void preRenderUpdate(float) -> preRenderUpdate
    284:284:void postRenderUpdate(float) -> postRenderUpdate
    291:312:void setRenderResolution(int,int) -> setRenderResolution
    316:318:void tick() -> tick
    322:327:void initGame() -> initGame
    341:351:void updateSprites(float) -> updateSprites
    353:357:void updateSpritesTick() -> updateSpritesTick
    359:441:void redraw() -> redraw
    443:447:void buildQuad(nidefawl.qubes.gl.VertexBuffer) -> buildQuad
    524:577:void lateInitGame() -> lateInitGame
    582:582:void onWheelScroll(long,double,double) -> onWheelScroll
    46:171:void <clinit>() -> <clinit>
test.game.SkyboxTest$1 -> test.game.SkyboxTest$1:
    test.game.SkyboxTest this$0 -> this$0
    72:72:void <init>(test.game.SkyboxTest) -> <init>
    75:78:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.SkyboxTest$Cloud -> test.game.SkyboxTest$Cloud:
    java.util.List sprites -> sprites
    nidefawl.qubes.vec.Vector3f mot -> mot
    nidefawl.qubes.vec.Vector3f pos -> pos
    nidefawl.qubes.vec.Vector3f lastPos -> lastPos
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    449:458:void <init>() -> <init>
    460:468:int store(java.nio.FloatBuffer) -> store
    471:476:void update(float) -> update
    478:483:void tick() -> tick
test.game.SkyboxTest$PointSprite -> test.game.SkyboxTest$PointSprite:
    float size -> size
    float rotspeed -> rotspeed
    float rot -> rot
    float lastRot -> lastRot
    float renderRot -> renderRot
    float xoffset -> xoffset
    float yoffset -> yoffset
    nidefawl.qubes.vec.Vector3f posOffset -> posOffset
    nidefawl.qubes.vec.Vector3f col -> col
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    int tick -> tick
    494:499:void <init>() -> <init>
    501:514:void update(float) -> update
    516:519:void tick() -> tick
    485:485:nidefawl.qubes.vec.Vector3f access$000(test.game.SkyboxTest$PointSprite) -> access$000
test.game.TestBlending -> test.game.TestBlending:
    15:18:void <init>() -> <init>
    20:23:void main(java.lang.String[]) -> main
    28:29:void onStatsUpdated() -> onStatsUpdated
    35:35:void onTextInput(long,int) -> onTextInput
    41:41:void onKeyPress(long,int,int,int,int) -> onKeyPress
    47:47:void render(float) -> render
    53:53:void input(float) -> input
    57:58:void preRenderUpdate(float) -> preRenderUpdate
    64:64:void postRenderUpdate(float) -> postRenderUpdate
    68:71:void setRenderResolution(int,int) -> setRenderResolution
    77:77:void tick() -> tick
    81:85:void initGame() -> initGame
    89:109:void lateInitGame() -> lateInitGame
    119:119:void onWheelScroll(long,double,double) -> onWheelScroll
test.game.TestEarlyZDiscard -> test.game.TestEarlyZDiscard:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    int image -> image
    nidefawl.qubes.render.post.SMAA smaa -> smaa
    nidefawl.qubes.gl.FrameBuffer fb -> fb
    nidefawl.qubes.gl.FrameBuffer fb2 -> fb2
    int a -> a
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    nidefawl.qubes.shader.Shader shaderHeavy -> shaderHeavy
    nidefawl.qubes.shader.Shader shaderTexture -> shaderTexture
    22:89:void <init>() -> <init>
    29:32:void main(java.lang.String[]) -> main
    42:50:void onStatsUpdated() -> onStatsUpdated
    54:54:void onTextInput(long,int) -> onTextInput
    58:58:void onKeyPress(long,int,int,int,int) -> onKeyPress
    62:87:void render(float) -> render
    94:103:void preRenderUpdate(float) -> preRenderUpdate
    107:107:void postRenderUpdate(float) -> postRenderUpdate
    111:138:void setRenderResolution(int,int) -> setRenderResolution
    145:173:void loadShader() -> loadShader
    177:178:void tick() -> tick
    182:190:void initGame() -> initGame
    194:197:void lateInitGame() -> lateInitGame
    202:202:void onWheelScroll(long,double,double) -> onWheelScroll
test.game.TestEarlyZDiscard$1 -> test.game.TestEarlyZDiscard$1:
    test.game.TestEarlyZDiscard this$0 -> this$0
    157:157:void <init>(test.game.TestEarlyZDiscard) -> <init>
    161:163:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.TestFontRenderer -> test.game.TestFontRenderer:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    int image -> image
    nidefawl.qubes.render.post.SMAA smaa -> smaa
    nidefawl.qubes.gl.FrameBuffer fb -> fb
    nidefawl.qubes.gl.FrameBuffer fb2 -> fb2
    int a -> a
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    nidefawl.qubes.shader.Shader shaderHeavy -> shaderHeavy
    nidefawl.qubes.shader.Shader shaderTexture -> shaderTexture
    26:145:void <init>() -> <init>
    33:36:void main(java.lang.String[]) -> main
    46:55:void onStatsUpdated() -> onStatsUpdated
    59:59:void onTextInput(long,int) -> onTextInput
    63:63:void onKeyPress(long,int,int,int,int) -> onKeyPress
    68:143:void render(float) -> render
    150:158:void preRenderUpdate(float) -> preRenderUpdate
    162:162:void postRenderUpdate(float) -> postRenderUpdate
    166:193:void setRenderResolution(int,int) -> setRenderResolution
    200:228:void loadShader() -> loadShader
    232:233:void tick() -> tick
    237:246:void initGame() -> initGame
    250:253:void lateInitGame() -> lateInitGame
    258:258:void onWheelScroll(long,double,double) -> onWheelScroll
test.game.TestFontRenderer$1 -> test.game.TestFontRenderer$1:
    test.game.TestFontRenderer this$0 -> this$0
    212:212:void <init>(test.game.TestFontRenderer) -> <init>
    216:218:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.TestNanoVG -> test.game.TestNanoVG:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    org.lwjgl.nanovg.NVGColor colorA -> colorA
    org.lwjgl.nanovg.NVGColor colorB -> colorB
    org.lwjgl.nanovg.NVGColor colorC -> colorC
    long vg -> vg
    int GRAPH_RENDER_FPS -> GRAPH_RENDER_FPS
    int GRAPH_RENDER_MS -> GRAPH_RENDER_MS
    int GRAPH_RENDER_PERCENT -> GRAPH_RENDER_PERCENT
    int GRAPH_HISTORY_COUNT -> GRAPH_HISTORY_COUNT
    test.game.TestNanoVG$PerfGraph fps -> fps
    test.game.TestNanoVG$DemoData data -> data
    int image -> image
    nidefawl.qubes.render.post.SMAA smaa -> smaa
    nidefawl.qubes.gl.FrameBuffer fb -> fb
    nidefawl.qubes.gl.FrameBuffer fb2 -> fb2
    int a -> a
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    nidefawl.qubes.shader.Shader shaderHeavy -> shaderHeavy
    nidefawl.qubes.shader.Shader shaderTexture -> shaderTexture
    53:58:org.lwjgl.nanovg.NVGColor rgba(int,int,int,int,org.lwjgl.nanovg.NVGColor) -> rgba
    89:118:int loadDemoData(long,test.game.TestNanoVG$DemoData) -> loadDemoData
    121:124:java.nio.ByteBuffer resizeBuffer(java.nio.ByteBuffer,int) -> resizeBuffer
    140:177:java.nio.ByteBuffer ioResourceToByteBuffer(java.lang.String,int) -> ioResourceToByteBuffer
    182:184:java.nio.ByteBuffer loadResource(java.lang.String,int) -> loadResource
    194:198:void initGraph(test.game.TestNanoVG$PerfGraph,int,java.lang.String) -> initGraph
    201:203:void updateGraph(test.game.TestNanoVG$PerfGraph,float) -> updateGraph
    206:210:float getGraphAverage(test.game.TestNanoVG$PerfGraph) -> getGraphAverage
    214:288:void renderGraph(long,float,float,test.game.TestNanoVG$PerfGraph) -> renderGraph
    47:427:void <init>() -> <init>
    294:297:void main(java.lang.String[]) -> main
    307:316:void onStatsUpdated() -> onStatsUpdated
    320:320:void onTextInput(long,int) -> onTextInput
    324:324:void onKeyPress(long,int,int,int,int) -> onKeyPress
    328:404:void render(float) -> render
    406:408:void nvgStart() -> nvgStart
    410:425:void nvgEnd() -> nvgEnd
    432:442:void preRenderUpdate(float) -> preRenderUpdate
    446:446:void postRenderUpdate(float) -> postRenderUpdate
    450:477:void setRenderResolution(int,int) -> setRenderResolution
    484:512:void loadShader() -> loadShader
    516:517:void tick() -> tick
    521:539:void initGame() -> initGame
    543:546:void lateInitGame() -> lateInitGame
    551:551:void onWheelScroll(long,double,double) -> onWheelScroll
    49:51:void <clinit>() -> <clinit>
test.game.TestNanoVG$1 -> test.game.TestNanoVG$1:
    test.game.TestNanoVG this$0 -> this$0
    496:496:void <init>(test.game.TestNanoVG) -> <init>
    500:502:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.TestNanoVG$DemoData -> test.game.TestNanoVG$DemoData:
    java.nio.ByteBuffer entypo -> entypo
    java.nio.ByteBuffer RobotoRegular -> RobotoRegular
    java.nio.ByteBuffer RobotoBold -> RobotoBold
    int fontNormal -> fontNormal
    int fontBold -> fontBold
    int fontIcons -> fontIcons
    int[] images -> images
    73:83:void <init>() -> <init>
test.game.TestNanoVG$PerfGraph -> test.game.TestNanoVG$PerfGraph:
    int style -> style
    java.nio.ByteBuffer name -> name
    float[] values -> values
    int head -> head
    67:70:void <init>() -> <init>
test.game.TestNoise -> test.game.TestNoise:
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    boolean startup -> startup
    int TEX_SIZE -> TEX_SIZE
    java.lang.String error -> error
    java.lang.String stats -> stats
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer buf -> buf
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.TesselatorState tessState -> tessState
    int reloadtick -> reloadtick
    java.util.Random rand -> rand
    int frame -> frame
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    boolean hadContext -> hadContext
    nidefawl.qubes.texture.array.TextureArray arr -> arr
    nidefawl.qubes.shader.Shader shader -> shader
    36:129:void <init>() -> <init>
    41:46:void main(java.lang.String[]) -> main
    59:74:void onStatsUpdated() -> onStatsUpdated
    78:78:void onTextInput(long,int) -> onTextInput
    82:82:void onKeyPress(long,int,int,int,int) -> onKeyPress
    88:109:void render(float) -> render
    114:123:void preRenderUpdate(float) -> preRenderUpdate
    127:127:void postRenderUpdate(float) -> postRenderUpdate
    134:184:void setRenderResolution(int,int) -> setRenderResolution
    188:189:void tick() -> tick
    193:198:void initGame() -> initGame
    202:293:void lateInitGame() -> lateInitGame
    298:321:void initShaders() -> initShaders
    325:325:void onWheelScroll(long,double,double) -> onWheelScroll
    33:34:void <clinit>() -> <clinit>
test.game.TestNoise$1 -> test.game.TestNoise$1:
    test.game.TestNoise this$0 -> this$0
    238:238:void <init>(test.game.TestNoise,int) -> <init>
    242:261:void uploadTextures() -> uploadTextures
    265:271:void postUpload() -> postUpload
    274:276:void load() -> load
    280:288:void collectTextures(nidefawl.qubes.assets.AssetManager) -> collectTextures
test.game.TestPointSprites -> test.game.TestPointSprites:
    int MAX_SPRITES -> MAX_SPRITES
    nidefawl.qubes.input.KeybindManager movement -> movement
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> fbDeferred
    int tick -> tick
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    boolean startup -> startup
    nidefawl.qubes.gl.GLVBO vboMat -> vboMat
    nidefawl.qubes.gl.GLVBO vboQuad -> vboQuad
    nidefawl.qubes.gl.GLVBO vboIdx -> vboIdx
    nidefawl.qubes.shader.Shader spriteShader -> spriteShader
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    nidefawl.qubes.vec.Vector3f skyColor -> skyColor
    nidefawl.qubes.vec.Vector3f fogColor -> fogColor
    int action -> action
    java.lang.String stats -> stats
    boolean once -> once
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    boolean hadContext -> hadContext
    nidefawl.qubes.gl.VertexBuffer vertexBuf -> vertexBuf
    nidefawl.qubes.meshing.BlockFaceAttr attr -> attr
    int vaoPos -> vaoPos
    java.util.List clouds -> clouds
    java.nio.ByteBuffer bufMat -> bufMat
    java.nio.FloatBuffer bufMatFloat -> bufMatFloat
    nidefawl.qubes.gl.ReallocIntBuffer vertexUploadDirectBuf -> vertexUploadDirectBuf
    int texCloud -> texCloud
    nidefawl.qubes.font.FontRenderer font -> font
    int totalSprites -> totalSprites
    30:276:void <init>() -> <init>
    37:42:void main(java.lang.String[]) -> main
    62:103:void initShaders() -> initShaders
    108:123:void onStatsUpdated() -> onStatsUpdated
    127:127:void onTextInput(long,int) -> onTextInput
    131:141:void onKeyPress(long,int,int,int,int) -> onKeyPress
    147:204:void render(float) -> render
    209:218:void preRenderUpdate(float) -> preRenderUpdate
    222:222:void postRenderUpdate(float) -> postRenderUpdate
    229:250:void setRenderResolution(int,int) -> setRenderResolution
    254:256:void tick() -> tick
    260:265:void initGame() -> initGame
    278:288:void updateSprites(float) -> updateSprites
    290:294:void updateSpritesTick() -> updateSpritesTick
    296:335:void redraw() -> redraw
    337:341:void buildQuad(nidefawl.qubes.gl.VertexBuffer) -> buildQuad
    418:462:void lateInitGame() -> lateInitGame
    467:467:void onWheelScroll(long,double,double) -> onWheelScroll
    46:144:void <clinit>() -> <clinit>
test.game.TestPointSprites$1 -> test.game.TestPointSprites$1:
    test.game.TestPointSprites this$0 -> this$0
    65:65:void <init>(test.game.TestPointSprites) -> <init>
    68:71:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.TestPointSprites$Cloud -> test.game.TestPointSprites$Cloud:
    java.util.List sprites -> sprites
    nidefawl.qubes.vec.Vector3f mot -> mot
    nidefawl.qubes.vec.Vector3f pos -> pos
    nidefawl.qubes.vec.Vector3f lastPos -> lastPos
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    343:352:void <init>() -> <init>
    354:362:int store(java.nio.FloatBuffer) -> store
    365:370:void update(float) -> update
    372:377:void tick() -> tick
test.game.TestPointSprites$PointSprite -> test.game.TestPointSprites$PointSprite:
    float size -> size
    float rotspeed -> rotspeed
    float rot -> rot
    float lastRot -> lastRot
    float renderRot -> renderRot
    float xoffset -> xoffset
    float yoffset -> yoffset
    nidefawl.qubes.vec.Vector3f posOffset -> posOffset
    nidefawl.qubes.vec.Vector3f col -> col
    nidefawl.qubes.vec.Vector3f renderPos -> renderPos
    int tick -> tick
    388:393:void <init>() -> <init>
    395:408:void update(float) -> update
    410:413:void tick() -> tick
    379:379:nidefawl.qubes.vec.Vector3f access$000(test.game.TestPointSprites$PointSprite) -> access$000
test.game.TestSMAA -> test.game.TestSMAA:
    boolean SRGB -> SRGB
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    int image -> image
    nidefawl.qubes.render.post.SMAA smaa -> smaa
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    nidefawl.qubes.assets.AssetTexture t -> t
    boolean once -> once
    nidefawl.qubes.shader.Shader shaderGammaToLin -> shaderGammaToLin
    nidefawl.qubes.shader.Shader shaderLinToGamma -> shaderLinToGamma
    boolean locked -> locked
    int lx -> lx
    int ly -> ly
    int drawMode -> drawMode
    nidefawl.qubes.gl.FrameBuffer outputBuffer -> outputBuffer
    boolean renderPixelInspector -> renderPixelInspector
    int[] texData -> texData
    int texW -> texW
    int texH -> texH
    nidefawl.qubes.font.FontRenderer font -> font
    27:251:void <init>() -> <init>
    33:36:void main(java.lang.String[]) -> main
    51:64:void onStatsUpdated() -> onStatsUpdated
    67:91:void initShaders() -> initShaders
    94:94:void onTextInput(long,int) -> onTextInput
    101:133:void onKeyPress(long,int,int,int,int) -> onKeyPress
    139:249:void render(float) -> render
    256:270:void readImage(int) -> readImage
    273:284:void preRenderUpdate(float) -> preRenderUpdate
    288:288:void postRenderUpdate(float) -> postRenderUpdate
    292:301:void setRenderResolution(int,int) -> setRenderResolution
    305:306:void tick() -> tick
    310:315:void initGame() -> initGame
    319:328:void lateInitGame() -> lateInitGame
    333:333:void onWheelScroll(long,double,double) -> onWheelScroll
test.game.TestSMAA$1 -> test.game.TestSMAA$1:
    test.game.TestSMAA this$0 -> this$0
    73:73:void <init>(test.game.TestSMAA) -> <init>
    76:79:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.TestSMAA$2 -> test.game.TestSMAA$2:
    test.game.TestSMAA this$0 -> this$0
    82:82:void <init>(test.game.TestSMAA) -> <init>
    85:88:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.TestSSAO -> test.game.TestSSAO:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer buf -> buf
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.TesselatorState tessState -> tessState
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    boolean hadContext -> hadContext
    23:91:void <init>() -> <init>
    32:37:void main(java.lang.String[]) -> main
    42:43:void onStatsUpdated() -> onStatsUpdated
    47:47:void onTextInput(long,int) -> onTextInput
    51:51:void onKeyPress(long,int,int,int,int) -> onKeyPress
    55:71:void render(float) -> render
    76:85:void preRenderUpdate(float) -> preRenderUpdate
    89:89:void postRenderUpdate(float) -> postRenderUpdate
    94:144:void setRenderResolution(int,int) -> setRenderResolution
    148:149:void tick() -> tick
    153:158:void initGame() -> initGame
    162:198:void lateInitGame() -> lateInitGame
    203:203:void onWheelScroll(long,double,double) -> onWheelScroll
test.game.TestShaderTextInput -> test.game.TestShaderTextInput:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    int image -> image
    nidefawl.qubes.gl.FrameBuffer fb2 -> fb2
    int a -> a
    boolean down -> down
    boolean first -> first
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    nidefawl.qubes.shader.Shader shaderHeavy -> shaderHeavy
    nidefawl.qubes.font.FontRenderer font -> font
    nidefawl.qubes.font.TextInput text -> text
    float lastMx -> lastMx
    float lastMy -> lastMy
    23:43:void <init>() -> <init>
    31:34:void main(java.lang.String[]) -> main
    51:60:void onStatsUpdated() -> onStatsUpdated
    64:65:void onTextInput(long,int) -> onTextInput
    69:72:void onKeyPress(long,int,int,int,int) -> onKeyPress
    76:136:void render(float) -> render
    140:151:void updateMousePos() -> updateMousePos
    154:164:void preRenderUpdate(float) -> preRenderUpdate
    168:169:void postRenderUpdate(float) -> postRenderUpdate
    173:187:void setRenderResolution(int,int) -> setRenderResolution
    192:214:void loadShader() -> loadShader
    219:220:void tick() -> tick
    224:233:void initGame() -> initGame
    237:239:void lateInitGame() -> lateInitGame
    244:244:void onWheelScroll(long,double,double) -> onWheelScroll
    248:248:void submit(nidefawl.qubes.font.TextInput) -> submit
    252:252:void onEscape(nidefawl.qubes.font.TextInput) -> onEscape
test.game.TestShaderToy -> test.game.TestShaderToy:
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    boolean startup -> startup
    java.lang.String error -> error
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    int image -> image
    nidefawl.qubes.gl.FrameBuffer fb2 -> fb2
    int a -> a
    boolean down -> down
    boolean first -> first
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    nidefawl.qubes.shader.Shader shaderHeavy -> shaderHeavy
    nidefawl.qubes.font.FontRenderer font -> font
    float lastMx -> lastMx
    float lastMy -> lastMy
    java.lang.String stats -> stats
    int reloadTick -> reloadTick
    31:60:void <init>() -> <init>
    44:47:void main(java.lang.String[]) -> main
    64:90:void onStatsUpdated() -> onStatsUpdated
    94:94:void onTextInput(long,int) -> onTextInput
    98:105:void onMouseClick(long,int,int,int) -> onMouseClick
    109:116:void onKeyPress(long,int,int,int,int) -> onKeyPress
    120:198:void render(float) -> render
    202:213:void updateMousePos() -> updateMousePos
    216:249:void preRenderUpdate(float) -> preRenderUpdate
    253:253:void postRenderUpdate(float) -> postRenderUpdate
    256:261:void onWindowResize(int,int) -> onWindowResize
    264:278:void setRenderResolution(int,int) -> setRenderResolution
    282:306:void loadShader() -> loadShader
    311:317:void tick() -> tick
    321:329:void initGame() -> initGame
    333:335:void lateInitGame() -> lateInitGame
    340:340:void onWheelScroll(long,double,double) -> onWheelScroll
    344:344:void submit(nidefawl.qubes.font.TextInput) -> submit
    348:348:void onEscape(nidefawl.qubes.font.TextInput) -> onEscape
    32:36:void <clinit>() -> <clinit>
test.game.TestThreadedWorker -> test.game.TestThreadedWorker:
    int WORK_LOAD -> WORK_LOAD
    boolean HIGH_COMPUTATIONAL_LOAD -> HIGH_COMPUTATIONAL_LOAD
    float[] inputData -> inputData
    java.util.Random r -> r
    test.game.TestThreadedWorker$WorkData data1 -> data1
    test.game.TestThreadedWorker$WorkData singleThreadedResult -> singleThreadedResult
    nidefawl.qubes.util.ThreadedWorker worker -> worker
    54:55:void main(java.lang.String[]) -> main
    60:62:void <init>() -> <init>
    64:101:void doStuff() -> doStuff
    103:105:test.game.TestThreadedWorker$WorkData runSingleThreaded() -> runSingleThreaded
    108:113:test.game.TestThreadedWorker$WorkData runMultiThreaded() -> runMultiThreaded
    117:118:void fromThread(int,int) -> fromThread
    11:17:void <clinit>() -> <clinit>
test.game.TestThreadedWorker$WorkData -> test.game.TestThreadedWorker$WorkData:
    float[] out -> out
    20:22:void <init>() -> <init>
    24:42:void process(int,int) -> process
    44:50:boolean isEqual(test.game.TestThreadedWorker$WorkData) -> isEqual
test.game.meshregion.MeshList -> test.game.meshregion.MeshList:
    test.game.meshregion.VMeshBuffer[] array -> array
    6:24:void <init>(java.lang.Class) -> <init>
    27:30:test.game.meshregion.VMeshBuffer getMesh(int,int) -> getMesh
    void bindVAO() -> bindVAO
    void init() -> init
    void draw() -> draw
    void reset() -> reset
    void upload(int,int) -> upload
    void addFace(nidefawl.qubes.meshing.BlockFaceAttr) -> addFace
    45:45:java.lang.String getName() -> getName
test.game.meshregion.MeshListInterleaved -> test.game.meshregion.MeshListInterleaved:
    int vao -> vao
    int VERT_LEN1 -> VERT_LEN1
    nidefawl.qubes.gl.VertexBuffer bufferDataVertex -> bufferDataVertex
    15:17:void <init>() -> <init>
    21:27:void init() -> init
    31:38:void draw() -> draw
    42:43:void bindVAO() -> bindVAO
    48:49:void addFace(nidefawl.qubes.meshing.BlockFaceAttr) -> addFace
    53:54:void reset() -> reset
    58:64:void upload(int,int) -> upload
    68:105:void setupVAO() -> setupVAO
    10:10:void <clinit>() -> <clinit>
test.game.meshregion.MeshListInterleavedNV -> test.game.meshregion.MeshListInterleavedNV:
    int vao -> vao
    int VERT_LEN1 -> VERT_LEN1
    nidefawl.qubes.gl.VertexBuffer bufferDataVertex -> bufferDataVertex
    int[] attrOffsets -> attrOffsets
    nidefawl.qubes.gl.MultiDrawIndirectBuffer buffer -> buffer
    boolean bindless -> bindless
    boolean first -> first
    18:44:void <init>(boolean) -> <init>
    28:34:void init() -> init
    38:43:void draw() -> draw
    46:57:void draw2() -> draw2
    59:74:void draw1() -> draw1
    78:79:void bindVAO() -> bindVAO
    84:85:void addFace(nidefawl.qubes.meshing.BlockFaceAttr) -> addFace
    89:91:void reset() -> reset
    95:101:void upload(int,int) -> upload
    105:152:void setupVAO() -> setupVAO
    154:154:java.lang.String getName() -> getName
    13:16:void <clinit>() -> <clinit>
test.game.meshregion.MeshListInterleavedNV_Half -> test.game.meshregion.MeshListInterleavedNV_Half:
    int vao -> vao
    int VERT_LEN1 -> VERT_LEN1
    nidefawl.qubes.gl.VertexBuffer bufferDataVertex -> bufferDataVertex
    int[] attrOffsets -> attrOffsets
    18:20:void <init>() -> <init>
    24:30:void init() -> init
    34:49:void draw() -> draw
    53:54:void bindVAO() -> bindVAO
    59:60:void addFace(nidefawl.qubes.meshing.BlockFaceAttr) -> addFace
    64:65:void reset() -> reset
    69:75:void upload(int,int) -> upload
    79:126:void setupVAO() -> setupVAO
    12:15:void <clinit>() -> <clinit>
test.game.meshregion.MeshListSeperate -> test.game.meshregion.MeshListSeperate:
    int vao -> vao
    int VERT_LEN1 -> VERT_LEN1
    int VERT_LEN2 -> VERT_LEN2
    nidefawl.qubes.gl.VertexBuffer bufferDataVertex -> bufferDataVertex
    nidefawl.qubes.gl.VertexBuffer bufferDataFace -> bufferDataFace
    17:20:void <init>() -> <init>
    23:30:void init() -> init
    34:42:void draw() -> draw
    46:47:void bindVAO() -> bindVAO
    50:52:void addFace(nidefawl.qubes.meshing.BlockFaceAttr) -> addFace
    55:57:void reset() -> reset
    60:68:void upload(int,int) -> upload
    73:111:void setupVAO() -> setupVAO
    10:10:void <clinit>() -> <clinit>
test.game.meshregion.VMeshBuffer -> test.game.meshregion.VMeshBuffer:
    int x -> x
    int z -> z
    3:3:void <init>() -> <init>
test.game.meshregion.VMeshBufferInterleaved -> test.game.meshregion.VMeshBufferInterleaved:
    nidefawl.qubes.gl.GLTriBuffer vertexBuffer -> vertexBuffer
    7:7:void <init>() -> <init>
test.game.meshregion.VMeshBufferInterleavedNV -> test.game.meshregion.VMeshBufferInterleavedNV:
    nidefawl.qubes.gl.GLTriBuffer vertexBuffer -> vertexBuffer
    5:5:void <init>() -> <init>
test.game.meshregion.VMeshBufferInterleavedNV_Half -> test.game.meshregion.VMeshBufferInterleavedNV_Half:
    nidefawl.qubes.gl.GLTriBuffer vertexBuffer -> vertexBuffer
    long addr -> addr
    long addrIdx -> addrIdx
    long size -> size
    long sizeIdx -> sizeIdx
    5:5:void <init>() -> <init>
test.game.meshregion.VMeshBufferSeperate -> test.game.meshregion.VMeshBufferSeperate:
    nidefawl.qubes.gl.GLTriBuffer vertexBuffer -> vertexBuffer
    nidefawl.qubes.gl.GLAttrBuffer faceAttrBuffer -> faceAttrBuffer
    7:7:void <init>() -> <init>
test.game.meshregion.VertexPointerTest -> test.game.meshregion.VertexPointerTest:
    int REGION_DIST -> REGION_DIST
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.FrameBuffer fbDeferred -> fbDeferred
    boolean hadContext -> hadContext
    boolean once -> once
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.vec.Vector3f skyColor -> skyColor
    nidefawl.qubes.vec.Vector3f fogColor -> fogColor
    int tick -> tick
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    boolean startup -> startup
    nidefawl.qubes.shader.Shader modelShader -> modelShader
    nidefawl.qubes.shader.Shader terrainShader -> terrainShader
    nidefawl.qubes.shader.Shader shaderDeferred -> shaderDeferred
    nidefawl.qubes.shader.Shader skyShader -> skyShader
    int action -> action
    java.lang.String stats -> stats
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    boolean reverse -> reverse
    test.game.meshregion.MeshList listIntNV_Half -> listIntNV_Half
    test.game.meshregion.MeshList listIntNVBuf -> listIntNVBuf
    test.game.meshregion.MeshList listIntNV -> listIntNV
    test.game.meshregion.MeshList listInt -> listInt
    test.game.meshregion.MeshList listSep -> listSep
    test.game.meshregion.MeshList[] lists -> lists
    int size -> size
    nidefawl.qubes.meshing.BlockFaceAttr attr -> attr
    nidefawl.qubes.texture.array.TextureArray arr -> arr
    nidefawl.qubes.gl.TesselatorState skybox1 -> skybox1
    nidefawl.qubes.gl.TesselatorState skybox2 -> skybox2
    nidefawl.qubes.font.FontRenderer font -> font
    29:429:void <init>() -> <init>
    44:49:void main(java.lang.String[]) -> main
    65:120:void initShaders() -> initShaders
    125:154:void onStatsUpdated() -> onStatsUpdated
    158:158:void onTextInput(long,int) -> onTextInput
    162:162:void onKeyPress(long,int,int,int,int) -> onKeyPress
    168:288:void render(float) -> render
    294:302:void preRenderUpdate(float) -> preRenderUpdate
    306:306:void postRenderUpdate(float) -> postRenderUpdate
    311:332:void setRenderResolution(int,int) -> setRenderResolution
    336:337:void tick() -> tick
    340:345:void initGame() -> initGame
    353:381:void redraw() -> redraw
    384:425:void drawFace(float,float,float,int) -> drawFace
    437:569:void lateInitGame() -> lateInitGame
    574:574:void onWheelScroll(long,double,double) -> onWheelScroll
    53:54:void <clinit>() -> <clinit>
test.game.meshregion.VertexPointerTest$1 -> test.game.meshregion.VertexPointerTest$1:
    test.game.meshregion.VertexPointerTest this$0 -> this$0
    67:67:void <init>(test.game.meshregion.VertexPointerTest) -> <init>
    70:73:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.meshregion.VertexPointerTest$2 -> test.game.meshregion.VertexPointerTest$2:
    test.game.meshregion.VertexPointerTest this$0 -> this$0
    76:76:void <init>(test.game.meshregion.VertexPointerTest) -> <init>
    80:83:java.lang.String getDefinition(java.lang.String) -> getDefinition
test.game.meshregion.VertexPointerTest$3 -> test.game.meshregion.VertexPointerTest$3:
    test.game.meshregion.VertexPointerTest this$0 -> this$0
    445:445:void <init>(test.game.meshregion.VertexPointerTest,int) -> <init>
    449:493:void uploadTextures() -> uploadTextures
    497:499:void findMaxTileWidth() -> findMaxTileWidth
    502:502:void collectTextures(nidefawl.qubes.assets.AssetManager) -> collectTextures
    506:523:void postUpload() -> postUpload
test.game.vr.VRApp -> test.game.vr.VRApp:
    test.game.vr.VRApp$InputSource selInputSource -> selInputSource
    nidefawl.qubes.util.SimpleResourceManager shaders -> shaders
    nidefawl.qubes.util.SimpleResourceManager newshaders -> newshaders
    nidefawl.qubes.input.CameraController cameraController -> cameraController
    nidefawl.qubes.gl.FrameBuffer sceneFB -> sceneFB
    nidefawl.qubes.gl.GLTriBuffer cube -> cube
    nidefawl.qubes.shader.Shader modelShader -> modelShader
    nidefawl.qubes.font.FontRenderer font -> font
    int tick -> tick
    int action -> action
    java.lang.String stats -> stats
    boolean startup -> startup
    boolean once -> once
    nidefawl.qubes.vec.Vector3f tmp -> tmp
    nidefawl.qubes.vec.Vec3D tmpPos -> tmpPos
    26:218:void <init>() -> <init>
    31:34:void main(java.lang.String[]) -> main
    57:75:void initShaders() -> initShaders
    79:105:void onStatsUpdated() -> onStatsUpdated
    109:109:void onTextInput(long,int) -> onTextInput
    113:120:void onKeyPress(long,int,int,int,int) -> onKeyPress
    125:161:void renderScene(float) -> renderScene
    165:216:void render(float) -> render
    221:228:void preRenderUpdate(float) -> preRenderUpdate
    232:232:void postRenderUpdate(float) -> postRenderUpdate
    237:242:void onWindowResize(int,int) -> onWindowResize
    245:263:void setRenderResolution(int,int) -> setRenderResolution
    267:268:void tick() -> tick
    272:277:void initGame() -> initGame
    280:284:void redraw() -> redraw
    288:295:void lateInitGame() -> lateInitGame
    300:300:void onWheelScroll(long,double,double) -> onWheelScroll
    39:40:void <clinit>() -> <clinit>
test.game.vr.VRApp$InputSource -> test.game.vr.VRApp$InputSource:
    test.game.vr.VRApp$InputSource MOUSE -> MOUSE
    test.game.vr.VRApp$InputSource HEADTRACKING -> HEADTRACKING
    test.game.vr.VRApp$InputSource[] $VALUES -> $VALUES
    35:35:test.game.vr.VRApp$InputSource[] values() -> values
    35:35:test.game.vr.VRApp$InputSource valueOf(java.lang.String) -> valueOf
    35:35:void <init>(java.lang.String,int) -> <init>
    35:36:void <clinit>() -> <clinit>
